NL,OCL,src,,
A Constraint cannot be applied to itself.,not constrainedElement->includes(self),1.1,,
Elements that must be owned must have an owner.,mustBeOwned() implies owner->notEmpty(),1.1,,
An element may not directly or indirectly own itself.,not allOwnedElements()->includes(self),1.1,,
An importedElement has either public visibility or no visibility at all.,importedElement.visibility <> null implies importedElement.visibility =VisibilityKind::public,1.1,,
The visibility of an ElementImport is either public or private.,visibility = VisibilityKind::public or visibility = VisibilityKind::private,1.1,,
The upper bound must be greater than or equal to the lower bound.,upperBound() >= lowerBound(),1.1,,
The lower bound must be a non-negative integer literal.,lowerBound() >= 0,1.1,,
"If it is not empty, then lowerValue must have an Integer value.",lowerValue <> null implies lowerValue.integerValue() <> null,1.1,,
"If it is not empty, then upperValue must have an UnlimitedNatural value.",upperValue <> null implies upperValue.unlimitedValue() <> null,1.1,,
"If a NamedElement is owned by something other than a Namespace, it does not have a visibility. One that is not owned by anything (and hence must be a Package, as this is the only kind of NamedElement that overrides mustBeOwned()) may have a visibility.",(namespace = null and owner <> null) implies visibility = null,1.1,,
"When there is a name, and all of the containing Namespaces have a name, the qualifiedName is constructed from the name of the NamedElement and the names of the containing Namespaces.",(name <> null and allNamespaces()->select(ns | ns.name = null)->isEmpty()) implies qualifiedName = allNamespaces()->iterate( ns : Namespace; agg: String = name | ns.name.concat(self.separator()).concat(agg)),1.1,,
"If there is no name, or one of the containing Namespaces has no name, there is no qualifiedName.",name=null or allNamespaces()->select( ns | ns.name=null )->notEmpty() implies qualifiedName = null,1.1,,
A Namespace cannot have a PackageImport to itself.,packageImport.importedPackage.oclAsType(Namespace)->excludes(self),1.1,,
A Namespace cannot have an ElementImport to one of its ownedMembers.,elementImport.importedElement.oclAsType(Element)->excludesAll(ownedMember),1.1,,
A PackageableElement owned by a Namespace must have a visibility.,visibility = null implies namespace = null,1.1,,
Each parameterSubstitution must refer to a formal TemplateParameter of the target TemplateSignature.,parameterSubstitution->forAll(b | signature.parameter->includes(b.formal)),1.1,,
A TemplateBiinding contains at most one TemplateParameterSubstitution for each formal TemplateParameter of the target TemplateSignature.,signature.parameter->forAll(p | parameterSubstitution->select(b | b.formal = p)->size() <= 1),1.1,,
The default must be compatible with the formal TemplateParameter,default <> null implies default.isCompatibleWith(parameteredElement),1.1,,
"The actual ParameterableElement must be compatible with the formal TemplateParameter, e.g., the actual ParameterableElement for a Class TemplateParameter must be a Class.",actual->forAll(a | a.isCompatibleWith(formal.parameteredElement)),1.1,,
Parameters must own the ParameterableElements they parameter or those ParameterableElements must be owned by the TemplateableElement being templated.,template.ownedElement->includesAll(parameter.parameteredElement->asSet() - parameter.ownedParameteredElement->asSet()),1.1,,
The names of the parameters of a TemplateSignature are unique.,"parameter->forAll( p1, p2 | (p1 <> p2 and p1.parameteredElement.oclIsKindOf(NamedElement) and p2.parameteredElement.oclIsKindOf(NamedElement) ) implies p1.parameteredElement.oclAsType(NamedElement).name <> p2.parameteredElement.oclAsType(NamedElement).name)",1.1,,
"If a Duration has no expr, then it must have a single observation that is a DurationObservation.",expr = null implies (observation->size() = 1 and observation->forAll(oclIsKindOf(DurationObservation))),1.1,,
The multiplicity of firstEvent must be 2 if the multiplicity of constrainedElement is 2. Otherwise the multiplicity of firstEvent is 0.,if (constrainedElement->size() = 2) then (firstEvent->size() = 2) else (firstEvent->size() = 0) endif,1.1,,
A DurationConstraint has either one or two constrainedElements,constrainedElement->size() = 1 or constrainedElement->size()=2,1.1,,
The multiplicity of firstEvent must be 2 if the multiplicity of event is 2. Otherwise the multiplicity of firstEvent is 0.,if (event->size() = 2) then (firstEvent->size() = 2) else (firstEvent->size() = 0) endif,1.1,,
"If the language attribute is not empty, then the size of the body and language arrays must be the same.",language->notEmpty() implies (_'body'->size() = language->size()),1.1,,
The behavior must have exactly one return result parameter.,behavior <> null implies behavior.ownedParameter->select(direction=ParameterDirectionKind::return)->size() = 1,1.1,,
The behavior may only have non-stream in or return parameters.,behavior <> null implies behavior.ownedParameter->forAll(not isStream and (direction=ParameterDirectionKind::in or direction=ParameterDirectionKind::return)),1.1,,
All the operands of a StringExpression must be LiteralStrings,operand->forAll (oclIsKindOf (LiteralString)),1.1,,
"If a StringExpression has sub-expressions, it cannot have operands and vice versa (this avoids the problem of having to define a collating sequence between operands and subexpressions).",if subExpression->notEmpty() then operand->isEmpty() else operand->notEmpty() endif,1.1,,
A TimeConstraint has one constrainedElement.,constrainedElement->size() = 1,1.1,,
"If a TimeExpression has no expr, then it must have a single observation that is a TimeObservation.",expr = null implies (observation->size() = 1 and observation- >forAll(oclIsKindOf(TimeObservation))),1.1,,
When isAbstract is true there are no methods.,isAbstract implies method->isEmpty(),1.1,,
A Classifier may only specialize Classifiers of a valid type.,parents()->forAll(c | self.maySpecializeType(c)),1.1,,
"The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances also be its subclasses.",powertypeExtent->forAll( gs | gs.generalization->forAll( gen | not (gen.general = self) and not gen.general.allParents()->includes(self) and not (gen.specific = self) and not self.allParents()->includes(gen.specific))),1.1,,
The parents of a Classifier must be non-final.,parents()->forAll(not isFinalSpecialization),1.1,,
Generalization hierarchies must be directed and acyclical. A Classifier can not be both a transitively general and transitively specific Classifier of the same Classifier.,not allParents()->includes(self),1.1,,
"If allowSubstitutable is true, then there must be a constrainingClassifier.",allowSubstitutable implies constrainingClassifier->notEmpty(),1.1,,
"The parameteredElement has no direct features, and if constrainedElement is empty it has no generalizations.",parameteredElement.feature->isEmpty() and (constrainingClassifier->isEmpty() implies parameteredElement.allParents()->isEmpty()),1.1,,
"If the parameteredElement is not abstract, then the Classifier used as an argument shall not be abstract.",(not parameteredElement.isAbstract) implies templateParameterSubstitution.actual- >forAll(a | not a.oclAsType(Classifier).isAbstract),1.1,,
The argument to a ClassifierTemplateParameter is a Classifier.,templateParameterSubstitution.actual->forAll(a | a.oclIsKindOf(Classifier)),1.1,,
"If there are any constrainingClassifiers, then every argument must be the same as or a specialization of them, or if allowSubstitutable is true, then it can also be substitutable.",templateParameterSubstitution.actual->forAll( a | let arg : Classifier = a.oclAsType(Classifier) in constrainingClassifier->forAll( cc | arg = cc or arg.conformsTo(cc) or (allowSubstitutable and arg.isSubstitutableFor(cc)) ) ),1.1,,
"If there are any constrainingClassifiers, then the parameteredElement must be the same as or a specialization of them, or if allowSubstitutable is true, then it can also be substitutable.",constrainingClassifier->forAll( cc | parameteredElement = cc or parameteredElement.conformsTo(cc) or (allowSubstitutable and parameteredElement.isSubstitutableFor(cc)) ),1.1,,
Every Generalization associated with a particular GeneralizationSet must have the same general Classifier.,generalization->collect(general)->asSet()->size() <= 1,1.1,,
"The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances be its subclasses.",powertype <> null implies generalization->forAll( gen | not (gen.general = powertype) and not gen.general.allParents()->includes(powertype) and not (gen.specific = powertype) and not powertype.allParents()->includes(gen.specific) ),1.1,,
An InstanceSpecification can act as a DeployedArtifact if it represents an instance of an Artifact.,deploymentForArtifact->notEmpty() implies classifier->exists(oclIsKindOf(Artifact)),1.1,,
No more than one slot in an InstanceSpecification may have the same definingFeature.,classifier->forAll(c | (c.allSlottableFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1))),1.1,,
"The definingFeature of each slot is a StructuralFeature related to a classifier of the InstanceSpecification, including direct attributes, inherited attributes, private attributes in generalizations, and memberEnds of Associations, but excluding redefined StructuralFeatures.",slot->forAll(s | classifier->exists (c | c.allSlottableFeatures()->includes (s.definingFeature))),1.1,,
An InstanceSpecification can act as a DeploymentTarget if it represents an instance of a Node and functions as a part in the internal structure of an encompassing Node.,deployment->notEmpty() implies classifier->exists(node | node.oclIsKindOf(Node) and Node.allInstances()->exists(n | n.part->exists(p | p.type = node))),1.1,,
"An Operation can have at most one return parameter; i.e., an owned parameter with the direction set to 'return.'",self.ownedParameter->select(direction = ParameterDirectionKind::return)->size() <= 1,1.1,,
A bodyCondition can only be specified for a query Operation.,bodyCondition <> null implies isQuery,1.1,,
"Only in and inout Parameters may have a delete effect. Only out, inout, and return Parameters may have a create effect.",(effect = ParameterEffectKind::delete implies (direction = ParameterDirectionKind::_'in' or direction = ParameterDirectionKind::inout)) and (effect = ParameterEffectKind::create implies (direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::return)),1.1,,
An input Parameter cannot be an exception.,isException implies (direction <> ParameterDirectionKind::_'in' and direction <> ParameterDirectionKind::inout),1.1,,
A Parameter may only be associated with a Connector end within the context of a Collaboration.,end->notEmpty() implies collaboration->notEmpty(),1.1,,
Reentrant behaviors cannot have stream Parameters.,(isStream and behavior <> null) implies not behavior.isReentrant,1.1,,
A Parameter cannot be a stream and exception at the same time.,not (isException and isStream),1.1,,
Parameters typed by DataTypes cannot have an effect.,(type.oclIsKindOf(DataType)) implies (effect = null),1.1,,
"The Parameters in a ParameterSet must all be inputs or all be outputs of the same parameterized entity, and the ParameterSet is owned by that entity.","parameter->forAll(p1, p2 | self.owner = p1.owner and self.owner = p2.owner and p1.direction = p2.direction)",1.1,,
"If a parameterized entity has input Parameters that are in a ParameterSet, then any inputs that are not in a ParameterSet must be streaming. Same for output Parameters.",((parameter->exists(direction = ParameterDirectionKind::_'in')) implies behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::_'in' and p.parameterSet->isEmpty())->forAll(isStream)) and ((parameter->exists(direction = ParameterDirectionKind::out)) implies behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::out and p.parameterSet->isEmpty())->forAll(isStream)),1.1,,
Two ParameterSets cannot have exactly the same set of Parameters.,"parameter->forAll(parameterSet->forAll(s1, s2 | s1->size() = s2->size() implies s1.parameter->exists(p | not s2.parameter->includes(p))))",1.1,,
Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.,subsettedProperty->notEmpty() implies (subsettingContext()->notEmpty() and subsettingContext()->forAll (sc | subsettedProperty->forAll(sp |sp.subsettingContext()->exists(c | sc.conformsTo(c))))),1.1,,
A multiplicity on the composing end of a composite aggregation must not have an upper bound greater than 1.,isComposite and association <> null implies opposite.upperBound() <= 1,1.1,,
A redefined Property must be inherited from a more general Classifier.,(redefinedProperty->notEmpty()) implies (redefinitionContext->notEmpty() and redefinedProperty->forAll(rp| ((redefinitionContext->collect(fc| fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp))),1.1,,
"A subsetting Property may strengthen the type of the subsetted Property, and its upper bound may be less.",subsettedProperty->forAll(sp | self.type.conformsTo(sp.type) and ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies self.upperBound() <= sp.upperBound() )),1.1,,
A binding of a PropertyTemplateParameter representing an attribute must be to an attribute.,(self.isAttribute() and (templateParameterSubstitution->notEmpty()) implies (templateParameterSubstitution->forAll(ts | ts.formal.oclIsKindOf(Property) and ts.formal.oclAsType(Property).isAttribute()))),1.1,,
A derived union is derived.,isDerivedUnion implies isDerived,1.1,,
A Property can be a DeploymentTarget if it is a kind of Node and functions as a part in the internal structure of an encompassing Node.,deployment->notEmpty() implies owner.oclIsKindOf(Node) and Node.allInstances()- >exists(n | n.part->exists(p | p = self)),1.1,,
A Property may not subset a Property with the same name.,subsettedProperty->forAll(sp | sp.name <> name),1.1,,
"If a Property is a classifier-owned end of a binary Association, its owner must be the type of the opposite end.",(opposite->notEmpty() and owningAssociation->isEmpty()) implies classifier = opposite.type,1.1,,
All qualified Properties must be Association ends,qualifier->notEmpty() implies association->notEmpty(),1.1,,
A redefining element must be consistent with each redefined element.,redefinedElement->forAll(re | re.isConsistentWith(self)),1.1,,
A RedefinableElement can only redefine non-leaf RedefinableElements.,redefinedElement->forAll(re | not re.isLeaf),1.1,,
At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.,redefinedElement->forAll(re | self.isRedefinitionContextValid(re)),1.1,,
"If any of the parent Classifiers are a template, then the extendedSignature must include the signature of that Classifier.",classifier.allParents()->forAll(c | c.ownedTemplateSignature->notEmpty() implies self->closure(extendedSignature)->includes(c.ownedTemplateSignature)),1.1,,
"If a behavior is classifier behavior, it does not have a specification.",classifierBehavior->notEmpty() implies classifierBehavior.specification->isEmpty(),1.1,,
immutable,ownedAttribute->forAll(isReadOnly),1.1,,
The visibility of all Features owned by an Interface must be public.,feature->forAll(visibility = VisibilityKind::public),1.1,,
A Reception has the same name as its signal,name = signal.name,1.1,,
"A Reception's parameters match the ownedAttributes of its signal by name, type, and multiplicity",signal.ownedAttribute->size() = ownedParameter->size() and Sequence{1..signal.ownedAttribute->size()}->forAll( i | ownedParameter->at(i).direction = ParameterDirectionKind::_'in' and ownedParameter->at(i).name = signal.ownedAttribute->at(i).name and ownedParameter->at(i).type = signal.ownedAttribute >at(i).type and ownedParameter->at(i).lowerBound() = signal.ownedAttribute->at(i).lowerBound() and ownedParameter->at(i).upperBound() = signal.ownedAttribute->at(i).upperBound()),1.1,,
An Association specializing another Association has the same number of ends as the other Association.,parents()->select(oclIsKindOf(Association)).oclAsType(Association)->forAll(p | p.memberEnd->size() = self.memberEnd->size()),1.1,,
"When an Association specializes another Association, every end of the specific Association corresponds to an end of the general Association, and the specific end reaches the same type or a subtype of the corresponding general end.",Sequence{1..memberEnd->size()}-> forAll(i | general->select(oclIsKindOf(Association)).oclAsType(Association)-> forAll(ga | self.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type))),1.1,,
Only binary Associations can be aggregations.,memberEnd->exists(aggregation <> AggregationKind::none) implies (memberEnd->size() = 2 and memberEnd->exists(aggregation = AggregationKind::none)),1.1,,
Ends of Associations with more than two ends must be owned by the Association itself.,memberEnd->size() > 2 implies ownedEnd->includesAll(memberEnd),1.1,,
An AssociationClass cannot be defined between itself and something else.,self.endType()->excludes(self) and self.endType()->collect(et| et.oclAsType(Classifier).allParents())->flatten()->excludes(self),1.1,,
The owned attributes and owned ends of an AssociationClass are disjoint.,ownedAttribute->intersection(ownedEnd)->isEmpty(),1.1,,
Only an active Class may own Receptions and have a classifierBehavior.,not isActive implies (ownedReception->isEmpty() and classifierBehavior = null),1.1,,
All the client elements of a roleBinding are in one Classifier and all supplier elements of a roleBinding are in one Collaboration.,"roleBinding->collect(client)->forAll(ne1, ne2 |
ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and
let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 :
ConnectableElement = ne2.oclAsType(ConnectableElement) in
ce1.structuredClassifier = ce2.structuredClassifier)
and
roleBinding->collect(supplier)->forAll(ne1, ne2 |
ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and
let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 :
ConnectableElement = ne2.oclAsType(ConnectableElement) in
ce1.collaboration = ce2.collaboration)",1.1,,
Every collaborationRole in the Collaboration is bound within the CollaborationUse.,type.collaborationRole->forAll(role | roleBinding->exists(rb | rb.supplier->includes(role))),1.1,,
"Connectors in a Collaboration typing a CollaborationUse must have corresponding Connectors between elements bound in the context Classifier, and these corresponding Connectors must have the same or more general type than the Collaboration Connectors.","type.ownedConnector->forAll(connector |
let rolesConnectedInCollab : Set(ConnectableElement) = connector.end.role->asSet(),
relevantBindings : Set(Dependency) = roleBinding->select(rb | rb.supplier-
>intersection(rolesConnectedInCollab)->notEmpty()),
boundRoles : Set(ConnectableElement) = relevantBindings-
>collect(client.oclAsType(ConnectableElement))->asSet(),
contextClassifier : StructuredClassifier = boundRoles-
>any(true).structuredClassifier->any(true) in
contextClassifier.ownedConnector->exists( correspondingConnector |
correspondingConnector.end.role->forAll( role | boundRoles->includes(role) )
and (connector.type->notEmpty() and correspondingConnector.type->notEmpty())
implies connector.type->forAll(conformsTo(correspondingConnector.type)) )
)",1.1,,
A Component cannot nest Classifiers.,nestedClassifier->isEmpty(),1.1,,
A Component nested in a Class cannot have any packaged elements.,nestingClass <> null implies packagedElement->isEmpty(),1.1,,
"The types of the ConnectableElements that the ends of a Connector are attached to must conform to the types of the ends of the Association that types the Connector, if any.","type<>null implies
let noOfEnds : Integer = end->size() in
(type.memberEnd->size() = noOfEnds) and Sequence{1..noOfEnds}->forAll(i | end-
>at(i).role.type.conformsTo(type.memberEnd->at(i).type))",1.1,,
"The ConnectableElements attached as roles to each ConnectorEnd owned by a Connector must be owned or inherited roles of the Classifier that owned the Connector, or they must be Ports of such roles.","structuredClassifier <> null
and
end->forAll( e | structuredClassifier.allRoles()->includes(e.role)
or
e.role.oclIsKindOf(Port) and structuredClassifier.allRoles()->includes(e.partWithPort))",1.1,,
"If a ConnectorEnd references a partWithPort, then the role must be a Port that is defined or inherited by the type of the partWithPort.","partWithPort->notEmpty() implies
(role.oclIsKindOf(Port) and partWithPort.type.oclAsType(Namespace).member->includes(role))",1.1,,
"If a ConnectorEnd is attached to a Port of the containing Classifier, partWithPort will be empty.",(role.oclIsKindOf(Port) and role.owner = connector.owner) implies partWithPort->isEmpty(),1.1,,
"The multiplicity of the ConnectorEnd may not be more general than the multiplicity of the corresponding end of the Association typing the owning Connector, if any.",self.compatibleWith(definingEnd),1.1,,
The Property held in self.partWithPort must not be a Port.,partWithPort->notEmpty() implies not partWithPort.oclIsKindOf(Port),1.1,,
Port.aggregation must be composite.,aggregation = AggregationKind::composite,1.1,,
A defaultValue for port cannot be specified when the type of the Port is an Interface.,type.oclIsKindOf(Interface) implies defaultValue->isEmpty(),1.1,,
All Ports are owned by an EncapsulatedClassifier.,owner = encapsulatedClassifier,1.1,,
The non-owned end of an Extension is typed by a Class.,metaclassEnd()->notEmpty() and metaclassEnd().type.oclIsKindOf(Class),1.1,,
"An Extension is binary, i.e., it has only two memberEnds.",memberEnd->size() = 2,1.1,,
The multiplicity of ExtensionEnd is 0..1 or 1.,(lowerBound() = 0 or lowerBound() = 1) and upperBound() = 1,1.1,,
The aggregation of an ExtensionEnd is composite.,self.aggregation = AggregationKind::composite,1.1,,
"If an element that is owned by a package has visibility, it is public or private.","packagedElement->forAll(e | e.visibility<> null implies e.visibility =
VisibilityKind::public or e.visibility = VisibilityKind::private)",1.1,,
An element imported as a metaclassReference is not specialized or generalized in a Profile.,"metaclassReference.importedElement->
select(c | c.oclIsKindOf(Classifier) and
(c.oclAsType(Classifier).allParents()->collect(namespace)->includes(self)))-
>isEmpty()
and
packagedElement->
select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier).allParents())->
intersection(metaclassReference.importedElement->select(oclIsKindOf(Classifier))-
>collect(oclAsType(Classifier)))->isEmpty()",1.1,,
All elements imported either as metaclassReferences or through metamodelReferences are members of the same base reference metamodel.,"metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()->
union(metaclassReference.importedElement.allOwningPackages() )->notEmpty()",1.1,,
Stereotypes may only participate in binary associations.,ownedAttribute.association->forAll(memberEnd->size()=2),1.1,,
A Stereotype may only generalize or specialize another Stereotype.,"allParents()->forAll(oclIsKindOf(Stereotype))
and Classifier.allInstances()->forAll(c | c.allParents()->exists(oclIsKindOf(Stereotype))
implies c.oclIsKindOf(Stereotype))",1.1,,
"Where a stereotype’s property is an association end for an association other than a kind of extension, and the other end is not a stereotype, the other end must be owned by the association itself.","ownedAttribute
->select(association->notEmpty() and not association.oclIsKindOf(Extension) and not
type.oclIsKindOf(Stereotype))
->forAll(opposite.owner = association)",1.1,,
There may be at most one Behavior for a given pairing of BehavioredClassifier (as owner of the Behavior) and BehavioralFeature (as specification of the Behavior).,"specification <> null implies _'context'.ownedBehavior-
>select(specification=self.specification)->size() = 1",1.1,,
"If a Behavior has a specification BehavioralFeature, then it must have the same number of ownedParameters as
its specification. The Behavior Parameters must also ""match"" the BehavioralParameter Parameters, but the
exact requirements for this matching are not formalized.","specification <> null implies ownedParameter->size() = specification.ownedParameter-
>size()",1.1,,
"The specification BehavioralFeature must be a feature (possibly inherited) of the context BehavioredClassifier
of the Behavior.", _'context'.feature->includes(specification),1.1,,
A FunctionBehavior has at least one output Parameter.,"self.ownedParameter->
select(p | p.direction = ParameterDirectionKind::out or p.direction=
ParameterDirectionKind::inout or p.direction= ParameterDirectionKind::return)->size() >= 1",1.1,,
"The types of the ownedParameters are all DataTypes, which may not nest anything but other DataTypes.","ownedParameter->forAll(p | p.type <> null and
p.type.oclIsTypeOf(DataType) and hasAllDataTypeAttributes(p.type.oclAsType(DataType)))",1.1,,
The ValueSpecification when must return a non-negative Integer.,when.integerValue() >= 0,1.1,,
"If a Trigger specifies one or more ports, the event of the Trigger must be a MessageEvent.",port->notEmpty() implies event.oclIsKindOf(MessageEvent),1.1,,
The exit Pseudostates must be Pseudostates with kind exitPoint.,exit->forAll(kind = PseudostateKind::exitPoint),1.1,,
The entry Pseudostates must be Pseudostates with kind entryPoint.,entry->forAll(kind = PseudostateKind::entryPoint),1.1,,
A FinalState has no exit Behavior.,exit->isEmpty(),1.1,,
A FinalState cannot have any outgoing Transitions.,outgoing->size() = 0,1.1,,
A FinalState cannot have Regions.,region->size() = 0,1.1,,
A FinalState cannot reference a submachine.,submachine->isEmpty(),1.1,,
A FinalState has no entry Behavior.,entry->isEmpty(),1.1,,
A FinalState has no state (doActivity) Behavior.,doActivity->isEmpty(),1.1,,
"A ProtocolStateMachine must only have a Classifier context, not a BehavioralFeature context.",_'context' <> null and specification = null,1.1,,
ProtocolStateMachines cannot have deep or shallow history Pseudostates.,"region->forAll (r | r.subvertex->forAll (v | v.oclIsKindOf(Pseudostate) implies
((v.oclAsType(Pseudostate).kind <> PseudostateKind::deepHistory) and
(v.oclAsType(Pseudostate).kind <> PseudostateKind::shallowHistory))))",1.1,,
"The states of a ProtocolStateMachine cannot have entry, exit, or do activity Behaviors.","region->forAll(r | r.subvertex->forAll(v | v.oclIsKindOf(State) implies
(v.oclAsType(State).entry->isEmpty() and v.oclAsType(State).exit->isEmpty() and
v.oclAsType(State).doActivity->isEmpty())))",1.1,,
All Transitions of a ProtocolStateMachine must be ProtocolTransitions.,region->forAll(r | r.transition->forAll(t | t.oclIsTypeOf(ProtocolTransition))),1.1,,
"If a ProtocolTransition refers to an Operation (i.e., has a CallEvent trigger corresponding to an Operation), then
that Operation should apply to the context Classifier of the StateMachine of the ProtocolTransition.","if (referred()->notEmpty() and containingStateMachine()._'context'->notEmpty()) then
containingStateMachine()._'context'.oclAsType(BehavioredClassifier).allFeatures()-
>includesAll(referred())
else true endif",1.1,,
A ProtocolTransition never has associated Behaviors,effect = null,1.1,,
A ProtocolTransition always belongs to a ProtocolStateMachine.,container.belongsToPSM(),1.1,,
All transitions outgoing a fork vertex must target states in different regions of an orthogonal state.,"(kind = PseudostateKind::fork) implies
-- for any pair of outgoing transitions there exists an orthogonal state which contains the
targets of these transitions
-- such that these targets belong to different regions of that orthogonal state
outgoing->forAll(t1:Transition, t2:Transition | let contState:State =
containingStateMachine().LCAState(t1.target, t2.target) in
((contState <> null) and (contState.region
->exists(r1:Region, r2: Region | (r1 <> r2) and t1.target.isContainedInRegion(r1)
and t2.target.isContainedInRegion(r2)))))",1.1,,
"In a complete statemachine, a choice Vertex must have at least one incoming and one outgoing Transition.","(kind = PseudostateKind::choice) implies (incoming->size() >= 1 and outgoing->size() >=
1)",1.1,,
"The outgoing Transition from an initial vertex may have a behavior, but not a trigger or a guard.","(kind = PseudostateKind::initial) implies (outgoing.guard = null and outgoing.trigger-
>isEmpty())",1.1,,
"In a complete StateMachine, a join Vertex must have at least two incoming Transitions and exactly one
outgoing Transition.",(kind = PseudostateKind::join) implies (outgoing->size() = 1 and incoming->size() >= 2),1.1,,
"In a complete StateMachine, a junction Vertex must have at least one incoming and one outgoing Transition.","(kind = PseudostateKind::junction) implies (incoming->size() >= 1 and outgoing->size()
>= 1)",1.1,,
History Vertices can have at most one outgoing Transition.,"((kind = PseudostateKind::deepHistory) or (kind = PseudostateKind::shallowHistory))
implies (outgoing->size() <= 1)",1.1,,
An initial Vertex can have at most one outgoing Transition.,(kind = PseudostateKind::initial) implies (outgoing->size() <= 1),1.1,,
"In a complete StateMachine, a fork Vertex must have at least two outgoing Transitions and exactly one
incoming Transition.",(kind = PseudostateKind::fork) implies (incoming->size() = 1 and outgoing->size() >= 2),1.1,,
All Transitions incoming a join Vertex must originate in different Regions of an orthogonal State.,"(kind = PseudostateKind::join) implies
-- for any pair of incoming transitions there exists an orthogonal state which contains the
source vetices of these transitions
-- such that these source vertices belong to different regions of that orthogonal state
incoming->forAll(t1:Transition, t2:Transition | let contState:State =
containingStateMachine().LCAState(t1.source, t2.source) in
((contState <> null) and (contState.region
->exists(r1:Region, r2: Region | (r1 <> r2) and t1.source.isContainedInRegion(r1)
and t2.source.isContainedInRegion(r2)))))",1.1,,
A Region can have at most one deep history Vertex.,"self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
select(kind = PseudostateKind::deepHistory)->size() <= 1",1.1,,
A Region can have at most one shallow history Vertex.,"subvertex->select(oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
select(kind = PseudostateKind::shallowHistory)->size() <= 1",1.1,,
"If a Region is owned by a StateMachine, then it cannot also be owned by a State and vice versa.","(stateMachine <> null implies state = null) and (state <> null implies stateMachine =
null)",1.1,,
A Region can have at most one initial Vertex.,"self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
select(kind = PseudostateKind::initial)->size() <= 1",1.1,,
Only entry or exit Pseudostates can serve as connection points.,"connectionPoint->forAll(kind = PseudostateKind::entryPoint or kind =
PseudostateKind::exitPoint)",1.1,,
Only submachine States can have connection point references.,isSubmachineState implies connection->notEmpty( ) ,1.1,,
Only composite States can have entry or exit Pseudostates defined.,connectionPoint->notEmpty() implies isComposite,1.1,,
"The connection point references used as destinations/sources of Transitions associated with a submachine State
must be defined as entry/exit points in the submachine StateMachine.","self.isSubmachineState implies (self.connection->forAll (cp |
cp.entry->forAll (ps | ps.stateMachine = self.submachine) and
cp.exit->forAll (ps | ps.stateMachine = self.submachine)))",1.1,,
A State is not allowed to have both a submachine and Regions.,isComposite implies not isSubmachineState,1.1,,
The connection points of a StateMachine are Pseudostates of kind entry point or exit point.,"connectionPoint->forAll (kind = PseudostateKind::entryPoint or kind =
PseudostateKind::exitPoint)",1.1,,
The Classifier context of a StateMachine cannot be an Interface.,_'context' <> null implies not _'context'.oclIsKindOf(Interface),1.1,,
A StateMachine as the method for a BehavioralFeature cannot have entry/exit connection points.,specification <> null implies connectionPoint->isEmpty(),1.1,,
"The context Classifier of the method StateMachine of a BehavioralFeature must be the Classifier that owns the
BehavioralFeature.","specification <> null implies ( _'context' <> null and
specification.featuringClassifier->exists(c | c = _'context'))",1.1,,
A Transition with kind external can source any Vertex except entry points.,"(kind = TransitionKind::external) implies
not (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind =
PseudostateKind::entryPoint)",1.1,,
A join segment must not have Guards or Triggers.,"(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind =
PseudostateKind::join) implies (guard = null and trigger->isEmpty())",1.1,,
"A Transition with kind internal must have a State as its source, and its source and target must be equal.","(kind = TransitionKind::internal) implies
(source.oclIsKindOf (State) and source = target)",1.1,,
Transitions outgoing Pseudostates may not have a Trigger.,"source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind <>
PseudostateKind::initial) implies trigger->isEmpty()",1.1,,
A join segment must always originate from a State.,"(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind =
PseudostateKind::join) implies (source.oclIsKindOf(State))",1.1,,
A fork segment must always target a State.,"(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind =
PseudostateKind::fork) implies (target.oclIsKindOf(State))",1.1,,
A Transition with kind local must have a composite State or an entry point as its source.,"(kind = TransitionKind::local) implies
((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or
(source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind =
PseudostateKind::entryPoint))",1.1,,
An initial Transition at the topmost level Region of a StateMachine that has no Trigger.,(source.oclIsKindOf(Pseudostate) and container.stateMachine->notEmpty()) implies trigger->isEmpty(),1.1,,
A fork segment must not have Guards or Triggers.,"(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind =
PseudostateKind::fork) implies (guard = null and trigger->isEmpty())",1.1,,
The source and target Vertices of a Transition must be contained in the same StateMachine as the Transition,"let stateMachine = self.containingStateMachine() in
source.containingStateMachine() = stateMachine and
target.containingStateMachine() = stateMachine",1.1,,
A Parameter with direction other than inout must have exactly one ActivityParameterNode in an Activity.,"ownedParameter->forAll(p |
p.direction <> ParameterDirectionKind::inout implies node->select(
oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter =
p)->size()= 1)",1.1,,
"A Parameter with direction inout must have exactly two ActivityParameterNodes in an Activity, at most one
with incoming ActivityEdges and at most one with outgoing ActivityEdges.","ownedParameter->forAll(p | p.direction = ParameterDirectionKind::inout implies
let associatedNodes : Set(ActivityNode) = node->select(
oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter =
p) in
associatedNodes->size()=2 and
associatedNodes->select(incoming->notEmpty())->size()<=1 and
associatedNodes->select(outgoing->notEmpty())->size()<=1
)",1.1,,
"If an ActivityEdge is directly owned by an Activity, then its source and target must be directly or indirectly
contained in the same Activity.","activity<>null implies source.containingActivity() = activity and
target.containingActivity() = activity",1.1,,
All containedNodes and containedEdges of an ActivityGroup must be in the same Activity as the group.,"containedNode->forAll(activity = self.containingActivity()) and
containedEdge->forAll(activity = self.containingActivity())",1.1,,
"No containedNode or containedEdge of an ActivityGroup may be contained by its subgroups or its
superGroups, transitively.","subgroup->closure(subgroup).containedNode->excludesAll(containedNode) and
superGroup->closure(superGroup).containedNode->excludesAll(containedNode) and
subgroup->closure(subgroup).containedEdge->excludesAll(containedEdge) and
superGroup->closure(superGroup).containedEdge->excludesAll(containedEdge)",1.1,,
"An ActivityParameterNode with no outgoing ActivityEdges and one or more incoming ActivityEdges must
have a parameter with direction out, inout, or return.","(incoming->notEmpty() and outgoing->isEmpty()) implies
(parameter.direction = ParameterDirectionKind::out or
parameter.direction = ParameterDirectionKind::inout or
parameter.direction = ParameterDirectionKind::return)",1.1,,
The parameter of an ActivityParameterNode must be from the containing Activity.,activity.ownedParameter->includes(parameter),1.1,,
The type of an ActivityParameterNode is the same as the type of its parameter.,type = parameter.type,1.1,,
"An ActivityParameterNode with no incoming ActivityEdges and one or more outgoing ActivityEdges must
have a parameter with direction in or inout.","(outgoing->notEmpty() and incoming->isEmpty()) implies
(parameter.direction = ParameterDirectionKind::_'in' or
parameter.direction = ParameterDirectionKind::inout)",1.1,,
"An ActivityParameterNode may have all incoming ActivityEdges or all outgoing ActivityEdges, but it must not
have both incoming and outgoing ActivityEdges",incoming->isEmpty() or outgoing->isEmpty(),1.1,,
"If a non-external ActivityPartition represents a Classifier and has a superPartition, then the superPartition must
represent a Classifier, and the Classifier of the subpartition must be nested (nestedClassifier or
ownedBehavior) in the Classifier represented by the superPartition, or be at the contained end of a composition
Association with the Classifier represented by the superPartition.","(not isExternal and represents.oclIsKindOf(Classifier) and superPartition->notEmpty())
implies
(
let representedClassifier : Classifier = represents.oclAsType(Classifier) in superPartition.represents.oclIsKindOf(Classifier) and
let representedSuperClassifier : Classifier =
superPartition.represents.oclAsType(Classifier) in
(representedSuperClassifier.oclIsKindOf(BehavioredClassifier) and
representedClassifier.oclIsKindOf(Behavior) and
representedSuperClassifier.oclAsType(BehavioredClassifier).ownedBehavior-
>includes(representedClassifier.oclAsType(Behavior)))
or
(representedSuperClassifier.oclIsKindOf(Class) and
representedSuperClassifier.oclAsType(Class).nestedClassifier-
>includes(representedClassifier))
or
(Association.allInstances()->exists(a | a.memberEnd->exists(end1 | end1.isComposite
and end1.type = representedClassifier and
a.memberEnd-
>exists(end2 | end1<>end2 and end2.type = representedSuperClassifier))))
)",1.1,,
"If an ActivityPartition represents a Property and has a superPartition, then the Property must be of a Classifier
represented by the superPartition, or of a Classifier that is the type of a Property represented by the
superPartition.","(represents.oclIsKindOf(Property) and superPartition->notEmpty()) implies
(
(superPartition.represents.oclIsKindOf(Classifier) and represents.owner =
superPartition.represents) or
(superPartition.represents.oclIsKindOf(Property) and represents.owner =
superPartition.represents.oclAsType(Property).type)
)",1.1,,
"If an ActivityPartition represents a Property and has a superPartition representing a Classifier, then all the other
non-external subpartitions of the superPartition must represent Properties directly owned by the same
Classifier.","(represents.oclIsKindOf(Property) and superPartition->notEmpty() and
superPartition.represents.oclIsKindOf(Classifier)) implies
(
let representedClassifier : Classifier = superPartition.represents.oclAsType(Classifier)
in
superPartition.subpartition->reject(isExternal)->forAll(p |
p.represents.oclIsKindOf(Property) and p.owner=representedClassifier)
)",1.1,,
An ActvivityPartition with isDimension = true may not be contained by another ActivityPartition.,isDimension implies superPartition->isEmpty(),1.1,,
"ControlFlows may not have ObjectNodes at either end, except for ObjectNodes with control type.","(source.oclIsKindOf(ObjectNode) implies source.oclAsType(ObjectNode).isControlType) and
(target.oclIsKindOf(ObjectNode) implies target.oclAsType(ObjectNode).isControlType)",1.1,,
"If the DecisionNode has no decisionInputFlow and an incoming ControlFlow, then any decisionInput Behavior
has no in parameters.","(decisionInput<>null and decisionInputFlow=null and incoming-
>exists(oclIsKindOf(ControlFlow))) implies
decisionInput.inputParameters()->isEmpty()",1.1,,
"The ActivityEdges incoming to and outgoing from a DecisionNode, other than the decisionInputFlow (if any),
must be either all ObjectFlows or all ControlFlows.","let allEdges: Set(ActivityEdge) = incoming->union(outgoing) in
let allRelevantEdges: Set(ActivityEdge) = if decisionInputFlow->notEmpty() then allEdges-
>excluding(decisionInputFlow) else allEdges endif in
allRelevantEdges->forAll(oclIsKindOf(ControlFlow)) or allRelevantEdges-
>forAll(oclIsKindOf(ObjectFlow))",1.1,,
The decisionInputFlow of a DecisionNode must be an incoming ActivityEdge of the DecisionNode.,incoming->includes(decisionInputFlow),1.1,,
"If the DecisionNode has a decisionInputFlow and a second incoming ObjectFlow, then any decisionInput has
two in Parameters, the first of which has a type that is the same as or a supertype of the type of object tokens
offered on the non-decisionInputFlow and the second of which has a type that is the same as or a supertype of
the type of object tokens offered on the decisionInputFlow.","(decisionInput<>null and decisionInputFlow<>null and incoming-
>forAll(oclIsKindOf(ObjectFlow))) implies
decisionInput.inputParameters()->size()=2",1.1,,
A DecisionNode has one or two incoming ActivityEdges and at least one outgoing ActivityEdge.,(incoming->size() = 1 or incoming->size() = 2) and outgoing->size() > 0,1.1,,
"If the DecisionNode has a decisionInputFlow and an incoming ControlFlow, then any decisionInput Behavior
has one in Parameter whose type is the same as or a supertype of the type of object tokens offered on the
decisionInputFlow.","(decisionInput<>null and decisionInputFlow<>null and incoming-
>exists(oclIsKindOf(ControlFlow))) implies
decisionInput.inputParameters()->size()=1",1.1,,
"A decisionInput Behavior has no out parameters, no inout parameters, and one return parameter.","decisionInput<>null implies
(decisionInput.ownedParameter->forAll(par |
par.direction <> ParameterDirectionKind::out and
par.direction <> ParameterDirectionKind::inout ) and
decisionInput.ownedParameter->one(par |
par.direction <> ParameterDirectionKind::return))",1.1,,
"If the DecisionNode has no decisionInputFlow and an incoming ObjectFlow, then any decisionInput Behavior
has one in Parameter whose type is the same as or a supertype of the type of object tokens offered on the
incoming ObjectFlow.","(decisionInput<>null and decisionInputFlow=null and incoming-
>forAll(oclIsKindOf(ObjectFlow))) implies
decisionInput.inputParameters()->size()=1",1.1,,
"The handlerBody has no incoming or outgoing ActivityEdges and the exceptionInput has no incoming
ActivityEdges.","handlerBody.incoming->isEmpty() and handlerBody.outgoing->isEmpty() and
exceptionInput.incoming->isEmpty()",1.1,,
"If the protectedNode is an Action with OutputPins, then the handlerBody must also be an Action with the same
number of OutputPins, which are compatible in type, ordering, and multiplicity to those of the protectedNode.","(protectedNode.oclIsKindOf(Action) and protectedNode.oclAsType(Action).output-
>notEmpty()) implies
(
handlerBody.oclIsKindOf(Action) and
let protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output,
handlerBodyOutput : OrderedSet(OutputPin) = handlerBody.oclAsType(Action).output in
protectedNodeOutput->size() = handlerBodyOutput->size() and
Sequence{1..protectedNodeOutput->size()}->forAll(i |
handlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and
handlerBodyOutput->at(i).isOrdered=protectedNodeOutput->at(i).isOrdered and
handlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i)))
)",1.1,,
"The handlerBody is an Action with one InputPin, and that InputPin is the same as the exceptionInput.","handlerBody.oclIsKindOf(Action) and
let inputs: OrderedSet(InputPin) = handlerBody.oclAsType(Action).input in
inputs->size()=1 and inputs->first()=exceptionInput",1.1,,
"An ActivityEdge that has a source within the handlerBody of an ExceptionHandler must have its target in the
handlerBody also, and vice versa.","let nodes:Set(ActivityNode) = handlerBody.oclAsType(Action).allOwnedNodes() in
nodes.outgoing->forAll(nodes->includes(target)) and
nodes.incoming->forAll(nodes->includes(source))",1.1,,
The handlerBody must have the same owner as the protectedNode.,handlerBody.owner=protectedNode.owner,1.1,,
The exceptionInput must either have no type or every exceptionType must conform to the exceptionInput type.,"exceptionInput.type=null or
exceptionType->forAll(conformsTo(exceptionInput.type.oclAsType(Classifier)))",1.1,,
A FinalNode has no outgoing ActivityEdges.,outgoing->isEmpty(),1.1,,
"The ActivityEdges incoming to and outgoing from a ForkNode must be either all ObjectFlows or all
ControlFlows.","let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in
allEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))",1.1,,
A ForkNode has one incoming ActivityEdge.,incoming->size()=1,1.1,,
An InitialNode has no incoming ActivityEdges.,incoming->isEmpty(),1.1,,
All the outgoing ActivityEdges from an InitialNode must be ControlFlows,outgoing->forAll(oclIsKindOf(ControlFlow)),1.1,,
"The interruptingEdges of an InterruptibleActivityRegion must have their source in the region and their target
outside the region, but within the same Activity containing the region.","interruptingEdge->forAll(edge |
node->includes(edge.source) and node->excludes(edge.target) and
edge.target.containingActivity() = inActivity)",1.1,,
A JoinNode has one outgoing ActivityEdge.,outgoing->size() = 1,1.1,,
"If one of the incoming ActivityEdges of a JoinNode is an ObjectFlow, then its outgoing ActivityEdge must be
an ObjectFlow. Otherwise its outgoing ActivityEdge must be a ControlFlow.","if incoming->exists(oclIsKindOf(ObjectFlow)) then outgoing-
>forAll(oclIsKindOf(ObjectFlow))
else outgoing->forAll(oclIsKindOf(ControlFlow))
endif",1.1,,
A MergeNode has one outgoing ActivityEdge.,outgoing->size()=1,1.1,,
"A selection Behavior has one input Parameter and one output Parameter. The input Parameter must have the
same as or a supertype of the type of the source ObjectNode, be non-unique and have multiplicity 0..*. The
output Parameter must be the same or a subtype of the type of source ObjectNode. The Behavior cannot have
side effects.","selection<>null implies
selection.inputParameters()->size()=1 and
selection.inputParameters()->forAll(not isUnique and is(0,*)) and
selection.outputParameters()->size()=1",1.1,,
ObjectFlows may not have ExecutableNodes at either end.,not (source.oclIsKindOf(ExecutableNode) or target.oclIsKindOf(ExecutableNode)),1.1,,
"A transformation Behavior has one input Parameter and one output Parameter. The input Parameter must be the
same as or a supertype of the type of object token coming from the source end. The output Parameter must be
the same or a subtype of the type of object token expected downstream. The Behavior cannot have side effects.","transformation<>null implies
transformation.inputParameters()->size()=1 and
transformation.outputParameters()->size()=1",1.1,,
An ObjectFlow may have a selection Behavior only if it has an ObjectNode as its source.,selection<>null implies source.oclIsKindOf(ObjectNode),1.1,,
isMulticast and isMultireceive cannot both be true.,not (isMulticast and isMultireceive),1.1,,
"A selection Behavior has one input Parameter and one output Parameter. The input Parameter must have the
same type as or a supertype of the type of ObjectNode, be non-unique, and have multiplicity 0..*. The output
Parameter must be the same or a subtype of the type of ObjectNode. The Behavior cannot have side effects.","selection<>null implies
selection.inputParameters()->size()=1 and
selection.inputParameters()->forAll(p | not p.isUnique and p.is(0,*) and
self.type.conformsTo(p.type)) and
selection.outputParameters()->size()=1 and
selection.inputParameters()->forAll(p | self.type.conformsTo(p.type))",1.1,,
"If an ObjectNode has a selection Behavior, then the ordering of the object node is ordered, and vice versa.",(selection<>null) = (ordering=ObjectNodeOrderingKind::ordered),1.1,,
"If isControlType=false, the ActivityEdges incoming to or outgoing from an ObjectNode must all be
ObjectFlows.",(not isControlType) implies incoming->union(outgoing)->forAll(oclIsKindOf(ObjectFlow)),1.1,,
"The number of result OutputPins must be the same as the number of input (in and inout) ownedParameters of
the Operation specified by the trigger Event. The type, ordering and multiplicity of each result OutputPin must
be consistent with the corresponding input Parameter.","let parameter: OrderedSet(Parameter) = trigger.event->asSequence()-
>first().oclAsType(CallEvent).operation.inputParameters() in
result->size() = parameter->size() and
Sequence{1..result->size()}->forAll(i |
parameter->at(i).type.conformsTo(result->at(i).type) and
parameter->at(i).isOrdered = result->at(i).isOrdered and
parameter->at(i).compatibleWith(result->at(i)))",1.1,->first()?,
"The action must have exactly one trigger, which must be for a CallEvent.","trigger->size()=1 and
trigger->asSequence()->first().event.oclIsKindOf(CallEvent)",1.1,,
isUnmarshall must be true for an AcceptCallAction.,isUnmarshall = true,1.1,,
"If isUnmarshall=false and any of the triggers are for SignalEvents or TimeEvents, there must be exactly one
result OutputPin with multiplicity 1..1.","not isUnmarshall and trigger->exists(event.oclIsKindOf(SignalEvent) or
event.oclIsKindOf(TimeEvent)) implies
output->size() = 1 and output->first().is(1,1)",1.1,,
AcceptEventActions may have no input pins.,input->size() = 0,1.1,,
"There are no OutputPins if the trigger events are only ChangeEvents and/or CallEvents when this action is an
instance of AcceptEventAction and not an instance of a descendant of AcceptEventAction (such as
AcceptCallAction).","(self.oclIsTypeOf(AcceptEventAction) and
(trigger->forAll(event.oclIsKindOf(ChangeEvent) or event.oclIsKindOf(CallEvent))))
implies output->size() = 0",1.1,,
"If isUnmarshall is true (and this is not an AcceptCallAction), there must be exactly one trigger, which is for a
SignalEvent. The number of result output pins must be the same as the number of attributes of the signal. The
type and ordering of each result output pin must be the same as the corresponding attribute of the signal. The
multiplicity of each result output pin must be compatible with the multiplicity of the corresponding attribute.","isUnmarshall and self.oclIsTypeOf(AcceptEventAction) implies
trigger->size()=1 and
trigger->asSequence()->first().event.oclIsKindOf(SignalEvent) and
let attribute: OrderedSet(Property) = trigger->asSequence()-
>first().event.oclAsType(SignalEvent).signal.allAttributes() in
attribute->size()>0 and result->size() = attribute->size() and
Sequence{1..result->size()}->forAll(i |
result->at(i).type = attribute->at(i).type and
result->at(i).isOrdered = attribute->at(i).isOrdered and
result->at(i).includesMultiplicity(attribute->at(i)))",1.1,,
"If isUnmarshall=false and all the triggers are for SignalEvents, then the type of the single result OutputPin
must either be null or all the signals must conform to it.","not isUnmarshall implies
result->isEmpty() or
let type: Type = result->first().type in
type=null or
(trigger->forAll(event.oclIsKindOf(SignalEvent)) and
trigger.event.oclAsType(SignalEvent).signal->forAll(s | s.conformsTo(type)))",1.1,,
The fromAction of an ActionInputPin must only have ActionInputPins as InputPins.,fromAction.input->forAll(oclIsKindOf(ActionInputPin)),1.1,,
The fromAction of an ActionInputPin must have exactly one OutputPin.,fromAction.output->size() = 1,1.1,,
The fromAction of an ActionInputPin cannot have ActivityEdges coming into or out of it or its Pins.,"fromAction.incoming->union(outgoing)->isEmpty() and
fromAction.input.incoming->isEmpty() and
fromAction.output.outgoing->isEmpty()",1.1,,
A value InputPin is required.,value<>null,1.1,,
"AddStructuralFeatureActions adding a value to ordered StructuralFeatures must have a single InputPin for the
insertion point with type UnlimitedNatural and multiplicity of 1..1 if isReplaceAll=false, and must have no
Input Pin for the insertion point when the StructuralFeature is unordered.","if not structuralFeature.isOrdered then insertAt = null
else
not isReplaceAll implies
insertAt<>null and
insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))
endif",1.1,,
"AddVariableValueActions for ordered Variables must have a single InputPin for the insertion point with type
UnlimtedNatural and multiplicity of 1..1 if isReplaceAll=false, otherwise the Action has no InputPin for the
insertion point.","if not variable.isOrdered then insertAt = null
else
not isReplaceAll implies
insertAt<>null and
insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))
endif",1.1,,
The number of argument InputPins must be the same as the number of attributes in the signal.,argument->size() = signal.allAttributes()->size(),1.1,,
"The type, ordering, and multiplicity of an argument InputPin must be the same as the corresponding attribute
of the signal.","let attribute: OrderedSet(Property) = signal.allAttributes() in
Sequence{1..argument->size()}->forAll(i |
argument->at(i).type.conformsTo(attribute->at(i).type) and
argument->at(i).isOrdered = attribute->at(i).isOrdered and argument->at(i).compatibleWith(attribute->at(i)))",1.1,,
A BroadcaseSignalAction may not specify onPort.,onPort=null,1.1,,
"The number of argument InputPins must be the same as the number of input (in and inout) ownedParameters of
the called Behavior or Operation. The type, ordering and multiplicity of each argument InputPin must be
consistent with the corresponding input Parameter.","let parameter: OrderedSet(Parameter) = self.inputParameters() in argument->size() = parameter->size() and
Sequence{1..argument->size()}->forAll(i |
argument->at(i).type.conformsTo(parameter->at(i).type) and
argument->at(i).isOrdered = parameter->at(i).isOrdered and
argument->at(i).compatibleWith(parameter->at(i)))",1.1,,
"The number of result OutputPins must be the same as the number of output (inout, out and return)
ownedParameters of the called Behavior or Operation. The type, ordering and multiplicity of each result
OutputPin must be consistent with the corresponding input Parameter.","let parameter: OrderedSet(Parameter) = self.outputParameters() in
result->size() = parameter->size() and
Sequence{1..result->size()}->forAll(i |
parameter->at(i).type.conformsTo(result->at(i).type) and
parameter->at(i).isOrdered = result->at(i).isOrdered and
parameter->at(i).compatibleWith(result->at(i)))",1.1,,
Only synchronous CallActions can have result OutputPins.,result->notEmpty() implies isSynchronous,1.1,,
"If onPort has no value, the operation must be an owned or inherited feature of the type of the target InputPin,
otherwise the Port given by onPort must be an owned or inherited feature of the type of the target InputPin, and
the Port must have a required or provided Interface with the operation as an owned or inherited feature.","if onPort=null then target.type.oclAsType(Classifier).allFeatures()-
>includes(operation) else target.type.oclAsType(Classifier).allFeatures()->includes(onPort) and onPort.provided-
>union(onPort.required).allFeatures()->includes(operation)
endif",1.1,,
The bodyOutput Pins are OutputPins on Actions in the body of the Clause., _'body'.oclAsType(Action).allActions().output->includesAll(bodyOutput),1.1,,
"The decider Pin must be on an Action in the test section of the Clause and must be of type Boolean with
multiplicity 1..1.","test.oclAsType(Action).allActions().output->includes(decider) and
decider.type = Boolean and
decider.is(1,1) ",1.1,,
The test and body parts of a ConditionalNode must be disjoint with each other.,test->intersection(_'body')->isEmpty(),1.1,,
The multiplicity of the object InputPin is 1..1.,"object.is(1,1)",1.1,,
The type of the InputPin must conform to the type of at least one of the memberEnds of the association.,association.memberEnd->exists(self.object.type.conformsTo(type)),1.1,,
The type of the result OutputPin is the same as the type of the inherited object InputPin.,result<>null implies result.type = object.type,1.1,,
The multiplicity of the result OutputPin must be 1..1.,"result<>null implies result.is(1,1)",1.1,,
The result OutputPins have no incoming edges.,result.incoming->isEmpty(),1.1,,
A ConditionalNode has no InputPins.,input->isEmpty(),1.1,,
"No ExecutableNode in the ConditionNode may appear in the test or body part of more than one clause of a
ConditionalNode.","node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->forAll(n |
self.clause->select(test->union(_'body')->includes(n))->size()=1)",1.1,,
"Each clause of a ConditionalNode must have the same number of bodyOutput pins as the ConditionalNode has
result OutputPins, and each clause bodyOutput Pin must be compatible with the corresponding result
OutputPin (by positional order) in type, multiplicity, ordering, and uniqueness.","clause->forAll(
bodyOutput->size()=self.result->size() and
Sequence{1..self.result->size()}->forAll(i |
bodyOutput->at(i).type.conformsTo(result->at(i).type) and
bodyOutput->at(i).isOrdered = result->at(i).isOrdered and
bodyOutput->at(i).isUnique = result->at(i).isUnique and
bodyOutput->at(i).compatibleWith(result->at(i))))",1.1,,
"The union of the ExecutableNodes in the test and body parts of all clauses must be the same as the subset of
nodes contained in the ConditionalNode (considered as a StructuredActivityNode) that are ExecutableNodes.","clause.test->union(clause._'body') = node-
>select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)",1.1,,
"No two clauses within a ConditionalNode may be predecessorClauses of each other, either directly or
indirectly.",clause->closure(predecessorClause)->intersection(clause)->isEmpty(),1.1,,
The Association cannot be an abstract Classifier.,not self.association().isAbstract,1.1,,
The multiplicity of the OutputPin is 1..1.,"result.is(1,1)",1.1,,
The type of the result OutputPin must be the same as the Association of the CreateLinkObjectAction.,result.type = association(),1.1,,
The Association must be an AssociationClass.,self.association().oclIsKindOf(AssociationClass),1.1,,
The classifier cannot be abstract.,not classifier.isAbstract,1.1,,
The classifier cannot be an AssociationClass.,not classifier.oclIsKindOf(AssociationClass),1.1,,
The type of the result OutputPin must be the same as the classifier of the CreateObjectAction.,result.type = classifier,1.1,,
The multiplicity of the target IinputPin is 1..1.,"target.is(1,1)",1.1,,
The target InputPin has no type.,target.type= null,1.1,,
"One of regionAsInput or regionAsOutput must be non-empty, but not both.",regionAsInput->notEmpty() xor regionAsOutput->notEmpty(),1.1,,
"An InputPin may have outgoing ActivityEdges only when it is owned by a StructuredActivityNode, and these
edges must target a node contained (directly or indirectly) in the owning StructuredActivityNode.","outgoing->notEmpty() implies
action<>null and
action.oclIsKindOf(StructuredActivityNode) and
action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(outgoing.target)",1.1,,
The inputValue InputPins is the same as the union of all the InputPins referenced by the endData.,inputValue->asBag()=endData.allPins(),1.1,,
"The ends of the endData must all be from the same Association and include all and only the memberEnds of
that association.",endData.end = self.association().memberEnd->asBag(),1.1,,
The ends of the endData must not be static.,endData->forAll(not end.isStatic),1.1,,
"LinkEndCreationData for ordered Association ends must have a single insertAt InputPin for the insertion point
with type UnlimitedNatural and multiplicity of 1..1, if isReplaceAll=false, and must have no InputPin for the
insertion point when the association ends are unordered.","if not end.isOrdered
then insertAt = null
else
not isReplaceAll=false implies
insertAt <> null and insertAt->forAll(type=UnlimitedNatural and is(1,1))
endif",1.1,,
The type of the value InputPin conforms to the type of the Association end.,value<>null implies value.type.conformsTo(end.type),1.1,,
The multiplicity of the value InputPin must be 1..1.,"value<>null implies value.is(1,1)",1.1,,
The value InputPin is not also the qualifier value InputPin.,value->excludesAll(qualifier.value),1.1,,
The Property must be an Association memberEnd.,end.association <> null,1.1,,
The qualifiers must be qualifiers of the Association end.,end.qualifier->includesAll(qualifier.qualifier),1.1,,
"LinkEndDestructionData for ordered, nonunique Association ends must have a single destroyAt InputPin if
isDestroyDuplicates is false, which must be of type UnlimitedNatural and have a multiplicity of 1..1.
Otherwise, the action has no destroyAt input pin.","if not end.isOrdered or end.isUnique or isDestroyDuplicates
then destroyAt = null
else
destroyAt <> null and
destroyAt->forAll(type=UnlimitedNatural and is(1,1))
endif",1.1,,
The loopVariableInputs must not have outgoing edges.,loopVariableInput.outgoing->isEmpty(),1.1,,
"The union of the ExecutableNodes in the setupPart, test and bodyPart of a LoopNode must be the same as the
subset of nodes contained in the LoopNode (considered as a StructuredActivityNode) that are
ExecutableNodes.","setupPart->union(test)->union(bodyPart)=node-
>select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->asSet()",1.1,,
The bodyOutput pins are OutputPins on Actions in the body of the LoopNode.,bodyPart.oclAsType(Action).allActions().output->includesAll(bodyOutput),1.1,,
The test and body parts of a ConditionalNode must be disjoint with each other.,"setupPart->intersection(test)->isEmpty() and
setupPart->intersection(bodyPart)->isEmpty() and
test->intersection(bodyPart)->isEmpty()",1.1,,
"A LoopNode must have the same number of bodyOutput Pins as loopVariables, and each bodyOutput Pin must
be compatible with the corresponding loopVariable (by positional order) in type, multiplicity, ordering and
uniqueness.","bodyOutput->size()=loopVariable->size() and
Sequence{1..loopVariable->size()}->forAll(i |
bodyOutput->at(i).type.conformsTo(loopVariable->at(i).type) and
bodyOutput->at(i).isOrdered = loopVariable->at(i).isOrdered and
bodyOutput->at(i).isUnique = loopVariable->at(i).isUnique and
loopVariable->at(i).includesMultiplicity(bodyOutput->at(i)))",1.1,,
"A LoopNode must have the same number of loopVariableInputs and loopVariables, and they must match in
type, uniqueness and multiplicity.","loopVariableInput->size()=loopVariable->size() and
loopVariableInput.type=loopVariable.type and
loopVariableInput.isUnique=loopVariable.isUnique and
loopVariableInput.lower=loopVariable.lower and
loopVariableInput.upper=loopVariable.upper",1.1,,
"A LoopNode must have the same number of result OutputPins and loopVariables, and they must match in type,
uniqueness and multiplicity.","result->size()=loopVariable->size() and
result.type=loopVariable.type and
result.isUnique=loopVariable.isUnique and
result.lower=loopVariable.lower and
result.upper=loopVariable.upper",1.1,,
All ActivityEdges outgoing from loopVariable OutputPins must have targets within the LoopNode.,allOwnedNodes()->includesAll(loopVariable.outgoing.target),1.1,,
"An OutputPin may have incoming ActivityEdges only when it is owned by a StructuredActivityNode, and
these edges must have sources contained (directly or indirectly) in the owning StructuredActivityNode.","incoming->notEmpty() implies
action<>null and
action.oclIsKindOf(StructuredActivityNode) and
action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(incoming.source)",1.1,,
A control Pin has a control type.,isControl implies isControlType,1.1,,
Pin multiplicity is not unique.,not isUnique,1.1,,
The multiplicity of the value InputPin is 1..1.,"value.is(1,1)",1.1,,
The type of the value InputPin conforms to the type of the qualifier Property.,value.type.conformsTo(qualifier.type),1.1,,
The qualifier must be a qualifier of the Association end of the linkEndData that owns this QualifierValue.,linkEndData.end.qualifier->includes(qualifier),1.1,,
The multiplicity of the result OutputPin is 0..*.,"result.is(0,*)",1.1,,
The object InputPin has no type.,object.type = null,1.1,,
The type of the result OutputPin is Boolean.,result.type = Boolean,1.1,,
The type and ordering of the result OutputPin are same as the type and ordering of the open Association end.,self.openEnd()->forAll(type=result.type and isOrdered=result.isOrdered),1.1,,
The multiplicity of the open Association end must be compatible with the multiplicity of the result OutputPin.,self.openEnd()->first().compatibleWith(result),1.1,,
Visibility of the open end must allow access from the object performing the action.,"let openEnd : Property = self.openEnd()->first() in
openEnd.visibility = VisibilityKind::public or
endData->exists(oed |
oed.end<>openEnd and
(_'context' = oed.end.type or
(openEnd.visibility = VisibilityKind::protected and
_'context'.conformsTo(oed.end.type.oclAsType(Classifier)))))",1.1,,
"Exactly one linkEndData specification (corresponding to the ""open"" end) must not have a value InputPin.",self.openEnd()->size() = 1,1.1,,
The open end must be navigable.,self.openEnd()->first().isNavigable(),1.1,,
The ends of the association must not be static.,end.association.memberEnd->forAll(e | not e.isStatic),1.1,,
The type of the result OutputPin is the same as the type of the end Property.,result.type = end.type,1.1,,
The type of the object InputPin is the AssociationClass that owns the end Property.,object.type = end.association,1.1,,
The association of the end must be an AssociationClass.,end.association.oclIsKindOf(AssociationClass),1.1,,
"The type of the object InputPin is the AssociationClass that owns the Association end that has the given
qualifier Property.",object.type = qualifier.associationEnd.association,1.1,,
The multiplicity of the qualifier Property is 1..1.,"qualifier.is(1,1)",1.1,,
The ends of the Association must not be static.,qualifier.associationEnd.association.memberEnd->forAll(e | not e.isStatic),1.1,,
The type of the result OutputPin is the same as the type of the qualifier Property.,result.type = qualifier.type,1.1,,
The association of the Association end of the qualifier Property must be an AssociationClass.,qualifier.associationEnd.association.oclIsKindOf(AssociationClass),1.1,,
The qualifier Property must be a qualifier of an Association end.,qualifier.associationEnd <> null,1.1,,
A ReadSelfAction must have a context Classifier.,_'context' <> null,1.1,,
"If the ReadSelfAction is contained in a Behavior that is acting as a method, then the Operation of the method
must not be static.","let behavior: Behavior = self.containingBehavior() in
behavior.specification<>null implies not behavior.specification.isStatic",1.1,,
The type of the result OutputPin is the context Classifier.,result.type = _'context',1.1,,
The multiplicity of the StructuralFeature must be compatible with the multiplicity of the result OutputPin.,structuralFeature.compatibleWith(result),1.1,,
The type and ordering of the result OutputPin are the same as the type and ordering of the StructuralFeature.,"result.type =structuralFeature.type and
result.isOrdered = structuralFeature.isOrdered",1.1,,
The type and ordering of the result OutputPin are the same as the type and ordering of the variable.,"result.type =variable.type and
result.isOrdered = variable.isOrdered",1.1,,
The multiplicity of the variable must be compatible with the multiplicity of the output pin.,variable.compatibleWith(result),1.1,,
None of the newClassifiers may be abstract.,not newClassifier->exists(isAbstract),1.1,,
The type of the output of the reducer Behavior must conform to the type of the result OutputPin.,reducer.outputParameters().type->forAll(conformsTo(result.type)),1.1,,
"RemoveStructuralFeatureValueActions removing a value from ordered, non-unique StructuralFeatures must
have a single removeAt InputPin and no value InputPin, if isRemoveDuplicates is false. The removeAt
InputPin must be of type Unlimited Natural with multiplicity 1..1. Otherwise, the Action has a value InputPin
and no removeAt InputPin.","if structuralFeature.isOrdered and not structuralFeature.isUnique and not
isRemoveDuplicates then
value = null and
removeAt <> null and
removeAt.type = UnlimitedNatural and
removeAt.is(1,1)
else
removeAt = null and value <> null
endif",1.1,,
"ReadVariableActions removing a value from ordered, non-unique Variables must have a single removeAt
InputPin and no value InputPin, if isRemoveDuplicates is false. The removeAt InputPin must be of type
Unlimited Natural with multiplicity 1..1. Otherwise, the Action has a value InputPin and no removeAt
InputPin.","if variable.isOrdered and not variable.isUnique and not isRemoveDuplicates then
value = null and
removeAt <> null and
removeAt.type = UnlimitedNatural and
removeAt.is(1,1)
else
removeAt = null and value <> null
endif",1.1,,
"The replyValue InputPins must match the output (return, out, and inout) parameters of the operation of the
event of the replyToCall Trigger in number, type, ordering, and multiplicity.","let parameter:OrderedSet(Parameter) =
replyToCall.event.oclAsType(CallEvent).operation.outputParameters() in
replyValue->size()=parameter->size() and
Sequence{1..replyValue->size()}->forAll(i |
replyValue->at(i).type.conformsTo(parameter->at(i).type) and
replyValue->at(i).isOrdered=parameter->at(i).isOrdered and
replyValue->at(i).compatibleWith(parameter->at(i)))",1.1,,
The event of the replyToCall Trigger must be a CallEvent.,replyToCall.event.oclIsKindOf(CallEvent),1.1,,
"If onPort is not empty, the Port given by onPort must be an owned or inherited feature of the type of the target
InputPin.",onPort<>null implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort),1.1,,
"The type, ordering, and multiplicity of an argument InputPin must be the same as the corresponding attribute
of the signal.","let attribute: OrderedSet(Property) = signal.allAttributes() in
Sequence{1..argument->size()}->forAll(i |
argument->at(i).type.conformsTo(attribute->at(i).type) and
argument->at(i).isOrdered = attribute->at(i).isOrdered and
argument->at(i).compatibleWith(attribute->at(i)))",1.1,,
"The number and order of argument InputPins must be the same as the number and order of attributes of the
signal.",argument->size()=signal.allAttributes()->size(),1.1,,
"If onPort is not empty, the Port given by onPort must be an owned or inherited feature of the type of the target
InputPin.","not onPort->isEmpty() implies target.type.oclAsType(Classifier).allFeatures()-
>includes(onPort)",1.1,,
"If the InputPin has a type, then the type or one of its ancestors must have a classifierBehavior.","object.type->notEmpty() implies
(object.type.oclIsKindOf(BehavioredClassifier) and
object.type.oclAsType(BehavioredClassifier).classifierBehavior<>null)",1.1,,
The type of the object InputPin must be either a Behavior or a BehavioredClassifier with a classifierBehavior.,self.behavior()<>null,1.1,,
A StartObjectBehaviorAction may not specify onPort.,onPort->isEmpty(),1.1,,
"The structuralFeature must either be an owned or inherited feature of the type of the object InputPin, or it must
be an owned end of a binary Association whose opposite end had as a type to which the type of the object
InputPin conforms.","object.type.oclAsType(Classifier).allFeatures()->includes(structuralFeature) or
object.type.conformsTo(structuralFeature.oclAsType(Property).opposite.type)",1.1,,
"The visibility of the structuralFeature must allow access from the object performing the
ReadStructuralFeatureAction.","structuralFeature.visibility = VisibilityKind::public or
_'context'.allFeatures()->includes(structuralFeature) or
structuralFeature.visibility=VisibilityKind::protected and
_'context'.conformsTo(structuralFeature.oclAsType(Property).opposite.type.oclAsType(Classifi
er))",1.1,,
The structuralFeature must not be static.,not structuralFeature.isStatic,1.1,,
The structuralFeature must have exactly one featuringClassifier.,structuralFeature.featuringClassifier->size() = 1,1.1,,
"The outgoing ActivityEdges of the OutputPins of a StructuredActivityNode must have targets that are not
within the StructuredActivityNode.",output.outgoing.target->excludesAll(allOwnedNodes()-input),1.1,,
"The edges of a StructuredActivityNode are all the ActivityEdges with source and target ActivityNodes
contained directly or indirectly within the StructuredActivityNode and at least one of the source or target not
contained in any more deeply nested StructuredActivityNode.","edge=self.sourceNodes().outgoing->intersection(self.allOwnedNodes().incoming)->
union(self.targetNodes().incoming->intersection(self.allOwnedNodes().outgoing))->asSet()",1.1,,
"The incoming ActivityEdges of an InputPin of a StructuredActivityNode must have sources that are not within
the StructuredActivityNode.",input.incoming.source->excludesAll(allOwnedNodes()-output),1.1,,
The multiplicity of the InputPins is 1..1.,"first.is(1,1) and second.is(1,1)",1.1,,
The InputPins have no type.,first.type= null and second.type = null,1.1,,
The type of the result OutputPin is Boolean.,result.type=Boolean,1.1,,
The unmarshallType must have at least one StructuralFeature.,unmarshallType.allAttributes()->size() >= 1,1.1,,
The number of result outputPins must be the same as the number of attributes of the unmarshallType.,unmarshallType.allAttributes()->size() = result->size(),1.1,,
"The type, ordering and multiplicity of each attribute of the unmarshallType must be compatible with the type,
ordering and multiplicity of the corresponding result OutputPin.","let attribute:OrderedSet(Property) = unmarshallType.allAttributes() in
Sequence{1..result->size()}->forAll(i |
attribute->at(i).type.conformsTo(result->at(i).type) and
attribute->at(i).isOrdered=result->at(i).isOrdered and
attribute->at(i).compatibleWith(result->at(i)))",1.1,,
The type of the object InputPin conform to the unmarshallType.,object.type.conformsTo(unmarshallType),1.1,,
The type of the value ValueSpecification must conform to the type of the ValuePin.,value.type.conformsTo(type),1.1,,
The type of the value ValueSpecification must conform to the type of the result OutputPin.,value.type.conformsTo(result.type),1.1,,
The VariableAction must be in the scope of the variable.,variable.isAccessibleBy(self),1.1,,
The visibility of at least one end must allow access from the context Classifier of the WriteLinkAction.,"endData.end->exists(end |
end.type=_'context' or
end.visibility=VisibilityKind::public or
end.visibility=VisibilityKind::protected and
endData.end->exists(other |
other<>end and _'context'.conformsTo(other.type.oclAsType(Classifier))))",1.1,,
The multiplicity of the result OutputPin must be 1..1.,"result <> null implies result.is(1,1)",1.1,,
The type of the value InputPin must conform to the type of the structuralFeature.,value <> null implies value.type.conformsTo(structuralFeature.type),1.1,,
The type of the result OutputPin is the same as the type of the inherited object InputPin.,result <> null implies result.type = object.type,1.1,,
The type of the value InputPin must conform to the type of the variable.,value <> null implies value.type.conformsTo(variable.type),1.1,,
"The Action referenced by the ActionExecutionSpecification must be owned by the Interaction owning that
ActionExecutionSpecification.","(enclosingInteraction->notEmpty() or enclosingOperand.combinedFragment->notEmpty()) and
let parentInteraction : Set(Interaction) = enclosingInteraction.oclAsType(Interaction)-
>asSet()->union(
enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in
(parentInteraction->size() = 1) and self.action.interaction->asSet() = parentInteraction",1.1,,
"If the interactionOperator is break, the corresponding InteractionOperand must cover all Lifelines covered by
the enclosing InteractionFragment.","interactionOperator=InteractionOperatorKind::break implies
enclosingInteraction.oclAsType(InteractionFragment)->asSet()->union(
enclosingOperand.oclAsType(InteractionFragment)->asSet()).covered->asSet() =
self.covered->asSet()",1.1,,
"The interaction operators 'consider' and 'ignore' can only be used for the ConsiderIgnoreFragment subtype of
CombinedFragment.","((interactionOperator = InteractionOperatorKind::consider) or (interactionOperator =
InteractionOperatorKind::ignore)) implies oclIsKindOf(ConsiderIgnoreFragment)",1.1,,
"If the interactionOperator is opt, loop, break, assert or neg, there must be exactly one operand.","(interactionOperator = InteractionOperatorKind::opt or interactionOperator =
InteractionOperatorKind::loop or
interactionOperator = InteractionOperatorKind::break or interactionOperator =
InteractionOperatorKind::assert or
interactionOperator = InteractionOperatorKind::neg)
implies operand->size()=1",1.1,,
The interaction operator of a ConsiderIgnoreFragment must be either 'consider' or 'ignore'.,"(interactionOperator = InteractionOperatorKind::consider) or (interactionOperator =
InteractionOperatorKind::ignore)",1.1,,
"The NamedElements must be of a type of element that can be a signature for a message (i.e.., an Operation, or
a Signal).",message->forAll(m | m.oclIsKindOf(Operation) or m.oclIsKindOf(Signal)),1.1,,
"Continuations always occur as the very first InteractionFragment or the very last InteractionFragment of the
enclosing InteractionOperand.","enclosingOperand->notEmpty() and
let peerFragments : OrderedSet(InteractionFragment) = enclosingOperand.fragment in
( peerFragments->notEmpty() and
((peerFragments->first() = self) or (peerFragments->last() = self)))",1.1,,
"Across all Interaction instances having the same context value, every Lifeline instance covered by a
Continuation (self) must be common with one covered Lifeline instance of all other Continuation instances
with the same name as self, and every Lifeline instance covered by a Continuation instance with the same
name as self must be common with one covered Lifeline instance of self. Lifeline instances are common if they
have the same selector and represents associationEnd values.","enclosingOperand.combinedFragment->notEmpty() and
let parentInteraction : Set(Interaction) =
enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
collect(enclosingInteraction).oclAsType(Interaction)->asSet()
in
(parentInteraction->size() = 1)
and let peerInteractions : Set(Interaction) =
(parentInteraction->union(parentInteraction->collect(_'context')->collect(behavior)->
select(oclIsKindOf(Interaction)).oclAsType(Interaction)->asSet())->asSet()) in
(peerInteractions->notEmpty()) and
let combinedFragments1 : Set(CombinedFragment) = peerInteractions.fragment->
select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet() in
combinedFragments1->notEmpty() and combinedFragments1->closure(operand.fragment->
select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment))-
>asSet().operand.fragment->
select(oclIsKindOf(Continuation)).oclAsType(Continuation)->asSet()->
forAll(c : Continuation | (c.name = self.name) implies
(c.covered->asSet()->forAll(cl : Lifeline | -- cl must be common to one lifeline covered
by self
self.covered->asSet()->
select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))
and
(self.covered->asSet()->forAll(cl : Lifeline | -- cl must be common to one lifeline
covered by c
c.covered->asSet()->
select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))
)",1.1,,
"Continuations are always global in the enclosing InteractionFragment e.g., it always covers all Lifelines
covered by the enclosing InteractionOperator.","enclosingOperand->notEmpty() and
let operandLifelines : Set(Lifeline) = enclosingOperand.covered in
(operandLifelines->notEmpty() and
operandLifelines->forAll(ol :Lifeline |self.covered->includes(ol)))",1.1,,
"No other OccurrenceSpecifications on a given Lifeline in an InteractionOperand may appear below a
DestructionOccurrenceSpecification.","let o : InteractionOperand = enclosingOperand in o->notEmpty() and let peerEvents : OrderedSet(OccurrenceSpecification) = covered.events-
>select(enclosingOperand = o)
in peerEvents->last() = self",1.1,,
The startEvent and the finishEvent must be on the same Lifeline.,start.covered = finish.covered,1.1,,
"If this Gate is an actualGate, it must have exactly one matching formalGate within the referred Interaction.","interactionUse->notEmpty() implies interactionUse.refersTo.formalGate-
>select(matches(self))->size()=1",1.1,,
"If this Gate is inside a CombinedFragment, it must have exactly one matching Gate which is outside of that
CombinedFragment.","isInsideCF() implies combinedFragment.cfragmentGate->select(isOutsideCF() and
matches(self))->size()=1",1.1,,
"If this Gate is outside an 'alt' CombinedFragment, for every InteractionOperator inside that CombinedFragment
there must be exactly one matching Gate inside the CombinedFragment with its opposing end enclosed by that
InteractionOperator. If this Gate is outside CombinedFragment with operator other than 'alt', there must be
exactly one matching Gate inside that CombinedFragment.","isOutsideCF() implies if self.combinedFragment.interactionOperator->asOrderedSet()->first() =InteractionOperatorKind::alt
then self.combinedFragment.operand->forAll(op : InteractionOperand | self.combinedFragment.cfragmentGate->select(isInsideCF() and oppositeEnd().enclosingFragment()->includes(self.combinedFragment) and matches(self))-
>size()=1) else self.combinedFragment.cfragmentGate->select(isInsideCF() and matches(self))->size()=1 endif",1.1,0,
"isFormal() implies that no other formalGate of the parent Interaction returns the same getName() as returned
for self.",isFormal() implies interaction.formalGate->select(getName() = self.getName()),1.1,,
"isActual() implies that no other actualGate of the parent InteractionUse returns the same getName() as returned
for self.",isActual() implies interactionUse.actualGate->select(getName() = self.getName())->size()=1,1.1,,
"isOutsideCF() implies that no other outside cfragmentGate of the parent CombinedFragment returns the same
getName() as returned for self.",isOutsideCF() implies combinedFragment.cfragmentGate->select(getName() =self.getName())->size()=1,1.1,,
"isInsideCF() implies that no other inside cfragmentGate attached to a message with its other end in the same
InteractionOperator as self, returns the same getName() as returned for self.","isInsideCF() implies
let selfOperand : InteractionOperand = self.getOperand() in
combinedFragment.cfragmentGate->select(isInsideCF() and getName() = self.getName())-
>select(getOperand() = selfOperand)->size()=1",1.1,,
"An occurrence specification must not be ordered relative to itself through a series of general orderings. (In
other words, the transitive closure of the general orderings is irreflexive.)",after->closure(toAfter.after)->excludes(before),1.1,,
An Interaction instance must not be contained within another Interaction instance.,enclosingInteraction->isEmpty(),1.1,,
"Minint/maxint can only be present if the InteractionConstraint is associated with the operand of a loop
CombinedFragment.","maxint->notEmpty() or minint->notEmpty() implies
interactionOperand.combinedFragment.interactionOperator =
InteractionOperatorKind::loop",1.1,,
"If minint is specified, then the expression must evaluate to a non-negative integer.",minint->notEmpty() implies minint->asSequence()->first().integerValue() >= 0,1.1,,
"If maxint is specified, then the expression must evaluate to a positive integer.","maxint->notEmpty() implies
maxint->asSequence()->first().integerValue() > 0",1.1,,
"If maxint is specified, then minint must be specified and the evaluation of maxint must be >= the evaluation of
minint.","maxint->notEmpty() implies (minint->notEmpty() and
maxint->asSequence()->first().integerValue() >=
minint->asSequence()->first().integerValue() )",1.1,,
"Actual Gates of the InteractionUse must match Formal Gates of the referred Interaction. Gates match when
their names are equal and their messages correspond.","actualGate->notEmpty() implies
refersTo.formalGate->forAll( fg : Gate | self.actualGate->select(matches(fg))->size()=1) and
self.actualGate->forAll(ag : Gate | refersTo.formalGate->select(matches(ag))->size()=1)",1.1,,
"The returnValueRecipient must be a Property of a ConnectableElement that is represented by a Lifeline
covered by this InteractionUse.","returnValueRecipient->asSet()->notEmpty() implies
let covCE : Set(ConnectableElement) = covered.represents->asSet() in
covCE->notEmpty() and let classes:Set(Classifier) =
covCE.type.oclIsKindOf(Classifier).oclAsType(Classifier)->asSet() in
let allProps : Set(Property) = classes.attribute->union(classes.allParents().attribute)-
>asSet() in
allProps->includes(returnValueRecipient)",1.1,,
The type of the returnValue must correspond to the type of the returnValueRecipient.,"returnValue.type->asSequence()->notEmpty() implies returnValue.type->asSequence()-
>first() = returnValueRecipient.type->asSequence()->first()",1.1,,
"The InteractionUse must cover all Lifelines of the enclosing Interaction that are common with the lifelines
covered by the referred Interaction. Lifelines are common if they have the same selector and represents
associationEnd values.","let parentInteraction : Set(Interaction) = enclosingInteraction->asSet()->
union(enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in
parentInteraction->size()=1 and let refInteraction : Interaction = refersTo in
parentInteraction.covered-> forAll(intLifeline : Lifeline | refInteraction.covered->
forAll( refLifeline : Lifeline | refLifeline.represents = intLifeline.represents and
(
( refLifeline.selector.oclIsKindOf(LiteralString) implies
intLifeline.selector.oclIsKindOf(LiteralString) and
refLifeline.selector.oclAsType(LiteralString).value =
intLifeline.selector.oclAsType(LiteralString).value ) and
( refLifeline.selector.oclIsKindOf(LiteralInteger) implies
intLifeline.selector.oclIsKindOf(LiteralInteger) and
refLifeline.selector.oclAsType(LiteralInteger).value =
intLifeline.selector.oclAsType(LiteralInteger).value ))
implies self.covered->asSet()->includes(intLifeline)))",1.1,,
The selector for a Lifeline must only be specified if the referenced Part is multivalued.,"self.selector->notEmpty() = (self.represents.oclIsKindOf(MultiplicityElement) and
self.represents.oclAsType(MultiplicityElement).isMultivalued())",1.1,,
"If a lifeline is in an Interaction referred to by an InteractionUse in an enclosing Interaction, and that lifeline is
common with another lifeline in an Interaction referred to by another InteractonUse within that same enclosing
Interaction, it must be common to a lifeline within that enclosing Interaction. By common Lifelines we mean
Lifelines with the same selector and represents associations.","let intUses : Set(InteractionUse) = interaction.interactionUse in
intUses->forAll
( iuse : InteractionUse |
let usingInteraction : Set(Interaction) = iuse.enclosingInteraction->asSet()
->union(
iuse.enclosingOperand.combinedFragment->asSet()-
>closure(enclosingOperand.combinedFragment).enclosingInteraction->asSet())
in
let peerUses : Set(InteractionUse) = usingInteraction.fragment-
>select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()
->union(
usingInteraction.fragment-
>select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet()
->closure(operand.fragment-
>select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)).operand.fragment->
select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()
)->excluding(iuse)
in
peerUses->forAll( peerUse : InteractionUse |
peerUse.refersTo.lifeline->forAll( l : Lifeline | (l.represents = self.represents and
( self.selector.oclIsKindOf(LiteralString) implies
l.selector.oclIsKindOf(LiteralString) and
self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )
and
( self.selector.oclIsKindOf(LiteralInteger) implies
l.selector.oclIsKindOf(LiteralInteger) and
self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value
))
implies
usingInteraction.lifeline->select(represents = self.represents and
( self.selector.oclIsKindOf(LiteralString) implies
l.selector.oclIsKindOf(LiteralString) and
self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )
and
( self.selector.oclIsKindOf(LiteralInteger) implies
l.selector.oclIsKindOf(LiteralInteger) and
self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value
))
)
)
)",1.1,,
"The classifier containing the referenced ConnectableElement must be the same classifier, or an ancestor, of the
classifier that contains the interaction enclosing this lifeline.",represents.namespace->closure(namespace)->includes(interaction._'context'),1.1,,
"The selector value, if present, must be a LiteralString or a LiteralInteger.","self.selector->notEmpty() implies
self.selector.oclIsKindOf(LiteralInteger) or
self.selector.oclIsKindOf(LiteralString)",1.1,,
"If the sendEvent and the receiveEvent of the same Message are on the same Lifeline, the sendEvent must be
ordered before the receiveEvent.","receiveEvent.oclIsKindOf(MessageOccurrenceSpecification)
implies let f : Lifeline = sendEvent-
>select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecificatio
n)->asOrderedSet()->first().covered in
f = receiveEvent-
>select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecificatio
n)->asOrderedSet()->first().covered implies
f.events->indexOf(sendEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()-
>first() ) <
f.events->indexOf(receiveEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()-
>first() )",1.1,,
"Messages cannot cross boundaries of CombinedFragments or their operands. This is true if and only if both
MessageEnds are enclosed within the same InteractionFragment (i.e., an InteractionOperand or an Interaction).","sendEvent->notEmpty() and receiveEvent->notEmpty() implies
let sendEnclosingFrag : Set(InteractionFragment) =
sendEvent->asOrderedSet()->first().enclosingFragment()
in
let receiveEnclosingFrag : Set(InteractionFragment) =
receiveEvent->asOrderedSet()->first().enclosingFragment()
in sendEnclosingFrag = receiveEnclosingFrag",1.1,,
"In the case when the Message signature is a Signal, the arguments of the Message must correspond to the
attributes of the Signal. A Message Argument corresponds to a Signal Attribute if the Argument is of the same
Class or a specialization of that of the Attribute.","(messageSort = MessageSort::asynchSignal ) and signature.oclIsKindOf(Signal) implies
let signalAttributes : OrderedSet(Property) =
signature.oclAsType(Signal).inheritedMember()->
select(n:NamedElement | n.oclIsTypeOf(Property))->collect(oclAsType(Property))-
>asOrderedSet()
in signalAttributes->size() = self.argument->size()
and self.argument->forAll( o: ValueSpecification |
not (o.oclIsKindOf(Expression)
and o.oclAsType(Expression).symbol->size()=0
and o.oclAsType(Expression).operand->isEmpty() ) implies
let p : Property = signalAttributes->at(self.argument->indexOf(o))
in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)))",1.1,,
"The signature must either refer an Operation (in which case messageSort is either synchCall or asynchCall or
reply) or a Signal (in which case messageSort is asynchSignal). The name of the NamedElement referenced by
signature must be the same as that of the Message.","signature->notEmpty() implies
((signature.oclIsKindOf(Operation) and
(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or
messageSort = MessageSort::reply)
) or (signature.oclIsKindOf(Signal) and messageSort = MessageSort::asynchSignal )
) and name = signature.name",1.1,,
"In the case when a Message with messageSort synchCall or asynchCall has a non empty Operation signature,
the arguments of the Message must correspond to the in and inout parameters of the Operation. A Parameter
corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.","(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall) and
signature.oclIsKindOf(Operation) implies
let requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
select(direction = ParameterDirectionKind::inout or direction =
ParameterDirectionKind::_'in' )
in requestParms->size() = self.argument->size() and
self.argument->forAll( o: ValueSpecification |
not (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and
o.oclAsType(Expression).operand->isEmpty() ) implies
let p : Parameter = requestParms->at(self.argument->indexOf(o)) in
o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
)",1.1,,
"In the case when a Message with messageSort reply has a non empty Operation signature, the arguments of the
Message must correspond to the out, inout, and return parameters of the Operation. A Parameter corresponds to
an Argument if the Argument is of the same Class or a specialization of that of the Parameter.","(messageSort = MessageSort::reply) and signature.oclIsKindOf(Operation) implies
let replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out
or direction = ParameterDirectionKind::return)
in replyParms->size() = self.argument->size() and
self.argument->forAll( o: ValueSpecification | o.oclIsKindOf(Expression) and let e :
Expression = o.oclAsType(Expression) in
e.operand->notEmpty() implies
let p : Parameter = replyParms->at(self.argument->indexOf(o)) in
e.operand->asSequence()-
>first().type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
)",1.1,,
"An Actor can only have Associations to UseCases, Components, and Classes. Furthermore these Associations
must be binary.","Association.allInstances()->forAll( a |
a.memberEnd->collect(type)->includes(self) implies
(
a.memberEnd->size() = 2 and
let actorEnd : Property = a.memberEnd->any(type = self) in
actorEnd.opposite.class.oclIsKindOf(UseCase) or
( actorEnd.opposite.class.oclIsKindOf(Class) and not
actorEnd.opposite.class.oclIsKindOf(Behavior))
)
)",1.1,,
An Actor must have a name.,name->notEmpty(),1.1,,
The ExtensionPoints referenced by the Extend relationship must belong to the UseCase that is being extended.,extensionLocation->forAll (xp | extendedCase.extensionPoint->includes(xp)),1.1,,
An ExtensionPoint must have a name.,name->notEmpty (),1.1,,
UseCases can only be involved in binary Associations.,"Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies
a.memberEnd->size() = 2)",1.1,,
UseCases cannot have Associations to UseCases specifying the same subject.,"Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies
(
let usecases: Set(UseCase) = a.memberEnd.type->select(oclIsKindOf(UseCase))-
>collect(oclAsType(UseCase))->asSet() in
usecases->size() > 1 implies usecases->collect(subject)->size() > 1
)
)",1.1,,
A UseCase cannot include UseCases that directly or indirectly include it.,not allIncludedUseCases()->includes(self),1.1,,
A UseCase must have a name.,name -> notEmpty (),1.1,,
The association ends of a CommunicationPath are typed by DeploymentTargets.,endType->forAll (oclIsKindOf(DeploymentTarget)),1.1,,
The DeploymentTarget of a DeploymentSpecification is a kind of ExecutionEnvironment.,deployment->forAll (location.oclIsKindOf(ExecutionEnvironment)),1.1,,
"The deployedElements of a DeploymentTarget that are involved in a Deployment that has an associated
Deployment-Specification is a kind of Component (i.e., the configured components).",deployment->forAll (location.deployedElement->forAll (oclIsKindOf(Component))),1.1,,
The internal structure of a Node (if defined) consists solely of parts of type Node.,part->forAll(oclIsKindOf(Node)),1.1,,
"The sources and targets of the information flow can only be one of the following kind: Actor, Node, UseCase,
Artifact, Class, Component, Port, Property, Interface, Package, ActivityNode, ActivityPartition, Behavior and
InstanceSpecification except when its classifier is a relationship (i.e. it represents a link).","(self.informationSource->forAll( sis |
oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact)
or
oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property)
or
oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or
oclIsKindOf(ActivityPartition) or
(oclIsKindOf(InstanceSpecification) and not
sis.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship)))))
and
(self.informationTarget->forAll( sit |
oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact)
or
oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property)
or
oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or
oclIsKindOf(ActivityPartition) or
(oclIsKindOf(InstanceSpecification) and not sit.oclAsType(InstanceSpecification).classifier-
>exists(oclIsKindOf(Relationship)))))",1.1,,
An information flow can only convey classifiers that are allowed to represent an information item.,"self.conveyed->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface)
or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component))",1.1,,
"The sources and targets of an information item (its related information flows) must designate subsets of the
sources and targets of the representation information item, if any. The Classifiers that can realize an
information item can only be of the following kind: Class, Interface, InformationItem, Signal, Component.","(self.represented->select(oclIsKindOf(InformationItem))->forAll(p |
p.conveyingFlow.source->forAll(q | self.conveyingFlow.source->includes(q)) and
p.conveyingFlow.target->forAll(q | self.conveyingFlow.target->includes(q)))) and
(self.represented->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface) or
oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component)))",1.1,,
"An informationItem has no feature, no generalization, and no associations.",self.generalization->isEmpty() and self.feature->isEmpty(),1.1,,
isFrame and isActivityFrame must not be true at the same time.,not (isActivityFrame and isFrame),1.1,,
modelElement must be an Association end.,not modelElement->forAll(association->isEmpty()),1.1,,
UMLAssociationOrConnectorOrLinkShapes must have exactly one modelElement.,modelElement->size()=1,1.1,,
"modelElement must be an Association, Connector, or InstanceSpecification with an Association classifier.","modelElement->asSequence()->first().oclIsKindOf(Association) or modelElement-
>asSequence()->first().oclIsKindOf(Connector)
or ( modelElement->asSequence()->first().oclIsKindOf(InstanceSpecification)
and (modelElement->asSequence()->first().oclAsType(InstanceSpecification).classifier-
>select(oclIsKindOf(Association))->size() > 0))",1.1,,
"For diamond kind and an Association modelElement, the Association has exactly two memberEnds, and
exactly two of the UMLEdges linked to the shape have those memberEnds as modelElements.","(kind=UMLAssociationOrConnectorOrLinkShapeKind::diamond and modelElement-
>forAll(oclIsKindOf(Association))) implies
let association : Association = modelElement->any(true).oclAsType(Association) in
((association.memberEnd->size() = 2) and
(sourceEdge.modelElement->union(targetEdge.modelElement)->select(em |
association.memberEnd->includes(em))->size()=2))",1.1,,
"For diamond kind and an InstanceSpecification modelElement, exactly one Association classifier of the
InstanceSpecification has exactly two memberEnds and exactly two of the UMLEdges linked to the shape have
those memberEnds as modelElements.","(kind=UMLAssociationOrConnectorOrLinkShapeKind::diamond and modelElement-
>forAll(oclIsKindOf(InstanceSpecification))) implies
let instanceSpecification : InstanceSpecification = modelElement-
>any(true).oclAsType(InstanceSpecification) in
(instanceSpecification.classifier->select(a | a.oclIsKindOf(Association) and
(a.oclAsType(Association).memberEnd->size() = 2) and
(sourceEdge.modelElement->union(targetEdge.modelElement)
->select(e | a.oclAsType(Association).memberEnd->includes(e.modelElement))
->size()=2))
->size()=1)",1.1,,
"For diamond kind and a Connector modelElement, the Connector has exactly two ends, and exactly two of the
UMLEdges linked to the shape have definingEnds of those ends as modelElements.","(kind=UMLAssociationOrConnectorOrLinkShapeKind::diamond and modelElement-
>forAll(oclIsKindOf(Connector))) implies
let connector : Connector = modelElement->any(true).oclAsType(Connector) in
((connector.end->size() = 2) and
(sourceEdge.modelElement->union(targetEdge.modelElement)->select(em |
connector.end.definingEnd->includes(em))->size()=2))",1.1,,
UMLClassDiagrams must have no modelElements.,modelElement->isEmpty(),1.1,,
isDoubleSided may be true only when modelElement is an active Class.,"isDoubleSided implies (modelElement->forAll(oclIsKindOf(Class)) and
modelElement.oclAsType(Class)->forAll(isActive))",1.1,,
UMLCompositeStructureDiagrams must have exactly one modelElement.,modelElement->size() = 1,1.1,,
"modelElement must be a StructuredClassifier or an InstanceSpecification with a classifier that is a
StructuredClassifier.","modelElement->asSequence()->first().oclIsKindOf(StructuredClassifier)
or ( modelElement->asSequence()->first().oclIsKindOf(InstanceSpecification)
and (modelElement->asSequence()->first().oclAsType(InstanceSpecification).classifier-
>select(c | c.oclIsKindOf(StructuredClassifier))->size() > 0))",1.1,,
"UMLDiagrams cannot have headings without frames, or vice-versa.",(isFrame = false) = (heading->isEmpty()),1.1,,
The modelElement of the heading is the same as the modelElement of the diagram it heads.,(heading->isEmpty()) or (heading.modelElement = modelElement),1.1,,
UMLLabels must have no more than one modelElement.,modelElement->size() <= 1,1.1,,
UMLLabels must have the value of false for isIcon.,isIcon=false,1.1,,
isInheritedDashed and isInheritedLighter cannot both have a value of true.,not (isInheritedDashed and isInheritedLighter),1.1,,
"UMLStateShapes may have multiple modelElements only when their outgoing Transitions have no triggers or
effects, and target the same junction State that has one outgoing Transition.","(modelElement->size() > 1) implies
( modelElement->forAll(outgoing->forAll(trigger->isEmpty() and
effect->isEmpty()
and
target.oclIsKindOf(Pseudostate) and
target.oclAsType(Pseudostate).kind = PseudostateKind::junction and
target.outgoing-
>size() = 1))
and modelElement.outgoing.target->asSet()->size()=1)",1.1,,
modelElement is a Property of a Stereotype.,modelElement->forAll(classifier.oclIsKindOf(Stereotype)),1.1,,
fontSize must be greater than zero.,fontSize > 0,1.1,,
"The referenceUnit shall not be a PrefixedUnit, i.e., it is not allowed to prefix an already prefixed
measurement unit. In general the referenceUnit should be a SimpleUnit.
",not referenceUnit.oclIsTypeOf(PrefixedUnit),1.2,,
The denominator of a rational number shall not be zero.,denominator <> 0,1.2,,
A QuantityKind cannot be defined in terms of itself. This follows from the quantity calculus used for expressing a derived QuantityKind in terms of base QuantityKinds chosen for a SystemOfQuantities by means of non- contradictory equations,"dependsOnQuantityKinds()->excludes(self)
",1.2,,
"For a QuantityKind to have a provenance to a single SystemOfQuantities, all included systems of quantities
shall be transitively disjoint with all used systems of quantities.","allIncludedSystemOfQuantities()->intersection(self.oclAsSet()
->closure(usedSystemOfQuantities))->isEmpty()",1.2,,
"The set of all QuantityKinds in a given SystemOfQuantities shall be partitioned into two disjoint, covering subsets: 
the set of base QuantityKinds (typically chosen to be mutually independent) and its complement, the 
set of derived QuantityKinds, each of which can be expressed in terms of the base QuantityKinds",allQuantityKinds()->includesAll(allBaseQuantityKinds()),1.2,,
" Every QuantityKind shall be defined in only one SystemOfQuantities but it can be in the scope of several 
SystemOfQuantities. A given QuantityKind is in scope of a SystemOfQuantities either because it is defined or used in a 
SystemOfQuantities or because it is included from the scope of another SystemOfQuantities.","includedSystemOfQuantities->collect(allQuantityKinds())
->intersection(quantityKind)->isEmpty()",1.2,,
"For a QuantityKind to have a provenance to a single SystemOfQuantities, the use and includes relationships among 
SystemOfQuantities shall be acyclic.",allAccessibleSystemOfQuantities()->excludes(self),1.2,,
" In a well-formed SystemOfUnits, all of the prefixes of PrefixedUnits shall be defined in the SystemOfUnits.","allPrefixes()->includesAll(allUnits()->select(oclIsTypeOf(PrefixedUnit))
->collect(oclAsType(PrefixedUnit).prefix))",1.2,,
All the dependent Units of a SystemOfUnits shall be in the scope of that SystemOfUnits.,allUnits()->includesAll(allUnits()->collect(dependsOnUnits())->flatten()->asSet()),1.2,,
" All of the quantityKinds that are measurementUnits of Units in the SystemOfUnits shall be defined in the 
systemOfQuantities of that SystemOfUnits.","getEffectiveSystemOfQuantities() = null or let aqk : Set(QuantityKind) = 
getEffectiveSystemOfQuantities().allQuantityKinds() in ->allUnits()
->forAll(u | aqk
->includesAll(getKindOfQuantitiesForMeasurementUnit(u)))",1.2,,
"For a Unit to have a provenance to a single SystemOfUnits, all included systems of units shall be transitively disjoint 
with all used systems of units.","allIncludedSystemOfUnits()->intersection(self.oclAsSet()
->closure(usedSystemOfUnits))->isEmpty()",1.2,,
" The set of all Units in a given SystemOfUnits shall be capable of being partitioned into two disjoint, covering subsets: 
the set of base Units (typically chosen to be mutually independent) and all its complement, the set of derived Units, each of which can be expressed in terms of the base Units",allUnits()->includesAll(allBaseUnits()),1.2,,
"Every Unit shall be defined in only one SystemOfUnits but it can be in the scope of several SystemOfUnits. A given 
Unit is in scope of a SystemOfUnits either because it is defined or used in a SystemOfUnits or because it is included 
from the scope of another SystemOfUnits.",includedSystemOfUnits->collect(allUnits())->intersection(unit)->isEmpty()),1.2,,
" For a Unit to have a provenance to a single SystemOfUnits, the use and includes relationships among SystemOfUnits 
shall be acyclic.",allAccessibleSystemOfUnits()->excludes(self),1.2,,
"A Unit cannot be defined in terms of itself. This follows from the requirement that, in a coherent SystemOfUnits, the Units of all derived QuantityKinds are expressed in terms of the base Units in accordance with the equations in the SystemOfQuantities",dependsOnUnits()->excludes(self),1.2,,
The client shall be an element stereotyped by View.,View.allInstances()->exists(v | v.base_Class = self.base_Dependency.client),1.2,,
"A Stakeholder stereotype can only be applied to UML::Actor or UML::Class which are not a
UML::Association.","self.base_Classifier.oclIsKindOf(UML::Actor)
or
(self.base_Classifier.oclIsKindOf(UML::Class)
and
not self.base_Classifier.oclIsKindOf(UML::Association))",1.2,,
"The stakeholder stereotype can only be applied to UML::Actor or UML::Class which are not a
UML::Association","(self.base_Classifier.oclIsKindOf(UML::Actor) or
self.base_Classifier.oclIsKindOf(UML::Class))
and not self.base_Classifier.oclIsKindOf(UML::Association)",1.2,,
A view shall only conform to a single viewpoint,"Conform.allInstances()->select(base_Generalization.specific = self.base_Class)
->size() = 1",1.2,,
"The derived value of the viewpoint shall be the classifier stereotyped by Viewpoint that is the general classifier
of the generalization relationship stereotyped by Conform for which the View is the specific classifier","self.viewpoint = Viewpoint.allInstances()->any(base_Class = Conform.allInstances()
->any(base_Generalization.specific = self.base_Class).base_Generalization.general)",1.2,,
"The derived values of the stakeholder attribute shall be the classifiers stereotyped by Stakeholder that are the
values of the stakeholder attribute of the general classifier of the generalization relationship stereotyped by
Conform for which the View is the specific classifier.","self.stakeholder = Viewpoint.allInstances()->any(base_Class = Conform.allInstances()
->any(base_Generalization.specific =
self.base_Class).base_Generalization.general).stakeholder",1.2,,
"The derived values of the method attribute shall be the names of the methods of the operations stereotyped by
the UML Create stereotype on the classifier stereotyped by Viewpoint.","self.method = self.base_Class.allFeatures()->select(f |
f.oclIsKindOf(UML::Operation))->select(o |
Standard::Create.allInstances().base_BehavioralFeature
->includes(o)).oclAsType(UML::Operation).method",1.2,,
The general classifier shall be an element stereotyped by Viewpoint,Viewpoint.allInstances()->exists(v | v.base_Class = self.base_Generalization.general),1.2,,
The specific classifier shall be an element that is stereotyped by View,View.allInstances()->exists(v | v.base_Class = self.base_Generalization.specific),1.2,,
"Properties with AdjunctProperty applied that have a Variable or Parameter as principal shall have a lower
multiplicity the same as or lower than the lower multiplicity of their principal, and an upper multiplicity the
same as or higher than the upper multiplicity of their principal","self.principal.oclIsKindOf(UML::MultiplicityElement) implies self.base_Property.lower
<= self.principal.oclAsType(UML::MultiplicityElement).lower and
self.base_Property.upper >= self.principal.oclAsType(UML::MultiplicityElement).upper",1.2,,
"Properties with AdjunctProperty applied that have an InteractionUse or submachine State as principal shall be
composite and be typed by the interaction or state machine invoked by the interaction use or submachine State
or one of their generalizations.","self.principal.oclIsKindOf(UML::InteractionUse) or
self.principal.oclIsKindOf(UML::State) implies let behavior: UML::Behavior = if
self.principal.oclIsKindOf(UML::InteractionUse) then
self.principal.oclAsType(UML::InteractionUse).refersTo else
self.principal.oclAsType(UML::State).submachine endif in if behavior.oclIsUndefined()
then self.base_Property.type->isEmpty() else self.base_Property.type->notEmpty() and
behavior->closure(generalization)->including(behavior)
->includes(self.base_Property.type) endif",1.2,,
"The principal of an applied AdjunctProperty shall be a Connector, CallAction, ObjectNode, Variable, Parameter,
submachine State, or InteractionUse.","self.principal.oclIsKindOf(UML::Connector) or
self.principal.oclIsKindOf(UML::CallAction) or
self.principal.oclIsKindOf(UML::ObjectNode) or self.principal.oclIsKindOf(UML::Variable) or
self.principal.oclIsKindOf(UML::Parameter) or
self.principal.oclIsKindOf(UML::InteractionUse) or
(self.principal.oclIsKindOf(UML::State) and
self.principal.oclAsType(UML::State).isSubmachineState)",1.2,,
"Properties to which AdjunctProperty applied shall have the same name as the principal, if the principal is a
NamedElement.","self.principal.oclIsKindOf(UML::NamedElement) implies self.base_Property.name =
self.principal.oclAsType(UML::NamedElement).name",1.2,,
Properties with AdjunctProperty applied that have a Connector or CallAction as principal shall be composite.,"self.principal.oclIsKindOf(UML::Connector) or
self.principal.oclIsKindOf(UML::CallAction) implies self.base_Property.isComposite()",1.2,,
"Properties with AdjunctProperty applied shall be owned by an element that owns the principal, at least
indirectly, or one of that elements specializations.","let owners: Set(UML::Element) = self.principal->closure(owner) in let
specializations: Set(UML::Element) = UML::Classifier.allInstances()->select(c |
c->closure(general)->intersection(owners)->notEmpty()) in owners
->union(specializations)->includes(self.base_Property.owner)",1.2,,
"Properties with AdjunctProperty applied that have as principal a Connector, ObjectNode, Variable, or Parameter
shall have the same type as the principal or one of that types generalizations","self.principal.oclIsKindOf(UML::Connector) or
self.principal.oclIsKindOf(UML::Variable) or
self.principal.oclIsKindOf(UML::Parameter) implies let principal_type:
UML::Classifier = if self.principal.oclIsKindOf(UML::Connector) then
self.principal.oclAsType(UML::Connector).type else
self.principal.oclAsType(UML::TypedElement).type.oclAsType(UML::Classifier) endif in
principal_type->closure(general)->including(principal_type)
->includes(self.base_Property.type)",1.2,,
Connectors that are principals of an applied AdjunctProperty shall have association blocks as types,"self.principal.oclIsKindOf(UML::Connector) implies let type: UML::Association =
self.principal.oclAsType(UML::Connector).type in Block.allInstances().base_Class
->includes(type)",1.2,,
"AdjunctProperty and ConnectorProperty applied to the same property shall have the same values for principal
and connector, respectively.","AdjunctProperty.allInstances()->forAll(ap | let cp: ConnectorProperty =
ConnectorProperty.allInstances()->any(base_Property=ap.base_Property) in (not
cp.oclIsUndefined()) implies cp.connector = ap.principal) ",1.2,,
"Properties with AdjunctProperty applied that have a CallAction as principal shall be composite and be typed by
the behavior invoked by the call action or one of that behaviors generalizations (for CallOperationAct ions, this
shall generalize all behaviors that might be dispatched), and an upper multiplicity of one if the CallAction
invokes a nonreentrant behavior.","self.principal.oclIsKindOf(UML::CallAction) implies if
self.principal.oclIsKindOf(UML::CallOperationAction) then let called:
Set(UML::Behavior) =
self.principal.oclAsType(UML::CallOperationAction).operation.method in if called
->isEmpty() then self.base_Property.type->isEmpty() else self.base_Property.type
->notEmpty() and called->forAll(b | b.general->including(b)
->includes(self.base_Property.type)) endif else let called: UML::Behavior = if
self.principal.oclIsKindOf(UML::CallBehaviorAction) then
self.principal.oclAsType(UML::CallBehaviorAction).behavior else
self.principal.oclAsType(UML::StartObjectBehaviorAction).behavior() endif in if
called.oclIsUndefined() then self.base_Property.type.oclIsUndefined() else let
behaviors: Set(UML::Behavior) = called
->closure(generalization).oclAsType(UML::Behavior)->including(called)->asSet() in
self.base_Property.type->notEmpty() and behaviors->includes(self.base_Property.type)
endif endif",1.2,,
"Properties with AdjunctProperty applied that have an ObjectNode as principal shall have a lower multiplicity of
zero and an upper multiplicity the same as or higher than the upperBound of the ObjectNode.","self.principal.oclIsKindOf(UML::ObjectNode) implies self.base_Property.lower = 0 and
self.base_Property.upper >=
self.principal.oclAsType(UML::ObjectNode).upperBound.unlimitedValue()",1.2,,
"The two ends of a binding connector shall have either the same type or types that are compatible so that equality
of their values can be defined.","self.base_Connector.end->at(1).role.type.conformsTo(self.base_Connector.end
->at(2).role.type) or self.base_Connector.end
->at(2).role.type.conformsTo(self.base_Connector.end->at(1).role.type)",1.2,,
"For an association in which both ends are typed by blocks, the number of ends shall be exactly two.","UML::Association.allInstances()->select(a| a.memberEnd->forAll(e| e.type->notEmpty()
and Block.allInstances().base_Class->includes(e.type)))->forAll(a | a.memberEnd
->size()=2)",1.2,,
"The number of ends of a connector owned by a block shall be exactly two. (In SysML, a binding connector is
not typed by an association, so this constraint is not implied entirely by the preceding constraint.)",self.base_Class.ownedConnector->forAll(c | c.end->size()=2 ),1.2,,
"If a property owned by a SysML Block or SysML ValueType is typed by a SysML ValueType, then the
aggregation attribute of the property shall be ""composite.""","self.base_Class.ownedAttribute->select(a| ValueType.allInstances().base_DataType
->includes(a.type))->forAll(a|a.isComposite())",1.2,,
"Within an instance of a SysML Block, the values of any property with composite aggregation (aggregation =
composite) shall not contain the block in any of its own properties that also have composite aggregation, or
within any unbroken chain of properties that all have composite aggregation. (Within an instance of a SysML
Block, the instances of properties with composite aggregation shall form an acyclic graph.)","self.base_Class->closure(part-
>select(p|p.type.oclIsKindOf(UML::Class)).type.oclAsType(UML::Class))
->excludes(self.base_Class)",1.2,,
Any classifier that specializes a Block shall also have the Block stereotype or one of its specializations applied,"UML::Classifier.allInstances()->select(c | c.general->includes(self.base_Class))
->forAll(c | Block.allInstances()->includes(c))",1.2,,
"Properties to which BoundReference is applied shall be the role of a connector end of at least one binding
connector, or generalized by such a property through redefinition","BindingConnector.allInstances().base_Connector.end.role->exists(r |
r=self.base_Property or self.base_Property->closure(redefinedElement)->includes(r))",1.2,,
"The value of boundEnd shall be a connector end of a binding connector, as identified in constraint 1, opposite
the property, as identified in constraint 1.","let opposite: UML::ConnectorEnd = BindingConnector.allInstances().base_Connector.end
->any(e | e.role=self.base_Property or self.base_Property->closure(redefinedElement)
->includes(e.role)) in self.boundEnd = opposite.owner.oclAsType(UML::Connector).end
->any(e | e<>opposite)",1.2,,
"The role of boundEnd shall be a property accessible by navigation from instances of the block owning the
property to which BoundReference is applied, but shall not be the property to which BoundReference is applied,
or one that it is related to by redefinition.","self.base_Property.association->notEmpty() and self.boundEnd.definingEnd->notEmpty()
and self.base_Property.association.navigableOwnedEnd
->includes(self.boundEnd.definingEnd)",1.2,,
"self.base_Property.association->notEmpty() and self.boundEnd.definingEnd->notEmpty()
and self.base_Property.association.navigableOwnedEnd
->includes(self.boundEnd.definingEnd)","self.boundEnd = self.bindingPath->last() and (let nce: NestedConnectorEnd =
NestedConnectorEnd.allInstances()->any(n| n.base_ConnectorEnd=self.boundEnd) in nce
->oclIsUndefined() or self.bindingPath->subSequence(1, self.bindingPath->size()-1) =
nce.propertyPath)",1.2,,
Properties to which BoundReference is applied shall either be reference properties or value properties.,"ValueType.allInstances().base_DataType->includes(self.base_Property.type) or not
self.base_Property.isComposite()",1.2,,
"Properties with BoundReference applied that have an upper multiplicity greater than one shall be ordered and
non-unique.","self.base_Property.upper > 1 implies self.base_Property.isOrdered and not
self.base_Property.isUnique",1.2,,
"BoundReferences shall not be applied to properties that are related by redefinition to other properties with
BoundReference applied.","self.base_Property.redefinedElement->notEmpty() implies
BoundReference.allInstances().base_Property
->excludesAll(self.base_Property.redefinedElement)",1.2,,
"The binding connector identified in constraint 1 shall not have the same property on both ends, or properties
related by redefinition.","let e1: UML::ConnectorEnd = self.boundEnd.owner.oclAsType(UML::Connector).end->at(1)
in let e2: UML::ConnectorEnd = self.boundEnd.owner.oclAsType(UML::Connector).end
->at(2) in e1.role <> e2.role and (e1.role.oclIsKindOf(UML::Property) and
e2.role.oclIsKindOf(UML::Property) implies
e1.role.oclAsType(UML::Property).redefinedElement->excludes(e2.role) and
e2.role.oclAsType(UML::Property).redefinedElement->excludes(e1.role))",1.2,,
"ClassifierBehaviorProperty shall only be applied to properties owned (not inherited) by blocks that have
classifier behaviors.","Block.allInstances().base_Class->exists(c | c.ownedAttribute
->includes(self.base_Property) and c.classifierBehavior->notEmpty())",1.2,,
Properties to which ClassifierBehaviorProperty is applied shall be composite,self.base_Property.isComposite,1.2,,
"Properties to which ClassifierBehaviorProperty applied shall be typed by the classifier behavior of their owning
block or a generalization of the classifier behavior.","let clBehavior: UML::Behavior =
self.base_Property.owner.oclAsType(UML::Class).classifierBehavior in
self.base_Property.type->notEmpty() and clBehavior->closure(general)
->including(clBehavior)->includes(self.base_Property.type)",1.2,,
ConnectorProperty shall only be applied to properties of classes stereotyped by Block,"Block.allInstances().base_Class->exists(c | c.ownedAttribute
->includes(self.base_Property))",1.2,,
"The connector attribute of the applied stereotype shall refer to a connector owned or inherited by a block owning
the property on which the stereotype is applied.","let owner: UML::Class = Block.allInstances().base_Class->any(c | c.ownedAttribute
->includes(self.base_Property)) in owner->closure(general)
->select(oclIsKindOf(UML::Class)).oclAsType(UML::Class).ownedConnector->flatten()
->includes(self.connector)",1.2,,
The type of the connector referred to by a connector attribute shall be an association class stereotyped by Block.,"Block.allInstances().base_Class->exists(c | c.oclIsKindOf(UML::AssociationClass) and
self.connector.type = c)",1.2,,
"A property stereotyped by ConnectorProperty shall have the same name and type as the connector referred to by
the connector attribute.",self.base_Property.name = self.connector.name,1.2,,
"sourceContext shall have a value when source is a property, otherwise it shall not have a value",self.base_DirectedRelationship.source->exists(s | s.oclIsKindOf(UML::Property)) xor self.sourceContext->isEmpty(),1.2,,
"targetContext shall have a value when target is a property, otherwise it shall not have a value","self.base_DirectedRelationship.source->exists(s | s.oclIsKindOf(UML::Property)) xor
self.sourceContext->isEmpty()",1.2,,
source shall be a property when sourcePropertyPath has a value.,"self.sourcePropertyPath->notEmpty() implies self.base_DirectedRelationship.source
->forAll(s | s.oclIsKindOf(UML::Property)) ",1.2,,
target shall be a property when targetPropertyPath has a value.,"self.targetPropertyPath->notEmpty() implies self.base_DirectedRelationship.target
->forAll(s | s.oclIsKindOf(UML::Property))",1.2,,
"The property in the first position of the sourcePropertyPath list, if any, shall be owned by the sourceContext or
one of its generalizations","self.sourcePropertyPath->notEmpty() implies self.sourceContext.allAttributes()
->includes(self.sourcePropertyPath->first())",1.2,,
"The property in the first position of the targetPropertyPath list, if any, shall be owned by the targetContext or
one of its generalizations.","self.targetPropertyPath->notEmpty() implies self.targetContext.allAttributes()
->includes(self.targetPropertyPath->first())",1.2,,
"The property at each successive position of the sourcePropertyPath and targetPropertyPath, following the first
position, shall be owned by the Block or ValueType that types the property at the immediately preceding
position, or a generalization of the Block or ValueType.","(self.sourcePropertyPath->size() >1 implies self.sourcePropertyPath->subSequence(2,
self.sourcePropertyPath->size())->forAll(p | let pp: UML::Property =
self.sourcePropertyPath->at(self.sourcePropertyPath->indexOf(p)-1) in let owners:
Set(UML::Classifier) = pp.type.oclAsType(UML::Classifier)
->including(pp.type.oclAsType(UML::Classifier)) in owners->includes(p.owner))) and (self.targetPropertyPath->size() >1 implies self.targetPropertyPath->subSequence(2,
self.targetPropertyPath->size())->forAll(p | let pp: UML::Property =
self.targetPropertyPath->at(self.targetPropertyPath->indexOf(p)-1) in let owners:
Set(UML::Classifier) = pp.type.oclAsType(UML::Classifier)
->including(pp.type.oclAsType(UML::Classifier)) in owners->includes(p.owner)))",1.2,,
"The type of the property at the last position of the sourcePropertyPath list shall own or inherit the source of the
stereotyped directed relationship.","self.sourcePropertyPath->notEmpty() implies self.sourcePropertyPath
->last().type.oclAsType(UML::Classifier).allAttributes()
->includesAll(self.base_DirectedRelationship.source)",1.2,,
"The type of the property at the last position of the targetPropertyPath list shall own or inherit the target of the
stereotyped directed relationship.","self.targetPropertyPath->notEmpty() implies self.targetPropertyPath
->last().type.oclAsType(UML::Classifier).allAttributes()
->includesAll(self.base_DirectedRelationship.target)",1.2,,
"The DistributedProperty stereotype shall only be applied to properties of classifiers stereotyped by Block or
ValueType.","Block.allInstances().base_Class.oclAsType(UML::Classifier)
->union(ValueType.allInstances().base_DataType)->includes(self.base_Property.owner)",1.2,,
"The property at each successive position of the propertyPath attribute, following the first position, shall be
owned by the Block or ValueType that types the property at the immediately preceding position, or a
generalization of the Block or ValueType.","self.propertyPath->size() >1 implies self.propertyPath->subSequence(2,
self.propertyPath->size())->forAll(p | let pp: UML::Property = self.propertyPath
->at(self.propertyPath->indexOf(p)-1) in let owners: Set(UML::Classifier) =
pp.type.oclAsType(UML::Classifier)->including(pp.type.oclAsType(UML::Classifier)) in
owners->includes(p.owner))",1.2,,
"Properties to which EndPathMultiplicity is applied shall be related by redefinition to a property to which
BoundReference is applied.","self.base_Property.redefinedProperty->notEmpty() and
BoundReference.allInstances().base_Property->exists(p |
self.base_Property.redefinedProperty->includes(p))",1.2,,
endPathLower shall be non-negative.,self.lower >= 0,1.2,,
"The first property in propertyPath shall be owned by the block that owns the connector, or one of the blocks generalizations."," let owningBlock: UML::Class =
 self.base_ConnectorEnd.owner.oclAsType(UML::Connector).owner.oclAsType(UML::Class)
in (not owningBlock.oclIsUndefined()) and owningBlock->closure(general)
 ->including(owningBlock)->includes(self.propertyPath->first().owner) ",1.2,,
The type of the property at the last position of the propertyPath list shall own or inherit the role property of the stereotyped connector end,"let type: UML::Classifier =
self.propertyPath->last().type.oclAsType(UML::Classifier) in
not type.oclIsUndefined()) andtype.allFeatures()
->includes(self.base_ConnectorEnd.role)",1.2,,
ParticipantProperty shall only be applied to properties of association classes stereotyped by Block.,"self.base_Property.class.oclIsKindOf(UML::AssociationClass) and
 Block.allInstances().base_Class->includes(self.base_Property.class)",1.2,,
ParticipantProperty shall not be applied to properties that are member ends of an association., UML::Association.allInstances().memberEnd->flatten()->excludes(self.base_Property),1.2,,
The aggregation of a property stereotyped by ParticipantProperty shall be none, self.base_Property.aggregation = UML::AggregationKind::none,1.2,,
"The end attribute of the applied stereotype shall refer to a member end of the association block owning the
property on which the stereotype is applied.",self.base_Property.association.memberEnd->includes(self.end),1.2,,
"A property stereotyped by ParticipantProperty shall have the same type as the property referred to by the end
attribute",self.base_Property.type = self.end.type,1.2,,
A property to which the ParticipantProperty is applied shall have a multiplicity of 1.,self.base_Property.lower = 1 and self.base_Property.upper = 1,1.2,,
"A classifier to which the PropertySpecificType stereotype is applied shall be referenced as the type of one and only
one property",UML::Property.allInstances()->select(p | p.type = self.base_Classifier)->size() = 1,1.2,,
Any classifier that specializes a ValueType shall also have the ValueType stereotype applied,"UML::Classifier.allInstances()->forAll(c | c.general->includes(self.base_DataType)
implies ValueType.allInstances().base_DataType->includes(c))",1.2,,
"The unit of a ValueType, if any, shall be an InstanceSpecification classified by SysMLs Unit block in the
UnitAndQuantityKind model library or a specialization of it.","self.unit->notEmpty() and self.unit.classifier->notEmpty() implies
self.unit.classifier->forAll(c |
c.oclIsKindOf(Libraries::UnitAndQuantityKind::Unit))",1.2,,
"The quantityKind of a ValueType, if any, shall be an InstanceSpecification classified by SysMLs QuantityKind
block in the UnitAndQuantityKind model library or a specialization of it.","self.quantityKind->notEmpty() and self.quantityKind.classifier->notEmpty() implies
self.quantityKind.classifier->forAll(c |
c.oclIsKindOf(Libraries::UnitAndQuantityKind::QuantityKind))",1.2,,
"The action has exactly one trigger, the event of which shall be a change structural feature event","self.base_AcceptEventAction.trigger->size()=1 and let trigger: UML::Trigger =
self.base_AcceptEventAction.trigger->any(true) in
ChangeStructuralFeatureEvent.allInstances().base_ChangeEvent->
includes(trigger.event)",1.2,,
"The action has two result pins with type and ordering the same as the type and ordering of the structural feature of the trigger event, and multiplicity compatible with the multiplicity of the structural feature.","let event: ChangeStructuralFeatureEvent =
ChangeStructuralFeatureEvent.allInstances()->any(e | e.base_ChangeEvent =
self.base_AcceptEventAction.trigger->any(true).event) in
self.base_AcceptEventAction.result->size() = 2 and
self.base_AcceptEventAction.result->forAll(r | r.type =
event.structuralFeature.type and r.isOrdered = event.structuralFeature.isOrdered
and r.lower <= event.structuralFeature.lower and r.upper >=
event.structuralFeature.upper) ",1.2,,
"The structural feature of the trigger event shall be owned by or inherited by the context of the behavior
containing the action. (The context of a behavior is either its owning block or itself if it is not owned by a block. ","let event: ChangeStructuralFeatureEvent =
ChangeStructuralFeatureEvent.allInstances()->any(e | e.base_ChangeEvent =
self.base_AcceptEventAction.trigger->any(true).event) in
self.base_AcceptEventAction._'context'->notEmpty() and
self.base_AcceptEventAction._'context'.allFeatures()
->includes(event.structuralFeature)",1.2,,
The structural feature referred by actions with this stereotype applied must have FlowProperty applied,"FlowProperty.allInstances().base_Property
->includes(self.base_AddStructuralFeatureValueAction.structuralFeature)",1.2,,
"The port at the first position in the onNestedPort list shall be owned by the block that types the object pin of the
stereotyped action, or one of that blocks generalizations.","self.base_AddStructuralFeatureValueAction.object.type.oclAsType(UML::Classifier) -
>allFeatures()->includes(self.onNestedPort->first()))",1.2,,
"The port at each successive position of the onNestedPort attribute, following the first position, shall be owned
by the Block that types the port at the immediately preceding position, or a generalization of that Block","self.onNestedPort->size() >1 implies self.propertyPath->subSequence(2, self.onNestedPort->size())->forAll(p | let pp: UML::Property = self.onNestedPort->at(self.onNestedPort->indexOf(p)-1) in let owners: Set(UML::Classifier) = pp.type.oclAsType(UML::Classifier) ->including(pp.type.oclAsType(UML::Classifier)) in owners->includes(p.owner))",1.2,,
"The type of the port at the last position of the onNestedPort list shall own or inherit the flow property that is the
structural feature of the stereotyped action","self.onNestedPort->last().type.oclAsType(UML::Classifier).allFeatures()
->includes(self.base_AddStructuralFeatureValueAction.structuralFeature)",1.2,,
The structural feature shall not be static,not self.structuralFeature.isStatic,1.2,,
The structural feature shall have exactly one featuringClassifier,self.structuralFeature.featuringClassifier->size()=1,1.2,,
"DirectedFeature shall only be applied to behavioral features, or to properties that do not have FlowProperty applied, including on subsetted or redefined features.",self.base_Feature.oclIsKindOf(UML::BehavioralFeature) or (self.base_Feature.oclIsKindOf(UML::Property) and let property: UML::Property = self.base_Feature.oclAsType(UML::Property) in FlowProperty.allInstances().base_Property->excludesAll(property.redefinedProperty ->union(property.subsettedProperty)->including(property))),1.2,,
A non-provided operation shall not be associated with a behavior as its method.,"self.base_Feature.oclIsKindOf(UML::Operation) and
 self.featureDirection=FeatureDirectionKind::required implies
 self.base_Feature.oclAsType(UML::Operation).method->isEmpty()",1.2,,
Any classifier that specializes a ConstraintBlock shall also have the ConstraintBlock stereotype applied.,"UML::Classifier.allInstances()->forAll(c | c.general->includes(self.base_Class)
implies ConstraintBlock.allInstances().base_Class->includes(c))",1.2,,
"A FlowProperty shall be typed by a ValueType, Block, or Signal"," Block.allInstances().base_Class->includes(self.base_Property.type) or
 ValueType.allInstances().base_DataType->includes(self.base_Property.type) or
 self.base_Property.oclIsKindOf(UML::Signal)",1.2,,
"Full ports shall not also be proxy ports. This applies even if some of the stereotypes are on subsetted or
redefined ports.",ProxyPort.allInstances()->excludes(self.base_Port),1.2,,
"Binding connectors shall not link full ports (either directly or indirectly through other binding connectors) to other composite properties of the block owning the full port (or that blocks generalizations or specializations), unless the composite properties are non-full ports.","let fullPorts: Set(UML::Port) = FullPort.allInstances().base_Port->asSet() in
BindingConnector.allInstances().base_Connector->select(c | c.end.role
->includes(self.base_Port))->forAll(c | fullPorts->excludesAll(c.end.role->reject
(r | r=self.base_Port)))",1.2,,
Full ports shall not be behavioral (isBehavior=false).,not self.base_Port.isBehavior,1.2,,
"Interface blocks shall not own or inherit behaviors, have classifier behaviors, or methods for their behavioral features.","self.base_Class.inheritedMember->select(m | m.oclIsKindOf(UML::Behavior))
->isEmpty() and self.base_Class.operation.method->flatten()->isEmpty()",1.2,,
"Interface blocks composite properties are either ports, value properties or flow properties.","self.base_Class.ownedAttribute->select(a|a.isComposite)->forAll(a |
a.oclIsKindOf(UML::Port) or a.oclIsKindOf(ValueType))",1.2,,
Ports owned by interface blocks shall only be typed by interface blocks,"self.base_Class.ownedPort->forAll(p|InterfaceBlock.allInstances().base_Class
->includes(p.type))",1.2,,
Any port typed by an InterfaceBlock shall have its isConjugated property set to false,"Port.allInstances()->forAll(p | p.type = self.base_Class implies
p.isConjugated=false)",1.2,,
The onPort property of an invocation action shall have a value when this stereotype is applied.,self.base_InvocationAction.onPort->notEmpty(),1.2,,
"The port at each successive position of the onNestedPort attribute, following the first position, shall be owned
by the Block that types the port at the immediately preceding position, or a generalization of that Block.","self.onNestedPort->size() >1 implies self.propertyPath->subSequence(2,
 self.onNestedPort->size())->forAll(p |
 let pp: UML::Property = self.onNestedPort->at(self.onNestedPort->indexOf(p)-1) in
 let owners: Set(UML::Classifier) = pp.type.oclAsType(UML::Classifier) ->including(pp.type.oclAsType(UML::Classifier)) in
 owners->includes(p.owner))",1.2,,
"The type of the port at the last position of the onNestedPort list shall own or inherit the onPort port of the
stereotyped invocation action","self.onNestedPort->last().type.oclAsType(UML::Classifier).allFeatures()
->includes(self.base_InvocationAction.onPort)",1.2,,
itemProperty shall not have a value if the item flow is realized by an Association,"self.base_InformationFlow.realization->exists(r | r.oclIsKindOf(UML::Association))
implies self.itemProperty->isEmpty()",1.2,,
"If an ItemFlow has an itemProperty, one of the classifiers of conveyed items shall be the same as the type of the
item property","self.itemProperty->notEmpty() implies self.base_InformationFlow.conveyed
->includes(self.itemProperty.type)",1.2,,
"If an ItemFlow has an itemProperty, its name shall be the same as the name of the item flow","self.itemProperty->notEmpty() implies self.itemProperty.name =
self.base_InformationFlow.name",1.2,,
"Proxy ports shall not also be full ports. This applies even if some of the stereotypes are on subsetted or redefined
ports",FullPort.allInstances()->excludes(self.base_Port),1.2,,
Proxy ports shall only be typed by interface blocks.,InterfaceBlock.allInstances().base_Class->includes(self.base_Port.type),1.2,,
Ports owned by the type of a proxy port shall be proxy ports,ProxyPort.allInstances().base_Port->includesAll(self.base_Port.class.ownedPort),1.2,,
"The port property of the stereotyped trigger shall have exactly one value, and the value cannot be a full port","self.base_Trigger.port->size()=1 and FullPort.allInstances().base_Port
->excludes(self.base_Trigger.port)",1.2,,
The values of the onNestedPort property shall not be full ports.,FullPort.allInstances().base_Port->excludesAll(self.onNestedPort),1.2,,
"The type of the port at the last position of the onNestedPort list must own or inherit the port of the stereotyped
trigger.","self.onNestedPort->last().type.oclAsType(UML::Classifier).allFeatures()
->includes(self.base_Trigger.port)",1.2,,
Any property of a block that is typed by a ConstraintBlock shall have composite aggregation,self.base_Class.ownedAttribute->forAll(p| p.isComposite),1.2,,
"When the «controlOperator» stereotype is applied, the behavior or operation shall have at least one parameter
typed by ControlValue. If the stereotype is not applied, the behavior or operation may not have any parameter
typed by ControlValue.","UML::Behavior.allInstances()->forAll(b | not
(ControlOperator.allInstances().base_Behavior->includes(b) xor b.ownedParameter
->exists(p | p.type=SysML::Libraries::ControlValues::ControlValue))) and
UML::Operation.allInstances()->forAll(o | not
(ControlOperator.allInstances().base_Operation->includes(o) xor o.ownedParameter
->exists(p | p.type=SysML::Libraries::ControlValues::ControlValue)))",1.2,,
"A behavior shall have the «controlOperator» stereotype applied if it is a method of an operation that has the
«controlOperator» stereotype applied.","(self.base_Operation->notEmpty() and self.base_Operation.method->notEmpty()) implies
self.base_Operation.method->forAll(b | ControlOperator.allInstances().base_Behavior
->includes(b))",1.2,,
The «nobuffer» and «overwrite» stereotypes cannot be applied to the same element at the same time,Overwrite.allInstances().base_ObjectNode->excludes(self.base_ObjectNode),1.2,,
"A parameter with the «optional» stereotypes applied shall have multiplicity.lower equal to zero, otherwise
multiplicity.lower shall be greater than zero","UML::Parameter.allInstances()->forAll(p | Optional.allInstances().base_Parameter
->includes(p) xor p.lower > 0)",1.2,,
"The «probability» stereotype shall only be applied to activity edges that have decision nodes or object nodes as
sources, or to output parameter sets.","(self.base_ActivityEdge->notEmpty() implies
self.base_ActivityEdge.source.oclIsKindOf(UML::DecisionNode)) and
(self.base_ParameterSet->notEmpty() implies self.base_ParameterSet.parameter
->forAll(p | p.direction=UML::ParameterDirectionKind::out)) ",1.2,,
"When the «probability» stereotype is applied to an activity edge, then it shall be applied to all edges coming out
of the same source.","self.base_ActivityEdge->notEmpty() implies
Probability.allInstances().base_ActivityEdge
->includesAll(self.base_ActivityEdge.target.incoming)",1.2,,
"When the «probability» stereotype is applied to an output parameter set, it shall be applied to all the parameter
sets of the behavior or operation owning the original parameter set.","self.base_ParameterSet->notEmpty() implies
Probability.allInstances().base_ParameterSet
->includesAll(self.base_ParameterSet.namespace.ownedMember->select(m |
m.oclIsKindOf(UML::ParameterSet))) ",1.2,,
"When the «rate» stereotype is applied to a parameter, the parameter shall be streaming.",self.base_Parameter->notEmpty() implies self.base_Parameter.isStream,1.2,,
A single «allocate» dependency shall have only one client (from) and one supplier (to).,self.base_Abstraction.source->size() = 1 and self.base_Abstraction.target->size() = 1,1.2,,
"An Action appearing in an ""AllocateActivityPartition"" shall be the /client (from) end of an ""allocate""
dependency. The element that represents the ""AllocateActivityPartition"" shall be the /supplier (to) end of the
same ""allocate"" dependency. In the «AllocateActivityPartition» name field, Properties are designated by the use
of a fully qualified name (including colon, e.g., ""part_name:Block_Name""), and Classifiers are designated by a
simple name (no colons, e.g., ""Block_Name"").","self.base_ActivityPartition.node->select(n|n.oclIsKindOf(UML::Action)) ->forAll(a |
let allocs: Set(UML::Abstraction) = Allocate.allInstances().base_Abstraction
->select(x |x.client->includes(a))->asSet() in allocs->exists(x | x.supplier
->includes(self.base_ActivityPartition.represents)))",1.2,,
"A Copy dependency may only be created between two NamedElements that have a subtype of the
abstractRequirement stereotype applied","AbstractRequirement.allInstances().base_NamedElement
->includesAll(self.base_Abstraction.client) and
AbstractRequirement.allInstances().base_NamedElement
->includesAll(self.base_Abstraction.supplier)",1.2,,
The supplier shall be an element stereotyped by a subtype of AbstractRequirement,"AbstractRequirement.allInstances().base_NamedElement
->includesAll(self.base_Abstraction.client)",1.2,,
The client shall be an element stereotyped by a subtype of AbstractRequirement.,"AbstractRequirement.allInstances().base_NamedElement
->includesAll(self.base_Abstraction.supplier)",1.2,,
"Abstractions with a Refine stereotype or one of its specializations applied shall have exactly one client and one
supplier",self.base_Abstraction.client->size()=1 and self.base_Abstraction.supplier->size()=1,1.2,,
"The property ""ownedOperation"" shall be empty",self.base_Class.ownedOperation->isEmpty(),1.2,,
"The property ""ownedAttribute"" shall be empty",self.base_Class.ownedAttribute->isEmpty(),1.2,,
Classes stereotyped by «requirement» shall not participate in associations.,UML::Association.allInstances().memberEnd->flatten().type->excludes(self.base_Class),1.2,,
Classes stereotyped by «requirement» shall not participate in generalizations,UML::Classifier.allInstances().general->flatten()->excludes(self.base_Class),1.2,,
"A nested classifier of a class stereotyped by Requirement or one of its specializations shall also be stereotyped
by Requirement or one of its specializations","self.base_Class.nestedClassifier->forAll(c | Requirement.allInstances().base_Class
->includes(c))",1.2,,
Classes stereotyped by «requirement» shall not be used to type any other model element.,UML::TypedElement.allInstances().type->excludes(self.base_Class),1.2,,
"The type of return parameter of the stereotyped model element shall be VerdictKind. (note this is consistent with
the UML Testing Profile).","(self.base_Behavior->notEmpty() implies self.base_Behavior.ownedParameter->exists(p |
p.direction=UML::ParameterDirectionKind::return and p.type = VerdictKind )) and (self.base_Operation->notEmpty() implies self.base_Operation.ownedParameter->exists(p
| p.direction=UML::ParameterDirectionKind::return and p.type = VerdictKind )) ",1.2,,
The supplier shall be an element stereotyped by any subtype of «AbstractRequirement»,"AbstractRequirement.allInstances().base_NamedElement
->includes(self.base_Abstraction.supplier)",1.2,,
A Constraint must be owned as a guard by a Transition and its constrainedElements must be empty.,"self.owner.oclIsKindOf(UML::StateMachines::Transition) and
self.constrainedElement->isEmpty()",1.3,,
The OpaqueExpression must have a behavior.,self.behavior <> null,1.3,,
The Expression must have no operands and its symbol must be “else”.,self.symbol = 'else' and self.operand->isEmpty(),1.3,,
"If an Operation is abstract, it must have no method. Otherwise it must not have more than one method and it must have 
exactly one method unless owned by an active Class.","if self.isAbstract then self.method->isEmpty()
else
self.method->size() <= 1 and
((self.class = null or not self.class.isActive) implies
self.method->size() = 1)
endif",1.3,,
"A StateMachine may not be a method and, if it has a context, it must be a classifierBehavior for that context.","self.specification = null and
self._'context' <> null implies self._'context'.classifierBehavior = self",1.3,,
The triggers of a Transition must all be for CallEvents or SignalEvents.,"self.trigger.event->forAll(
oclIsKindOf(UML::CommonBehavior::CallEvent) or
oclIsKindOf(UML::CommonBehavior::SignalEvent)
)",1.3,,
"The Operations of any CallEvents on the triggers of a Transition must be owned or inherited by the context of the 
containing StateMachine.","let stateMachine = self.containingStateMachine() in
let context_ =
if stateMachine._'context' = null then stateMachine
else stateMachine._'context'
endif in
context_.allFeatures()->includesAll(
self.trigger->select(oclIsKindOf(UML::CommonBehavior::CallEvent)).
oclAsType(UML::CommonBehavior::CallEvent).operation
)",1.3,,
"The Signals of any SignalEvents on the triggers of a Transition must have matching Receptions that are owned or 
inherited by the context of the containing StateMachine of the Transition.","let stateMachine = self.containingStateMachine() in
let context_ =
if stateMachine._'context' = null then stateMachine
else stateMachine._'context'
endif in
context_.allFeatures()->select(oclIsKindOf(UML::SimpleClassifiers::Reception)).
oclAsType(UML::SimpleClassifiers::Reception).signal->includesAll(
self.trigger->select(oclIsKindOf(UML::CommonBehavior::SignalEvent)).
oclAsType(UML::CommonBehavior::SignalEvent).signal
)",1.3,,
A State must not have a submachine.,not self.isSubmachineState,1.3,,
A State must not have a stateInvariant.,self.stateInvariant = null,1.3,,
A doActivity Behavior of a State can only have in parameters.,"self.doActivity <> null implies
self.doActivity.ownedParameter->forAll(direction =
ParameterDirectionKind::_'in')",1.3,,
A StateMachine must not have more than one extendedStateMachine,self.extendedStateMachine->size() <= 1,1.3,,
"A signature (set of Parameters) conforms to a collection of Triggers if one of the following is true: the signature is empty;
all the Triggers are for SignalEvents and the signature has exactly one Parameter of direction in, has multiplicity upper 
bound of 1 and is either untyped or has a type that is a Signal that conforms to all the Signals of the Triggers; or all 
theTriggers are for CallEvents and the signature conforms to or input-conforms to all the signatures of the Operations of 
the CallEvents. (A signature input-conforms to another if the first signature conforms to the signature containing only the 
in Parameters from the second signature).","conformsToAll(
signature : OrderedSet(UML::Classification::Parameter),
triggers : Collection(UML::CommonBehavior::Trigger)) : Boolean =
signature->isEmpty() or
triggers.event->forAll(oclIsKindOf(UML::CommonBehavior::SignalEvent)) and
signature->size() = 1 and
(let parameter = signature->at(1) in
parameter.direction = UML::Classification::ParameterDirectionKind::_'in'
and
parameter.is(1,1) and
(parameter.type = null or
triggers.event.oclAsType(UML::CommonBehavior::SignalEvent).signal-
>forAll(s |
parameter.type.conformsTo(s)
))) or
triggers.event->forAll(oclIsKindOf(UML::CommmonBehavior::CallEvent)) and
triggers.event.oclAsType(UML::CommmonBehavior::CallEvent).operation->
forAll(operation |
conforms(signature, operation.ownedParameter) or
conforms(signature, operation.ownedParameter->select(
direction = UML::Classification::ParameterDirectionKind::_'in'
)))",1.3,,
"One signature conforms to another if the first signature has the same number of Parameters as the second signature, and 
each Parameter of the first signature has the same direction, ordering and uniqueness as the corresponding Parameter (in 
order) from the second signature and a type and multiplicity that are compatible with those of the corresponding 
Parameter (depending on the Parameter direction).","conforms(
signature1 : OrderedSet(UML::Classification::Parameter),
signature2 : OrderedSet(UML::Classification::Parameter)) : Boolean =
signature1->size() = signature2->size() and
Sequence{1..signature1->size()} -> forAll(i |
let parameter1 = signature1->at(i) in
let parameter2 = signature2->at(i) in
parameter1.direction = parameter2.direction and
parameter1.isOrdered = parameter2.isOrdered and
parameter1.isUnique = parameter2.isUnique and
(parameter2.direction = UML::Classification::ParameterDirectionKind::_'in'
implies
 parameter2.type = null or
 parameter2.type <> null and
 parameter2.type.conformsTo(parameter1.type) and
 parameter2.compatibleWith(parameter1)) and
(parameter1.direction = UML::Classification::ParameterDirectionKind::out or
parameter1.direction = UML::Classification::ParameterDirectionKind::return
implies
 parameter1.type = null or
 parameter1.type <> null and
parameter1.type.conformsTo(parameter2.type) and
parameter1.compatibleWith(parameter2)) and
(parameter1.direction = UML::Classification::ParameterDirectionKind::inout
implies
 parameter1.type = parameter2.type and
 parameter2.compatibleWith(parameter1) and
 parameter1.compatibleWith(parameter2))
)",1.3,,
"The supplier AML Primitive Type must be an AML Primitive Type defined in the UML Primitive Type or XML
Primitive Type libraries.","self.base_Abstraction.supplier->exists(s|s.oclIsKindOf(PrimitiveType) and
((s.namespace.name='XMLPrimitiveTypes') or
(s.namespace.name='PrimitiveTypes')))",1.4,,
The supplier (target) of an «about» Abstraction must be a «ConceptReference».,"self.base_Abstraction.supplier->
select(c|c.stereotypedBy('ConceptReference'))->size()=1",1.4,,
The name of the base_EnumerationLiteral must be defined.,"not(self.base_EnumerationLiteral.name.oclIsUndefined())
and(self.base_EnumerationLiteral.name<>'')",1.4,,
The owning enumeration must be stereotyped with ScopedIdentifier.,self.base_EnumerationLiteral.namespace.stereotypedBy('ScopedIdentifier'),1.4,,
"definingCodeSystem, if present, must reference an enumeration literal stereotyped by CodeSystemReference or CodeSystemVersionReference.","not(self.definingCodeSystem.oclIsUndefined()) implies
self.definingCodeSystem.stereotypedBy('CodeSystemReference') or
self.definingCodeSystem.stereotypedBy('CodeSystemVersionReference') ) ",1.4,,
All of the member EnumerationLiterals must be stereotyped by ConceptReference.,"self.base_Enumeration.ownedLiteral->
forAll(ol|ol.stereotypedBy('ConceptReference'))",1.4,,
"The valueSetBinding tag value, if present, must reference an EnumerationLiteral that is stereotyped by
ValueSetReference or ValueSetDefinitionReference.","not(self.valueSetBinding.oclIsUndefined()) implies
( self.valueSetBinding.stereotypedBy('ValueSetReference') or
self.valueSetBinding.stereotypedBy('ValueSetDefinitionReference') )",1.4,,
All ownedLiterals must be stereotyped by PermissibleValue,"self.base_Enumeration.ownedLiteral->forAll(x:EnumerationLiteral|
x.stereotypedBy('PermissibleValue')",1.4,,
Every id must belong to a unique Enumeration. An identified Item cannot have two or more identifiers drawn from the same Enumeration.,"self.id->forAll(l1 | self.id->forAll(l2 |
l1.oclAsType(EnumerationLiteral).namespace =
l2.oclAsType(EnumerationLiteral).namespace implies l1 = l2))",1.4,,
Every term definition must have a description.,"self.base_EnumerationLiteral.ownedComment._'body'->
exists(b|not(b.oclIsUndefined()))",1.4,,
"Meaning, if present, must reference an EnumerationLiteral that is stereotyped by ConceptReference.","not(self.meaning.oclIsUndefined()) implies
self.meaning.stereotypedBy('ConceptReference')",1.4,,
All of the ownedLiterals must be stereotyped by Entry.,self.base_Enumeration.ownedLiteral->forAll(ol|ol.stereotypedBy('Entry')) ,1.4,,
Each member of valueSetDefinition must be a «ValueSetDefinitionReference» EnumerationLiteral,"self.valueSetDefinition->
forAll(d|d.stereotypedBy('ValueSetDefinitionReference'))",1.4,,
Every Archetype Package must be owned by a Package with an ArchetypeLibrary stereotype,self.base_Package.owningPackage.stereotypedBy('ArchetypeLibrary') ,1.4,,
Types (other than Associations) owned by an Archetype Package must be ObjectConstraints.,"self.base_Package.ownedType->select(x|x.oclIsKindOf(Classifier) and
not(x.oclIsKindOf(Association)))->
forAll(x|x.stereotypedBy('ObjectConstraint')",1.4,,
"If an Archetype specializes another Archetype, the ArchetypeDefinition supplier of both Archetypes must be the same.
In other words, both Archetypes must constrain the same “root class” in the reference model.","self.base_Package.packageImport.importedPackage ->
select(p|p.stereotypedBy('Archetype')).clientDependency ->
select(t|t.stereotypedBy('ArchetypeDefinition')).supplier.
oclAsType(Classifier).general ->forAll(x|self.base_Package.clientDependency->
select(t|t.stereotypedBy('ArchetypeDefinition')).supplier.
oclAsType(Classifier).general->includes(x))",1.4,,
"The [AOM] invariant requires the concept_code to exist in the terminology definition. In AML, the concept_code is
the language-specific text for the top-level Archetype definition Classifier. Thus in AML, this [AOM] invariant maps
to the requirement that the Archetype definition Classifier must have an «Archetype» id tag whose value is an
«ArchetypeTerm» within an Identifier Definition. Note that this Constraint ends up the same as [AOM]
ARCHETYPE_TERMINOLOGY:Invariant:concept_code_validity. ","self.base_Package.clientDependency ->
select(d|d.stereotypedBy('ArchetypeDefinition')).supplier ->
exists(s|s.appliedStereotypeInstance.oclAsType(ComplexObjectConstraint).id ->
notEmpty())",1.4,,
"Every Archetype Package must have exactly one clientDependency that is an ArchetypeDefinition and whose supplier
is a ComplexObjectConstraint within the same Archetype Package. ","self.base_Package.clientDependency ->
exists(d|d.stereotypedBy('ArchetypeDefinition') )",1.4,,
"The Archetype must have a valid original language. In AML, the original language is identified as a Usage from the
Archetype to a Resource Translation. ","self.base_Package.clientDependency -> select(d|d.oclIsKindOf(Usage) and
(d.name='original_language')).supplier ->
select(e|e.stereotypedBy('ResourceTranslation')) ->size()=1 ",1.4,,
"A terminology definition must exist for an Archetype. This [AOM] Invariant maps to the AML Constraint that an
Archetype must have one or more Resource Transformations. ","self.base_Package.nestedPackage.nestedPackage.ownedType->
exists(o|o.stereotypedBy('ResourceTranslation'))",1.4,,
"The [AOM] ARCHETYPE_HRIN/concept_id must have a value. [AOM] ARCHETYPE_HRIN/concept_id maps to
the name of the «Archetype» Package. ",not(self.base_Package.name.oclIsUndefined()) and (self.base_Package.name<>''),1.4,,
"The [AOM] ARCHETYPE/concept_code must be represented in the terminology definition. The [AOM]
ARCHETYPE/concept_code is mapped to the AML language-specific text for the top-level Archetype definition
Classifier. Thus in AML, this [AOM] invariant maps to the requirement that the Archetype definition Classifier must
have an «IdentifiedItem» id tag whose value is a «ArchetypeTerm» within an Identifier Definition.","self.base_Package.clientDependency ->
select(d|d.stereotypedBy('ArchetypeDefinition')).supplier->
exists(s|s.appliedStereotypeInstance.oclAsType(ComplexObjectConstraint).id->
notEmpty()) ",1.4,,
"There must exist an original language for the [AOM] ARCHETYPE_TERMINOLOGY. This [AOM] invariant maps to
the requirement that an AML Archetype Package must have exactly one Usage association named
""terminology_original_language"" whose supplier is a ResourceTranslation.","self.base_Package.clientDependency->select(d|d.oclIsKindOf(Usage) and
(d.name='terminology_original_language')).supplier ->
select(e|e.stereotypedBy('ResourceTranslation')) -> size()=1",1.4,,
"The [AOM] ARCHETYPE/terminology is required. The [AOM] ARCHETYPE/terminology maps to a nested Package
of the «Archetype» Package named “ontology.” ",self.base_Package.nestedPackage->exists(p|p.name='ontology'),1.4,,
"The [AOM] ARCHETYPE_TERMINOLOGY/term_definitions maps to a set of AML «ResourceTranslation»s, one per
language. There must be one or more «ResourceTranslation»s for an Archetype. ","self.base_Package.clientDependency->select(d|d.oclIsKindOf(Usage) and
(d.name='original_language')).supplier ->
exists(e|e.stereotypedBy('ResourceTranslation'))",1.4,,
"For an ArchetypeType of 'archetype' or 'template,' a description section containing the main meta-data of the archetype
must exist. ","(self.archetypeType.repr()<>'template_overlay') implies
self.base_Package.clientDependency.supplier->
select(d|d.stereotypedBy('ResourceTranslation'))->notEmpty() ",1.4,,
"An [AOM] VARIABLE_DECLARATION/name maps to a UML InstanceSpecification/name owned by an
«Archetype» Package. The name must be defined and not empty.","self.namespace.stereotypedBy('Namespace')implies(
not( self.name.oclIsUndefined()) and(self.name<>'') )",1.4,,
There must be exactly one packageImport of a Package stereotyped as a ReferenceModel.,"self.base_Package.packageImport.importedPackage->
select(stereotypedBy('ReferenceModel'))->size() = 1",1.4,,
All packaged elements must be Archetypes.,self.base_Package.packagedElement->forAll(p|p.stereotypedBy('Archetype')),1.4,,
The «Archetype» Classifier must specialize an «ObjectConstraint» Classifier that is the root of an Archetype definition.,"self.base_Classifier.general.supplierDependency.client->
exists(g|g.stereotypedBy('Archetype')) ",1.4,,
"If this Archetype root is a redefinition of another external node, then that external node must have as an ancestor the
Archetype definition which is the parent of this Archetype.","self.base_Classifier.general->forAll(g|g.stereotypedBy('ArchetypeRoot'))
implies self.base_Classifier.general.general ->
forAll(g|g.namespace=self.base_Classifier.namespace.oclAsType(Package).
packageImport.importedPackage->select(p|p.stereotypedBy('Archetype'))->
asSequence()->first())",1.4,,
"An external reference node defined as a filler for a slot in the parent archetype must have a node id that is a
specialization of that of the slot.
Note that mapping to [AOM] may coerce the value of C_ARCHETYPE_ROOT/node_id to a value in conformance
with this [AOM] Validation Rule.","self.base_Classifier.general->forAll(g|g.stereotypedBy('ArchetypeRoot')or
g.stereotypedBy('ArchetypeSlot')) implies
self.id.oclAsType(EnumerationLiteral) ->forAll(e|e.name.startsWith (
self.base_Classifier.general.appliedStereotype('ObjectConstraint').oclAsType(
ObjectConstraint).id.oclAsType(EnumerationLiteral).name->asSequence()->
first())) ",1.4,,
"If the reference object is a redefinition of either a slot node, or another external reference node, the node_id of the
object must conform to (i.e., be the same or a child of) the node_id of the corresponding parent node.
Note that the AML-UML transformation to [AOM] may coerce the node_id of provisioned C_ARCHETYPE_ROOT to
a value in conformance with the [AOM] Validation Rule.","self.base_Classifier.general->forAll(g|g.stereotypedBy('ArchetypeRoot')or
g.stereotypedBy('ArchetypeSlot')) implies
self.id.oclAsType(EnumerationLiteral) ->
forAll(e|e.name.startsWith(self.base_Classifier.general.appliedStereotype
Instance.oclAsType(ObjectConstraint).id.oclAsType(EnumerationLiteral).name->
asSequence()->first()))",1.4,,
"In the specialization of an archetype slot, either the slot can be specified to be closed (is_closed = True) or the slot can
be narrowed, but not both.","self.base_Classifier.general->forAll(g|g.stereotypedBy('ARCHETYPE_ROOT'))
implies (self.base_Classifier.ownedRule->
isEmpty()=self.base_Classifier.isLeaf)",1.4,,
All owned attributes are attribute constraints. Each must subset or redefine a reference model property. ,self.namespace.stereotypedBy('ComplexObjectConstraint') implies ((self.subsettedProperty->notEmpty()) or( self.redefinedProperty->notEmpty())),1.4,,
Every constraint must specialize exactly one Class.,self.base_Classifier.generalization->size() = 1,1.4,,
"If the upper multiplicity of this Property is bounded, then the sum of the multiplicity lower bounds of children is less
than or equal to the upper multiplicity of the constrained Property.","self->select(s|s.namespace.stereotypedBy('ComplexObjectConstraint'))
.subsettedProperty->union(self.redefinedProperty) ->select(r|r.upper>0) ->
forAll(refProperty| self.namespace.oclAsType(Class).ownedAttribute->
select(sibling|sibling.subsettedProperty->
union(sibling.redefinedProperty)->includes(refProperty)) .lower->
sum()<=refProperty.upper ) ",1.4,,
"If this is a Property with a bounded upper limit, then the minimum number of possible children must be less than or
equal to the upper value of the constrained Property.","self->select(s|s.namespace.stereotypedBy('ComplexObjectConstraint'))
.subsettedProperty->union(self.redefinedProperty) ->select(r|r.upper>0) ->
forAll(refProperty| self.namespace.oclAsType(Class).ownedAttribute->
select(sibling|sibling.subsettedProperty->union(sibling.redefinedProperty)->
includes(refProperty)) ->select(p|p.lower>0) ->size()<refProperty.upper )",1.4,,
"An [AOM] C_COMPLEX_OBJECT_PROXY cannot be a proxy for any allowed Reference Model Classifier. This
[AOM] Invariant is mapped to an AML Constraint that a Property of a Complex Object Constraint, whose aggregation
is none, cannot be (directly) typed by a Reference Model Classifier.","((self.aggregation=AggregationKind::none) and
self.namespace.stereotypedBy('ComplexObjectConstraint')) implies
self.type.getNearestReferenceModel().oclIsUndefined() ",1.4,,
"An [AOM] rm_type_name maps to the name of the Reference Model Classifier which is the supertype of an Archetype
Classifier. The Reference Model Classifier must have a non-empty name. ",self.base_Classifier.general->forAll(g|not(g.name.oclIsUndefined()) and (g.name<>'')),1.4,,
"The [AOM] QUERY_VARIABLE maps to a UML InstanceSpecification whose specification is an OpaqueExpression.
The [AOM] QUERY_VARIABLE/context maps to the name of the UML OpaqueExpression. The name of the
OpaqueExpression must be either undefined or non-empty. The [AOM] QUERY_VARIABLE/query_id maps to the
name of the UML InstanceSpecification. ","(self.namespace.stereotypedBy('ComplexObjectConstraint') and
not(self.specification.oclIsUndefined()) and
self.specification.oclIsKindOf(OpaqueExpression) implies
(self.specification.name.oclIsUndefined() or(self.specification.name<>'') ) ",1.4,,
"Each value set code (ac-code) used in a term constraint in the archetype definition must be defined in the
term_definitions part of the terminology of the current archetype. ","(self._'context'.stereotypedBy('ComplexObjectConstraint') and
self.specification.oclIsKindOf(Expression) and
(self.specification.oclAsType(Expression).symbol='=') ) implies
self.specification.oclAsType(Expression).operand->
forAll(o|o.oclIsKindOf(InstanceValue) and
o.oclAsType(InstanceValue).instance.stereotypedBy('ArchetypeTerm') and
o.oclAsType(InstanceValue).instance.getNearestPackage().
nestingPackage.nestingPackage=self.getNearestPackage()",1.4,,
"It must be possible for at least one instance of one optional child object (i.e., an object for which the occurrences lower
bound is 0) and one instance of every mandatory child object (i.e., object constraints for which the occurrences lower
bound is >= 1) to be included within the cardinality range.","self->select(s|s.namespace.stereotypedBy('ComplexObjectConstraint'))
.subsettedProperty->union(self.redefinedProperty) ->select(r|r.upper>0) ->
forAll(refProperty| self.namespace.oclAsType(Class).ownedAttribute->
select(sibling|sibling.subsettedProperty->union(sibling.redefinedProperty)->
includes(refProperty)).lower->sum()<=(refProperty.upper-1) )",1.4,,
"A redefined object node in a specialized archetype with occurrences matching {0} must have exactly the same node id
as the node in the flat parent being redefined.","self.base_Classifier.attribute->select(a|a.upper=0).type ->
forAll(t|t.oclAsType(Classifier).general ->
forAll(g|g.appliedStereotype('ObjectConstraint').
oclAsType(ObjectConstraint).id ->
forAll(e|e=t.appliedStereotype('ObjectConstraint').
oclAsType(ObjectConstraint).id->asSequence()->first())))",1.4,,
"When a cardinality with a finite upper bound is stated on an attribute, for all immediate child objects for which an
occurrences constraint is stated, the sum of occurrences lower bounds should be lower than the cardinality upper limit","self->select(s|s.namespace.stereotypedBy('ComplexObjectConstraint')) .
subsettedProperty->union(self.redefinedProperty) ->select(r|r.upper>0) ->
forAll(refProperty|self.namespace.oclAsType(Class).ownedAttribute->
select(sibling|sibling.subsettedProperty->union(sibling.redefinedProperty)->
includes(refProperty)).lower->sum()<=refProperty.upper )",1.4,,
The specific property must reference an ObjectConstraint. ,self.base_Generalization.specific.stereotypedBy('ObjectConstraint'),1.4,,
"This Classifier must have exactly one generalization, and that is a «Constraint» Generalization.","self.base_NamedElement.oclIsKindOf(Classifier) implies
(self.base_NamedElement.oclAsType(Classifier).generalization->
forAll(x|x.stereotypedBy('Constrains')) and
(self.base_NamedElement.oclAsType(Classifier).generalization->size() = 1))",1.4,,
This Property must redefine or subset a Reference Model Property.,"self.base_NamedElement.oclIsKindOf(Property) implies
self.base_NamedElement.oclAsType(Property)->forAll(p|p.redefinedProperty->
notEmpty() or p.subsettedProperty->notEmpty()) ",1.4,,
"The occurrences of a new (i.e., having no corresponding node in the parent Archetype) object constraint node in a
specialized archetype, if stated, may not be ‘prohibited’, i.e., have an upper bound of {0}, since prohibition only makes
sense for an existing node.","self.namespace->select(n|n.stereotypedBy('ComplexObjectConstraint')
).oclAsType(Classifier).general->
select(g|g.stereotypedBy('ComplexObjectConstraint'))->isEmpty() implies
(self.upper<>0)",1.4,,
Each resource annotation must annotate a reference model or archetype element.,"not(self.base_Comment.annotatedElement->
includes(self.base_Comment.owningElement))",1.4,,
All of the ownedLiterals must be stereotyped by IdEntry,self.base_Enumeration.ownedLiteral->forAll(ol|ol.stereotypedBy('IdEntry')) ,1.4,,
The ref tags of the ownedLiterals must all be unique. No two translation entries may reference the same identifier,"self.base_Enumeration.ownedLiteral->size() =
self.base_Enumeration.ownedLiteral.appliedStereotype('IdEntry').
oclAsType(IdEntry).ref->asSet()->size() ",1.4,,
"Translations must exist for term_definitions and constraint_definitions sections for all languages defined in the
description / translations section. ",self.base_Enumeration.ownedLiteral->notEmpty(),1.4,,
an ExceptionDef m ust be defined in a Container,definedIn .notEmpty,1.5,,
a ValueMemberDef must be defined within a ValueDef,definedIn.oclIsTypeof (ValueDef) ,1.5,,
an OperationDef must be defined within an InterfaceDef or within a ValueDef,definedIn.oclIsKindOf (InterfaceDef) or definedIn.oclIsKindOf (ValueDef) ,1.5,,
an AttributeDef can must be defined within an InterfaceDef or within a ValueDef,definedIn.oclIsKindOf (InterfaceDef) or definedIn.oclIsKindOf (ValueDef),1.5,,
a TypedefDef must be defined in a Container,definedIn.notEmpty,1.5,,
a ValueDef must be defined within a ModuleDef,definedIn.oclIsKindOf (ModuleDef),1.5,,
an InterfaceDef must be defined within a ModuleDef,definedIn.oclIsKindOf (ModuleDef),1.5,,
"if ModuleDef is defined in a Container, this Container must be another ModuleDef ",definedIn.notEmpty implies (defined In.oclIsKindOf (ModuleDef) and definedIn <> self),1.5,,
Abstract InterfaceDefs may only derive from other abstract InterfaceDefs,isAbstract implies base->forAll (isAbstract),1.5,,
Abstract ValueDefs may only derive from other abstract ValueDefs,isAbstract implies base->isEmpty,1.5,,
base (if any) refers to a concrete ValueDef,base->notEmpty implies not base.isAbstract,1.5,,
abstractBase refers only to abstract ValueDefs,abstractBase->forAll(isAbstract),1.5,,
A FacetDef can be defined only within a ComponentDef,definedIn.oclType = ComponentDef,1.5,,
A «CORBAComponent» cannot own operations:,self.feature->forAll(not oclIsKindOf (behavioralFeature)),1.6,,
A «CORBAComponent» can only inherit from a «CORBAComponent» or a «CORBAInterface»:,"self.generalization->forAll (g : Generalization | g.parent.isStereotyped (""CORBAComponent"") or g.parent.isStereotyped(""CORBAInterface""))",1.6,,
Only single inheritance is possible between «CORBAComponent»:,"self.generalization->
select(parent.isStereotyped(""CORBAComponent""))->size <= 1",1.6,,
Each «CORBAComponent» inheritance from a «CORBAInterface» must be stereotyped «CORBASupports»:,"self.generalization->forAll (g : Generalization | g.parent.isStereotyped(""CORBAInterface"") implies g.isStereotyped(""CORBASupports""))",1.6,,
It’s an association between a «CORBAComponent» and a «CORBAInterface»:,"self.connection->exists( participant.isStereotyped(""CORBAComponent"")) and self.connection->exists (participant.isStereotyped(""CORBAInterface""))",1.6,,
The «CORBAComponent» side is a composition:,"self.connection->exists(participant.isStereotyped(""CORBAComponent"") and aggregation = #composite)",1.6,,
It’s an association stereotyped «CORBAProvides»:,"self.isStereotyped(""CORBAProvides”)",1.6,,
The “CORBAInterface” side cardinality must be 1:,"self.connection->exists(participant.isStereotyped(""CORBAInterface"") and multiplicity.min=1 and multiplicity.max=1)",1.6,,
It’s an association stereotyped «CORBAUses»:,"self.isStereotyped(""CORBAUses”)",1.6,,
The «CCMReceptacle» side cardinality must be greater than one for multiple receptacles,"self.connection->exists(participant.isStereotyped(""CORBAInterface"") and multiplicity.min=1 and multiplicity.max>1)",1.6,,
It’s a binary association.,self.connection->size=2,1.6,,
It’s an association between a «CORBAComponent» and a «CORBAEvent»,"self.connection->exists( participant.isStereotyped(""CORBAComponent"")) and self.connection->exists (participant.isStereotyped(""CORBAEvent""))",1.6,,
The «CORBAEvent» side cardinality must be 1.,"self.connection->exists(participant.isStereotyped(""CORBAEvent"") and multiplicity.min=1 and multiplicity.max=1)",1.6,,
The «CORBAEmits» side cardinality must be 1.,"self.connection->exists(participant.isStereotyped(""CORBAEmits"") and multiplicity.min=1 and multiplicity.max=1)",1.6,,
The «CORBAPublishes» side cardinality can be 1 or more,"self.connection->exists(participant.isStereotyped(""CORBAPublishes"") and multiplicity.max>1)",1.6,,
There is exactly one « CORBAManages » association for each Home.,self.connection->select(isStereotyped(“CORBAManages”))->size = 1,1.6,,
The «CORBAHome» side cardinality must be 1..1.,"self.connection->exists(participant.isStereotyped(""CORBAHome"")) and multiplicity.min=1 and multiplicity.max=1)",1.6,,
The «CORBAComponent» side cardinality must be “0..n.”,"self.connection->exists(participant.isStereotyped(""CORBAComponent"")) and multiplicity.min=0 and multiplicity.max=n)",1.6,,
A « CORBAHome » can inherit from one « CORBAHome » at most,"self.generalization->select(parent.isStereotyped(""CORBAHome""))->size=1",1.6,,
"If “CORBAHome” h1 inherits from “CORBAHome” h2 and h2 manages “CORBAComponent” C2 ,then h1 must manage C2 or any other component C1 that inherits from C2.","let h1=self and let h2=self.generalization->select(parent.isStereotyped(""CORBAHome"")) and h2->notEmpty implies let
C2=h2.connection->
select(participant.isStereotyped(""CORBAComponent"")) and let C1=
h1.connection->select(participant.isStereotyped(""CORBAComponent"")) and (C1 = C2 or C1.allParents->includes(C2))",1.6,,
"If « CORBAHome » h1 inherits from h2, and « CORBAHome » h2 is associated with primary key k2, then h1 must be associated with k2 or with a primary key k1 that inherits from k2.","let h1=self and let h2=self.generalization->select(parent.isStereotyped(""CORBAHome"")) and h2->notEmpty implies let
k2=h2.connection
->select(isStereotyped(""CORBAManages"")).LinkToClass.ClassPart and let k1=self.connection
->select(isStereotyped(""CORBAManages"")).LinkToClass.ClassPart and (k1 = k2 or k1.allParents->includes(k2))",1.6,,
Each «CORBAHome» inheritance from a «CORBAInterface» must be stereotyped.,"self.generalization->forAll
(g : Generalization | g.parent.isStereotyped(""CORBAInterface"")
implies g.isStereotyped(""CORBASupports""))",1.6,,
It’s an association between a «CORBAHome» and a «CORBAComponent».,"self.connection->exists(participant.isStereotyped(""CORBAHome"")) and self.connection->exists(participant.isStereotyped(""CORBAComponent""))",1.6,,
A « CORBAHomeFactory » operation has only input parameters. ,self. parameter->forAll(kind=#in),1.6,,
A «CORBAHomeFactory» can only be defined in a “CORBAHome.”,"self.owner.isStereotyped(""CORBAHome"")",1.6,,
A « CORBAHomeFinder » can only be defined in a “CORBAHome.”,"self.owner.isStereotyped(""CORBAHome"")",1.6,,
There is an association between  «CORBAComponentImpl» and  «CORBAComponent».,"self.connection->
exists(participant.isStereotyped(""CORBAComponentImpl"")) and self.connection->exists(participant.isStereotyped(""CORBAComponent""))",1.6,,
"The only classes that are allowed to be contained by a  «CORBAComponentImpl» are classes with the stereotype
 «CORBASegment».","self.connection->
exists(participant.isStereotyped(""CORBAComponentImpl"") and aggregation = #composite and aggregation.participant.isStereotyped(""CORBASegment""))",1.6,,
A  «CORBAComponentImpl» always has exactly one  «CORBAComponent» associated while each  «CORBAComponent» might be implemented by different types of  «CORBAComponentImpl».,"self.connection->
exists(participant.isStereotyped(""CORBAComponentImpl"") and multiplicity.min=1 and max=*)
self.connection->exists(participant.isStereotyped(""CORBAComponent"") and multiplicity.min=1 and max=1)",1.6,,
Each  « CORBAHomeImpl » in a model implements exactly one  «CORBAHome».,"self.connection->exists(participant.isStereotyped(""CORBAHomeImpl"") and multiplicity.min=1 and max=1)
self.connection->exists(participant.isStereotyped(""CORBAHome"") and multiplicity.min=1 and max=1)",1.6,,
 It’s an association between a «CORBAHomeImpl» and a «CORBAComponentImpl»,"self.connection->
exists(participant.isStereotyped(""CORBAHomeImpl"")) and self.connection-> exists(participant.isStereotyped(""CORBAComponentImpl""))",1.6,,
"Each  « CORBAHomeImpl » manages exactly one  «CORBAComponentImpl», this relation is modeled by the
association  «CORBAManages». ","self.connection->
exists(participant.isStereotyped(""CORBAComponentImpl"") and multiplicity.min=1 and max=1)",1.6,,
All model elements representing CORBA Namespaces may not directly contain another element of the same name.,self.ownedElements ->forAll(ownedEl | not ownedEl.name = self.name),1.7,,
"All Attributes of a «CORBAUserDefinedType»-stereotyped Classifier that are
not stereotyped «CORBAConstant» must be of a type that is stereotyped
«CORBAPrimitive», and for which the ownerScope is “instance,” the
targetScope is “instance,” and the changeability is “changeable.”","self.allAttributes
->forAll(attribute | not attribute.isStereotyped(""CORBAConstant"") implies
attribute.type.isStereotyped(""CORBAPrimitive"") and
attribute.ownerScope = #instance and
attribute.targetScope = #instance and
attribute.changeability = #changeable attribute.isStereotyped(""CORBAConstant"") implies attribute.type.isStereotyped(""CORBAPrimitive"") and attribute.ownerScope = #instance and attribute.targetScope = #instance and attribute.changeability = #changeable",1.7,,
"All Associations in which a «CORBAUserDefinedType»-stereotyped Classifier
participates that have navigable opposite AssociationEnds must be binary and
unidirectional.","self.navigableOppositeEnds
->forAll(end | end.association.connection->size = 2 and
end.association.connection
->select(end | end.isNavigable)->size = 1)",1.7,,
"All navigable opposite AssociationEnds of a «CORBAUserDefinedType»-
stereotyped Classifier must have changeability “changeable,” aggregation “none,”
targetScope “instance,” and a type that is stereotyped with a descendant of
«CORBAUserDefinedType» or stereotyped «CORBAPrimitive».","self.navigableOppositeEnds
->forAll (end | end.changeability = #changeable and
end.aggregation = #none and
end.targetScope = #instance and
(end.type.isStereokinded(""CORBAUserDefinedType"") or
end.type.isStereotyped(""CORBAPrimitive"")))",1.7,,
"All non-navigable near AssociationEnds of a «CORBAUserDefinedType»-
stereotyped Classifier must have targetScope “instance.”",self.nonNavigableNearEnds.targetScope = #instance,1.7,,
"All Associations in which a «CORBAUserDefinedType»-stereotyped Classifier
participates that have a navigable opposite AssociationEnd whose type is not a
«CORBAInterface»-stereotyped Classifier must have a near AssociationEnd
with the aggregation “composite.”","self.navigableOppositeEnds
->forAll(opEnd | not opEnd.type.isStereotyped(""CORBAUserDefinedType"")
implies
opEnd.association.connection
->select(end | end <> opEnd).aggregation = #composite)",1.7,,
"A «CORBAUserDefinedType»-stereotyped Classifier cannot participate in any
AssociationClasses.",self.associations->forAll(assoc | not assoc.oclIsTypeOf(AssociationClass)),1.7,,
"A «CORBAModule»-stereotyped package may directly contain only
«CORBAModule»-stereotyped packages or Classes stereotyped as
«CORBAConstants» or as a descendant of «CORBAUserDefinedType».","self.ownedElement->forAll(el | el.isStereotyped(""CORBAModule"") or
el.isStereotyped(""CORBAConstants"") or
el.isStereokinded(""CORBAUserDefinedType""))",1.7,,
"A «CORBAModule»-stereotyped package may directly contain at most one
Class stereotyped as «CORBAConstants».","self.ownedElement
->collect(el | el.isStereotyped(""CORBAConstants""))->size <= 1",1.7,,
A «CORBAObjectType»-stereotyped Class may not have Receptions.,self.features->forAll(feature | not feature.oclIsTypeOf(Reception)),1.7,,
"The ownedElements of a «CORBAObjectType»-stereotyped Class may only be
Classes stereotyped with a descendant of «CORBAConstructedType»,
«CORBAIndexedType», or «CORBAWrapper».","self.ownedElements
->forAll(ownedEl | ownedEl.isStereokinded(""CORBAConstructedType"") or
ownedEl.isStereoKinded(""CORBAIndexedType"") or
ownedEl.isStereoKinded(""CORBAWrapper""))",1.7,,
"All parents of a «CORBAObjectType»-stereotyped Class must have the same
stereotype as the Class.","self.generalization
->forAll(generalization | generalization.parent..stereotype.name =
self.stereotype.name)",1.7,,
"All Attributes of a «CORBAInterface»-stereotyped Class must have visibility
“public.”",self.allAttributes->forAll(attrib | attrib.visibility = #public),1.7,,
"All navigable opposite AssociationEnds of a «CORBAInterface»-stereotyped
Class must have visibility “public.”",self.navigableOppositeEnds->forAll(end | end.visibility = #public),1.7,,
"A «CORBAInterface»-stereotyped Class tagged “isLocal” can only participate
in Generalizations with other «CORBAInterface»-stereotyped Classes tagged
“isLocal.”","(self.generalization->forAll(
parent.isStereotyped(“CORBAInterface”) and
parent.stereotype.taggedValue->select(name = ""isLocal"")->size = 1))
and
(self.generalization->forAll(
child.isStereotyped(""CORBAInterface"") and
child.stereotype.taggedValue->select(name = ""isLocal"")->size = 1))",1.7,,
"All Attributes of a «CORBAValue»-stereotyped Class must have visibility
“public” or “private.”","self.allAttributes->forAll(attrib | attrib.visibility = #public or
attrib.visibility = #private)",1.7,,
"All navigable opposite AssociationEnds of a «CORBAValue»-stereotyped Class
must have visibility “public” or “private.”","self.navigableOppositeEnds->forAll(end | end.visibility = #public or
end.visibility = #private)",1.7,,
"A concrete «CORBAValue»-stereotyped Class may only specialize a single
other concrete «CORBAValue»-stereotyped Class.","not self.isAbstract implies
self.generalization
->select(parent.isStereokinded(""CORBAValue"") and not parent.isAbstract)->size = 1",1.7,,
"A «CORBAValue»-stereotyped Class may only specialize a single
«CORBAInterface»-stereotyped Class, and it must do so using a
«CORBAValueSupports»-stereotyped Generalization.","let supportedInterface =
self.generalization->select(parent.isStereotyped(""CORBAInterface"")) and
let supportsGeneralization =
supportedInterface.generalization->intersection(self.generalization) in
supportedInterface->size = 1 and
supportsGeneralization.isStereotyped(""CORBAValueSupports"")",1.7,,
"A «CORBAValue»-stereotyped Class may only contain a single Operation
stereotyped as «CORBAValueFactory».","self.allOperations->collect(isStereotyped(""CORBAValueFactory""))->size <= 1",1.7,,
"A «CORBACustomValue»-stereotyped Class may not be truncated by a
«CORBATruncatable»-stereotyped Generalization that specializes the Class.","self.generalization
->forAll(parent = self implies not isStereotyped(""CORBATruncatable""))",1.7,,
"A «CORBAValueSupports»-stereotyped Generalization must have a
«CORBAInterface»-stereotyped Class as its parent and a «CORBAValue»-
stereotyped or «CORBACustomValue»-stereotyped Class as its child.","self.parent.isStereotyped(""CORBAInterface"") and
self.child.isStereokinded(""CORBAValue"")",1.7,,
"A «CORBATruncatable»-stereotyped Generalization must have a concrete
«CORBAValue»-stereotyped or «CORBACustomValue»-stereotyped Class
as its parent and has the same restriction as to its child.","self.parent.isStereokinded(""CORBAValue"") and not self.parent.isAbstract and
self.child.isStereokinded(""CORBAValue"") and not self.child.isAbstract",1.7,,
"A «CORBAValueFactory»-stereotyped Operation can have only in parameters
and has no return type.",self.parameter->forAll(kind = #in),1.7,0,错误原因是将in认成了限制名，且#没有特殊处理
"A «CORBAValueFactory»-stereotypedOperation must be owned by a
«CORBAValue»-stereotyped or «CORBACustomValue»-stereotyped Class.","self.owner.isStereokinded(""CORBAValue"")",1.7,,
"A «CORBAWrapper»-stereotyped Classifier must participate as the child in
exactly one Generalization relationship.",self.generalization->select(gen | gen.child = self)->size = 1,1.7,,
"The parent of a «CORBAWrapper»-stereotyped Classifier must be stereotyped
as «CORBAPrimitive» or as a descendant of «CORBAUserDefinedType».","self.generalization
->forAll(gen | gen.parent.isStereotyped(""CORBAPrimitive"") or
gen.parent.isStereokinded(""CORBAUserDefinedType""))",1.7,,
"The Generalization relationship in which a «CORBAWrapper»-stereotyped
Classifier participates has the empty string as its discriminator and no powertypes.","self.generalization->forAll(gen | gen.discriminator = ““ and
gen.powertype->isEmpty)",1.7,,
"A «CORBAWrapper»-stereotyped Classifier may not have any non-inherited
features.",self.feature->isEmpty,1.7,,
"A «CORBAWrapper»-stereotyped Classifier may not participate in any
Associations with navigable opposite AssociationEnds.",self.navigableOppositeEnds->isEmpty,1.7,,
A «CORBAWrapper» can only extend a DataType or a Class.,self.oclIsTypeOf(DataType) or self.oclIsTypeOf(Class),1.7,,
"The parent of a «CORBATypedef»-stereotyped Classifier must not be
stereotyped as «CORBAAnonymousSequence» or
«CORBAAnonymousArray».","self.generalization
->forAll(gen |not gen.parent.isStereotyped(""CORBAAnonymousSequence"") and
not gen.parent.isStereotyped(""CORBAAnonymousArray""))",1.7,,
"A «CORBAConstants»-stereotyped Class must be directly contained by a
«CORBAModule»-stereotyped package.","self.namespace.isStereotyped(""CORBAModule"")",1.7,,
"All the features of a «CORBAConstants»-stereotyped Class must be
«CORBAConstant»-stereotyped Attributes.","self.feature->forAll(feature | feature.oclIsTypeOf (Attribute) and
feature.isStereotyped (""CORBAConstant"") )",1.7,,
"A «CORBAConstants»-stereotyped UtilityClass cannot participate in any
Associations.",self.associations->isEmpty,1.7,,
"A «CORBAConstant»-stereotyped Attribute has the changeability “frozen” and
the ownerScope “classifier.”",self.changeability = #frozen and self.ownerScope = #classifier,1.7,,
"The owner of a «CORBAConstant»-stereotyped Attribute must be stereotyped
«CORBAConstants» or «CORBAObjectType».","self.owner.isStereotyped(""CORBAConstants"") or
self.owner.isStereokinded(""CORBAObjectType"")",1.7,,
"All features of a «CORBAConstructedType»-stereotyped Classifier must be
Attributes with visibility “public.”","self.feature->forAll(feature | feature.oclIsTypeOf(Attribute) and
feature.visibility = #public)",1.7,,
"A «CORBAConstructedType»-stereotyped Classifier cannot participate in any
Generalization relationships.",self.generalization->isEmpty and self.specialization->isEmpty,1.7,,
"All the Attributes of a «CORBAStructType»-stereotyped Classifier must have
multiplicity 1..1.","self.allAttributes->forAll(multiplicity.range.lower = 1 and
multiplicity.range.upper = 1)",1.7,,
"All the navigable opposite AssociationEnds of a «CORBAStructType»-
stereotyped Classifier must have the upper multiplicity value equal to 1.",self.navigableOppositeEnds->forAll(multiplicity.range.upper = 1),1.7,,
"All the navigable opposite AssociationEnds of a «CORBAStructType»-
stereotyped Classifier whose type is not a «CORBAInterface»-stereotyped
Class must have the lower multiplicity value equal to 1.","self.navigableOppositeEnds->forAll(not isStereotyped(""CORBAInterface"")
implies multiplicity.range.lower = 1)",1.7,,
"Either exactly one of the Attributes or exactly one of the navigable opposite
AssociationEnds of a «CORBAUnion»-stereotyped Class (but not both) must be
stereotyped as «switch» (in the case of an Attribute) or «switchEnd» (in the
case of AssociationEnd).","self.allAttributes->select(attrib | attrib.type.isStereotyped(""switch"") )-
>size = 1 xor
self.navigableOppositeEnds->select(end |
end.type.isStereotyped(""swutchEnd"") )->size = 1",1.7,,
"The Attribute or AssociationEnd that represents the switch of the IDL union
represented by the «CORBAUnion»-stereotyped Class must have multiplicity
1..1.","let switch =
self.allAttributes->select(attrib |
attrib.type.isStereotyped(""switch""))->union(
self.navigableOppositeEnds->select(end |
end.type.isStereotyped(""switchEnd""))) in
switch.oclIsTypeOf(Attribute) implies
(switch.multiplicity.range.lower = 1 and
switch.multiplicity.range.upper = 1)
and
switch.oclIsTypeOf(AssociationEnd) implies
(switch.multiplicity.range.lower = 1 and
switch.multiplicity.range.upper = 1)",1.7,,
"With the exception of the element representing the switch, every Attribute and
navigable opposite AssociationEnd of a «CORBAUnion»-stereotyped Class
must have the multiplicity 0..1 and a tagged value “case.”","(self.allAttributes
->forAll(attrib | not attrib.type.isStereotyped(""switch"")
implies attrib.multiplicity.range.lower = 0 and
attrib.multiplicity.range.upper = 1))
and(self.navigableOppositeEnds
->forAll(end | not end.type.isStereotyped(""switchEnd"")
implies end.multiplicity.range.lower = 0 and
end.multiplicity.range.upper = 1))",1.7,,
"All the Attributes of a «CORBAEnum»-stereotyped Class must have
multiplicity 1..1, type CORBA::short and an initialValue equal to the value of its
IDLOrder tag.","self.allAttributes
->forAll(attrib |attrib.multiplicity.range.lower = 1 and
attrib.multiplicity.range.upper = 1 and
attrib.initialValue.body = attrib.taggedValues
->select(tag | tag.name = ""IDLOrder"").value)",1.7,,
"A «CORBAEnum»-stereotyped Class may not participate in any Association
that has navigable opposite AssociationEnds.",navigableOppositeEnds->isEmpty,1.7,,
"A «CORBAException»-stereotyped Exception cannot be the type of a
navigable AssociationEnd.",self.allEnds->forAll(end | end.type = self implies not end.isNavigable),1.7,,
A «CORBAIndexedType»-stereotyped Class has no features.,self.features->isEmpty,1.7,,
"A «CORBAIndexedType»-stereotyped Class participates in exactly one
Association that has a navigable opposite AssociationEnd",self.navigableOppositeEnds->size = 1,1.7,,
"There is exactly one Association in which a «CORBAIndexedType»
participates as the type of the near, non-navigable AssociationEnd.",self.nonNavigableNearEnds->size = 1,1.7,,
"All qualifiers of the single non-navigable near AssociationEnd of a
«CORBAIndexedType» must have multiplicity 1..1, type CORBA::long, and a
constraint of the form ""{0..n}"" or ""{0..*}"" (where n is a non-negative integer).","self.nonNavigableNearEnds->forAll(end | end.qualifier->forAll
(qualifier | qualifier.multiplicity.range.lower = 1 and
qualifier.multiplicity.range.upper = 1 and
qualifier.type.name = ""CORBA::long"" and
qualifier.constraint->exists(constraint |
constraintSubstring(constraint,1,3) = ""0.."" and
(constraintUpperValue = ""*"" or
constraintUpperValue >= 1))))",1.7,,
"If the type being indexed is a «CORBAInterface»-stereotyped Class, then the
opposite AssociationEnd of the one qualified Association in which the
«CORBAIndexedType»-stereotyped Class participates has multiplicity lower
bound of at most 1 and multiplicity upper bound of exactly 1.","self.navigableOppositeEnd.type.isStereotyped(""CORBAInterface"")
implies
self.navigableOppositeEnd.multiplicity.range.lower <= 1 and
self.navigableOppositeEnd.multiplicity.range.upper = 1",1.7,,
"If the type being indexed is not a «CORBAInterface»-stereotyped Class, then
• the opposite AssociationEnd of the one qualified Association in which the
«CORBAIndexedType»-stereotyped Class participates has multiplicity 1..1, and
• the near AssociationEnd of the qualified Association has multiplicity lower bound
of at most 1 and upper bound of exactly 1.","not
self.qualifiedAssociationOppositeEnd.type.isStereotyped(""CORBAInterface"")
implies
(self.navigableOppositeEnd.multiplicity.range.lower = 1 and
self.navigableOppositeEnd.multiplicity.range.upper = 1)
and
(self.navigableNearEnd.multiplicity.range.lower <= 1 and
self.navigableNearEnd.multiplicity.range.upper =1)",1.7,,
A «CORBAIndexedType»-stereotyped Class cannot have any ownedElements.,self.ownedElements->isEmpty,1.7,,
"The operation constraintAsString returns a substring of the Constraint body
expression, where lower is the lower bound of the substring and upper is the upper
bound of the substring.","constraintSubstring :
(constraint : Constraint, lower : Integer, upper : Integer);
constraintSubstring =
constraint.body.body.substring(lower,upper) --sic!",1.7,,
"The single non-navigable near AssociationEnd of a «CORBASequence»-
stereotyped Class must have a single qualifier with the name “index.”","self.nonNavigableNearEnds->size = 1 and
self.nonNavigableNearEnds
->forAll(end |end.qualifier->size = 1 and
end.qualifier->forAll(qualifier | qualifier.name = ""index"")",1.7,,
"A «CORBAAnonymousSequence»-stereotyped Class must have exactly one
navigable opposite AssociationEnd whose multiplicity is 1..1.","navigableOppositeEnds->size = 1 and
navigableOppositeEnds
->forAll(end | end.multiplicity.range.lower = 1 and
end.multiplicity.range.upper = 1)",1.7,,
"The single non-navigable near AssociationEnd of a «CORBAArray»-
stereotyped Class must have one or more qualifiers with the names “index<i>,”
where the <i> are contiguous integers starting from 0.","let dimensions = self.nonNavigableNearEnd.
qualifier->collect(name.substring(6,name.size)) in
self.nonNavigableNearEnd.qualifier
->forAll(name.substring(1,5) = ""index"") and
dimensions->isUnique(n | n) and
dimensions->forAll(dim | dim >= 0 and dim <= dimensions",1.7,,
"The single navigable opposite AssociationEnd of a «CORBAArray»-
stereotyped Class must have multiplicity 1..1.","navigableOppositeEnds
->forAll(end | end.multiplicity.range.lower = 1 and
end.multiplicity.range.upper = 1)",1.7,,
"A «CORBAAnonymousArray»-stereotyped Class must have exactly one
navigable opposite AssociationEnd whose multiplicity is 1..1.","navigableOppositeEnds->size = 1 and navigableOppositeEnds
->forAll(end | end.multiplicity.range.lower = 1 and
end.multiplicity.range.upper = 1)",1.7,,
"A «oneway»-stereotyped Operation may not have any out or inout Parameters
and must have a return Parameter of type CORBA::void","self.parameter
->forAll(param | param.kind <> #out and
param.kind <> #inout) and
self.parameter->select(param | param.kind = #return and
param.type.name = “CORBA::void”)->size = 1)",1.7,,
"A «oneway»-stereotyped Operation must be owned by a
«CORBAInterface»-stereotyped Class.","self.owner.isStereotyped(""CORBAInterface"")",1.7,,
A «readonly»-stereotyped Attribute cannot raise a modify exception,"not self.taggedValue->exists(tag | tag.name = ""setRaises"")",1.7,,
upperValue must be a LiteralUnlimitedNatural and lowerValue must be a LiteralInteger. Both are required,self.upperValue->notEmpty() and self.upperValue->asSequence()->first().oclIsKindOf(LiteralUnlimitedNatural) and self.lowerValue->notEmpty() and self.lowerValue->asSequence()->first().oclIsKindOf(LiteralInteger),1.8,,
concurrency must be sequential,self.concurrency = CallConcurrencyKind::sequential,1.8,,
isStatic must be false,not self.isStatic,1.8,,
"Either all the classifiers are classes, or there is one classifier that is a data type",self.classifier->forAll(oclIsKindOf(Class)) or self.classifier->size() = 1 and self.classifier->forAll(oclIsKindOf(DataType)),1.8,,
"If an operation is abstract, it must have no method. Otherwise it must not have more than one method and it must have
exactly one method unless owned by an active class","If self.isAbstract then self.method->isEmpty()
else
 self.method->size() <= 1 and
 ((self.class = null or not self.class.isActive) implies
 self.method->size() = 1)
endif",1.8,,
isException must be false,not self.isException,1.8,,
isDerived and isDerivedUnion must be false,not self.isDerived and not self.isDerivedUnion,1.8,,
A reception must not have an associated method.,self.method->isEmpty(),1.8,,
A reception must not be abstract.,not self.isAbstract,1.8,,
isDerived must be false,not self.isDerived,1.8,,
Only active classes may have classifier behaviors.,self.classifierBehavior->notEmpty() implies self.isActive,1.8,,
Only an active class may specialize an active class.,self.parents()->exist(isActive) implies self.isActive,1.8,,
Only an abstract class may have abstract behavioral features.,self.member->select(oclIsKindOf(BehavioralFeature))->exists(isAbstract) implies self.isAbstract,1.8,,
"In this specification, a fUML instance model must have Behavior.isReentrant",self.isReentrant,1.8,,
body and language must be empty,self.language->isEmpty() and self.body->isEmpty(),1.8,,
An opaque behavior cannot be active.,not self.isActive,1.8,,
"An activity may be active, but cannot have a classifier behavior.",self.classifierBehavior->isEmpty(),1.8,,
isSingleExecution must be false.,not self.isExecution,1.8,,
A guard is only allowed if the source of the edge is a DecisionNode.,self.guard->notEmpty() implies self.source.oclIsKindOf(DecisionNode),1.8,,
isCombineDuplicate must be false,not self.isCombineDuplicate,1.8,,
isMulticast and isMultireceive must be false,not self.isMulticast and not self.isMultireceive,1.8,,
ordering must be FIFO,self.ordering = ObjectNodeOrderingKind::FIFO,1.8,,
isControlType must be false,not self.isControlType,1.8,,
The operations of the call events on the triggers of an accept call action must be owned or inherited by the context class of the action.,"let cls: Class = self.context.oclAsType(Class) in
let classes:Bag(Class) = cls.allParents()->select(oclIsKindOf(Class))->collect(oclAsType(Class))->union(cls->asBag()) in
classes.ownedOperation->includesAll(self.trigger.event->collect(oclAsType(CallEvent)).operation)",1.8,,
The context of the containing activity of the accept event action must be an active class.,self.context.oclAsType(Class).isActive,1.8,,
An accept event action may not be contained directly or indirectly in the test part of a clause or loop node.,"self->closure(inStructuredNode.oclAsType(ActivityNode))->forAll(n |
let s : StructuredActivityNode = n.inStructuredNode in
 s->notEmpty() implies
(s.ocllsTypeOf(ConditionalNode) implies s.oclAsType(ConditionalNode).clause.test->
excludes(n.oclAsType(ExecutableNode)) and
s.ocllsTypeOf(LoopNode) implies s.oclAsType(LoopNode).test->excludes(n.oclAsType(ExecutableNode))))",1.8,,
"Unless the action is an accept call action, all triggers must be for signal events.","not self.oclIsKindOf(AcceptCallAction) implies
self.trigger.event->forAll(oclIsKindOf(SignalEvent))",1.8,,
The behavior may not be active.,not self.behavior.isActive,1.8,,
isSynchronous must be true,self.isSynchronous,1.8,,
"If the behavior has a context, it must be the same as the context of the enclosing activity or a (direct or indirect) superclass of it.","self.behavior.context->notEmpty() implies
 self.context->union(self.context.allParents())->includes(self.behavior.context)",1.8,,
The given classifier must be a class.,self.classifier.oclIsKindOf(Class),1.8,,
The given classifier must not be an owned behavior (or otherwise have a context classifier).,self.classifier.oclIsKindOf(Behavior) implies self.classifier.oclAsType(Behavior).context = null,1.8,,
mode cannot be stream,self.mode <> ExpansionKind::stream,1.8,,
Edges may not cross into or out of an expansion region.,self.edge->forAll(self.node->includes(source) and self.node->includes(target)),1.8,,
An expansion region may not have output pins.,self.output->isEmpty(),1.8,,
no setupParts in fUML,self.setupPart->isEmpty(),1.8,,
isControl must be false,not self.isControl,1.8,,
All the old and new classifiers must be classes,self.oldClassifier->forAll(oclIsKindOf(Class)) and self.newClassifier->forAll(oclIsKindOf(Class)),1.8,,
isSynchronous must be false.,not self.isSynchronous,1.8,,
A TimedEvent is bound to one Clock.,on->size( ) = 1,1.9,,
The optional repetition property of a TimedEvent must be not defined when every is not defined.,every->isEmpty( ) implies repetition->isEmpty( ),1.9,,
Not all three properties are empty.,duration->notEmpty( ) or ( start->notEmpty( ) and finish->notEmpty( ) ),1.9,,
"A singledependency NfpRefine shall have only one client (from), but may have one or many suppliers (to).","context NfpRefine
inv: base_Dependency.from->size()=1 and base_Dependency.to->size()>=1",1.9,,
"If the Property ordering is set to UserDefined, it implies that both properties insertion and selection have to be
specified.",self.ordering = UsedDefined implies (self.insertion.size()=1 and self.selection.size()=1),1.9,,
 A conjugated port cannot be an atomic port.,self.isConjugated = true implies self.isAtomic = false,1.9,,
The ports referenced by the “onPorts” association must be FlowPorts or ClientServerPorts,"self.onPorts->forAll(port | port.oclIstypeOf(MARTE::MARTE_DesignModel::GCM::FlowPort) or
port.oclIsTypeOf(MARTE::MARTE_DesignModel::GCM::ClientServerPort). ",1.9,,
The features referenced by the “onFeatures” association must be FlowProperties or ClientServerFeatures.,"self.onFeatures->forAll(feature | feature.oclIstypeOf(MARTE::MARTE_DesignModel::GCM::FlowPorperty) or
feature.oclIsTypeOf(MARTE::MARTE_DesignModel::GCM::ClientServerFeature). ",1.9,,
A (local) clock can be defined either by a ClockExpression or by an Event.,definingEvent->None.mpty( ) = defBody->isEmpty( ),1.9,,
A ClockRelation constrains at least two clocks or anonymous clocks.,clocks->union(anonymousClocks)->size( ) >= 2,1.9,,
The referenced instants belong to different clocks.,instanceRefs.clock->size( ) = 2 ,1.9,,
All coincident junction instants in a coincidence relation are owned by distinct time bases.,"coincidentJIs->forAll( i,j | i<>j implies i.tb <> j.tb )",1.9,,
The nature of a discrete time base is discrete.,self.nature = TimeNatureKind::discrete,1.9,,
All instants owned by a discrete time base are junction instants.,self.instants->forAll( j | j.oclIsTypeOf(JunctionInstant) ),1.9,,
minD and maxD duration values of this duration interval value have the same onClock clock,minD.onClock = maxD.onClock,1.9,,
The intervalValue is on the same clock as the duration value,self.onClock = intervalValue.min.onClock,1.9,,
"All junction instants denoted by this instant value are owned by the timeBase time base of the onClock clock of this
time value.",denotedInstant->forAll( j | j.tb = self.onClock.timeBase ),1.9,,
All related time bases in a time base relation are directly or indirectly contained in this multiple time base,self.allIncludedTimesBases( )->includesAll(self.relatedTBs),1.9,,
"All related junction instants in a time instant relation are owned by a time base directly or indirectly contained in this
multiple time base.",self.allMemberJunctionInstants( )->includesAll(self.relatedJIs,1.9,,
The before and the after junction instants of a precedence relation are owned by distinct time bases,after.tb <> before.tb,1.9,,
A TimedDurationObservation of an execution refers to one clock only.,exc->notEmpty( ) implies on->size( ) = 1,1.9,,
 A TimedDurationObservation of two event occurrences refers to one or two clocks.,eocc->notEmpty( ) implies on->size( ) = 1 or on->size( ) = 2,1.9,,
 The isRelative attribute determines the kind of ClockedValueSpecification,"if isRelative, then when.oclIsTypeOf(DurationValueSpecification) else when.oclIsTypeOf(InstantValueSpecification)endif",1.9,,
The Clock of an at InstantValue is also an on Clock of this TimedOccurrenceEvent.,on->includesAll(at.onClock),1.9,,
All the at instant values are specified on different clocks.,"at->forAll( iv, jv | iv <> jv implies iv.onClock <> jv.onClock )",1.9,,
 The Clock of a startInstant InstantValue is also a on Clock of this TimedExecution.,on -> includesAll(startInstant.onClock),1.9,,
The Clock of a finishInstant InstantValue is also a on Clock of this TimedExecution.,on -> includesAll(finishInstant.onClock),1.9,,
The Clock of an executionDuration InstantValue is also a on Clock of this TimedExecution.,on -> includesAll(executionDuration.onClock),1.9,,
"Not all 3 properties duration, start, finish can be absent","( duration->isEmpty( ) implies start->notEmpty( ) and finish->notEmpty( ) )and
( ( start->isEmpty( ) and finish->isEmpty( ) ) implies duration->notEmpty( ) )",1.9,,
The lower and the upper bounds are owned by the time base of the time interval.,(lower.tb = base) and (upper.tb = base),1.9,,
Min and max instant values of this time interval value have the same onClock clock.,min.onClock = max.onClock,1.9,,
 A main real-time unit shall specify a main service.,self.isMain=true implies self.main->size() = 1,1.9,,
The base_InstanceSpecification of the Clock must be an InstanceSpecification of the base_Class of its type property,"not self.base_InstanceSpecification.oclIsUndefined() implies
self.base_InstanceSpecification.classifier->includes(self.type.base_Class)",1.9,,
The base_Property of the Clock must be a Property of the base_Class of its type property.,not self.base_Property.oclIsUndefined() implies self.base_Property.type = self.type.base_Class,1.9,,
The unit must be an ownedLiteral of the unitType enumeration of the ClockType.,self.unit->notEmpty( ) implies self.type.unitType.ownedLiteral->includes(self.unit),1.9,,
A logical clock does not have a defined standard,self.type.isLogical implies self.standard->isEmpty( ),1.9,,
"When clock extends an event, its type must be logical",not self.base_Event.oclUndefined() implies self.type.isLogical = true,1.9,,
Class inheritance should not be used for OperationalTransformations.,self.superClass->isEmpty(),1.11,,
The type of a ModelParameter is a ModelType or Collection of a ModelType.,"self.type.oclIsKindOf(ModelType)
or (self.type.oclIsKindOf(CollectionType)
 and self.type.oclAsType(CollectionType).elementType.oclIsKindOf(ModelType))",1.11,,
The body of a helper operation is a direct instance of OperationBody,self.body.oclIsTypeOf(OperationBody),1.11,,
The body of a constructor operation is a direct instance of ConstructorBody.,self.body.oclIsTypeOf(ConstructorBody),1.11,,
The body of a constructor operation is a direct instance of MappingBody,self.body.oclIsTypeOf(MappingBody),1.11,,
The body of a disjuncting mapping must be empty.,disjunct->notEmpty() implies body = null,1.11,,
Every containment ancestor of an ImperativeExpression that is an OclExpression must also be an ImperatveExpression.,"inv IsInImperativeContext: let ancestors = self->closure(oclContainer())
 in ancestors->forAll(oclIsKindOf(OclExpression) implies oclIsKindOf(ImperativeExpression))",1.11,,
A deferred assignment is a simple assignment,self.value->size()=1,1.11,,
"If citedElement is populated, isCitation must be true.",self.citedElement <> null implies self.isCitation = true,1.12,,
ImplementationConstraints should only be specified if +isAbstract is true,"self.implmentationConstraint->size() >
0 implies self.isAbstract = true ",1.12,,
"AssuranceCasePackageInterface are only allowed to contain the following: AssuranceCasePackageInterface,
ArgumentPackageInterfaces, ArtifactPackageInterfaces, and TerminologyPackages.","self.assuranceCasePackage->forall(acp|acp.oclIsTypeOf(AssuranceCasePackageInterface)) and
self.argumentPackage->forall(ap|ap.oclIsTypeOf(Argumentation::ArgumentPackageInterface)) and
self.artifactPackage->forall(ap|ap.oclIsTypeOf(Artifact::ArtifactPackageInterface)) and
self.terminologyPackage->forall(tp|tp.oclIsTypeOf(Terminology::TerminologyPackageInterface))",1.12,,
The participantPackages should be either AssuranceCasePackage or AssuranceCasePackageInterfaces.,"self.participantPackage->forall(pp|pp.oclIsTypeOf(AssuranceCase::AssuranceCasePacka ge) or
pp.oclIsTypeOf(AssuranceCase::AssuranceCasePackageInterface))",1.12,,
The participantPackages should be either TerminologyPackage or TerminologyPackageInterface,self.participantPackage->forall(pp|pp.oclIsKindOf(Terminology::TerminologyPac kage)),1.12,,
The participantPackages should be only ArgumentPackages,self.participantPackage->forall(pp|pp.oclIsTypeOf(Argument::ArgumentPackage)),1.12,,
The source of AssertedEvidence relationships must be ArtifactReference.,self.source->forall(s|s.oclIsTypeOf(ArtifactReference)),1.12,,
Metaclasses to be added must not be abstract, not self.getMetaClasses()->exists(isAbstract=true),1.13,,
Any element must be classified by at least one metaclass.,self.getMetaClasses()->size() >=1,1.13,,
The metaclass association is derived from the getMetaClasses operation.,self.metaClass = self.getMetaClasses(),1.13,,
No pair of classes exists such that they are both equivalent and disjoint,"not Class.allInstances()->exists(c | self.isEquivalentTo(c) and
 self.isDisjointWith(c) or self.hasDisjointAncestorsWith(c)))",1.13,,
The classifiers can only be Classes or Associations.,classifier->forAll(c | c.oclIsKindOf(Class) or c.oclIsKindOf(Association)),1.13,,
"If the InstanceSpecification is not a Link, none of its classifiers are associations","not self.oclIsKindOf(Link) implies classifier->forAll(c |
 c.oclIsKindOf(Class))",1.13,,
All classifiers are non-abstract,not classifier->exists(isAbstract),1.13,,
"The defining feature of each slot is a structural feature (directly or inherited) of a classifier of the instance
specification.","slot->forAll(s | classifier->exists (c |
 c.allFeatures()->includes (s.definingFeature)))",1.13,,
One structural feature (including the same feature inherited from multiple classifiers) is the defining feature of at most one slot in an instance specification.,"classifier->forAll(c | (c.allFeatures()->forAll(f |
 slot->select(s | s.definingFeature = f)->size() <= 1)))",1.13,,
No two metaclasses may be disjoint or have disjoint ancestors,"let classes : Set(Class) = self.getMetaClasses() in  classes->forAll(c1 | not classes->exists(c2 | c1 <> c2 and
 (c1.isDisjointWith(c2) or c1.hasDisjointAncestorsWith(c2))))",1.13,,
Each instance is classified at least once., classifier->notEmpty(),1.13,,
"If any metaclasses or their ancestors have equivalent classes, then those equivalent classes are also classifiers, either directly or indirectly",self.hasAllEquivalentClasses(),1.13,,
"If the language attribute is not empty, then the size of the body and language arrays must be the same.",language->notEmpty() implies (body->size() = language->size()),1.14,,
The general classifiers are the classifiers referenced by the generalization relationships.,general = self.parents(),1.14,,
The defining feature of each slot is a structural feature (directly or inherited) of a classifier of the instance specification.,slot->forAll(s | classifier->exists(c | c.allFeatures()->includes(s.definingFeature)) ),1.14,,
One structural feature (including the same feature inherited from multiple classifiers) is the defining feature of at most one slot in an instance specification.,classifier->forAll(c | (c.allFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1) ),1.14,,
The lower bound must be a non-negative integer literal.,lowerBound()->notEmpty() implies lowerBound() >= 0,1.14,,
The upper bound must be greater than or equal to the lower bound.,(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound(,1.14,,
The derived lower attribute must equal the lowerBound.,lower = lowerBound(),1.14,,
The derived upper attribute must equal the upperBound,upper = upperBound(),1.14,,
Generalization hierarchies must be directed and acyclical. A classifier cannot be both a transitively general and transitively specific classifier of the same classifier.,not self.allParents()->includes(self),1.14,,
The inheritedMember association is derived by inheriting the inheritable members of the parents.,self.inheritedMember = self.inherit( self.parents()->collect(p | p.inheritableMembers(self))->asSet() ),1.14,,
"If a NamedElement is not owned by a Namespace, it does not have a visibility",namespace->isEmpty() implies visibility->isEmpty(),1.14,,
"When an association specializes another association, every end of the specific association corresponds to an end of the general association, and the specific end reaches the same type or a subtype of the more general end.",Sequence{1..self.memberEnd->size()}-> forAll(i | self.general->select(oclIsKindOf(Association)).oclAsType(Association)-> forAll(ga |self.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type))),1.14,,
endType is derived from the types of the member ends.,self.endType = self.memberEnd->collect(e | e.type),1.14,,
Only binary associations can be aggregations,self.memberEnd->exists(isComposite) implies self.memberEnd->size() = 2,1.14,,
Association ends of associations with more than two ends must be owned by the association.,if memberEnd->size() > 2 then ownedEnd->includesAll(memberEnd),1.14,,
A redefinable element can only redefine non-leaf redefinable elements,self.redefinedElement->forAll(not isLeaf),1.14,,
The visibility of an ElementImport is either public or private.,self.visibility = #public or self.visibility = #private,1.14,,
An importedElement has either public visibility or no visibility at all.,self.importedElement.visibility.notEmpty() implies self.importedElement.visibility = #public,1.14,,
The importedMember property is derived from the ElementImports and the PackageImports.,importedMember = self.elementImport.importedElement.asSet()->union(self.packageImport.importedPackage->collect(p | p.visibleMembers())),1.14,,
n operation can have at most one return parameter.,ownedParameter->select(par | par.direction = #return)->size() <= 1,1.14,,
A bodyCondition can only be specified for a query operation.,bodyCondition->notEmpty() implies isQuery,1.14,,
"If an element that is owned by a package has visibility, it is public or private.",self.ownedElements->forAll(e | e.visibility->notEmpty() implies e.visibility = #public or e.visibility = #private),1.14,,
The non-owned end of an Extension is typed by a Class,metaclassEnd()->notEmpty() and metaclass()->oclIsKindOf(Class),1.14,,
The multiplicity of ExtensionEnd is 0..1 or 1.,(self->lowerBound() = 0 or self->lowerBound() = 1) and self->upperBound() = 1,1.14,,
The aggregation of an ExtensionEnd is composite.,self.aggregation = #composite,1.14,,
An element imported as a metaclassReference is not specialized or generalized in a Profile.,self.metaclassReference.importedElement-> select(c | c.oclIsKindOf(Classifier) and (c.generalization.namespace = self or c.specialization.namespace = self))->isEmpty(),1.14,,
All elements imported either as metaclassReferences or through metamodelReferences are members of the same base reference metamodel.,self.metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()-> union(self.metaclassReference.importedElement.allOwningPackages())->notEmpty(),1.14,,
A Stereotype may only generalize or specialize another Stereotype.,generalization.general->forAll(e | e.oclIsKindOf(Stereotype)) and generalization.specific->forAll(e | e.oclIsKindOf(Stereotype)),1.14,,
The first constrained element shall be a property.,self.base_Constraint.constrainedElement->at(1).oclIsKindOf(Property),1.15,,
The first constrained element shall be a value specification.,self.base_Constraint.constrainedElement->at(2).oclIsKindOf(ValueSpecification),1.15,,
An UPRConstraint constraint shall have 2 constrained elements.,self.base_Constraint.constrainedElement->size()=2,1.15,,
A Sensitivity is a binary relationship.,self.base_Dependency.supplier->size() = 1 and self.base_Dependency.client->size() = 1,1.15,,
Both the client and the supplier shall be constrained by a DesignObjectiveConstraint.,self.base_Dependency.client->union(self.base_Dependency.supplier)->forAll(p | DesignObjectiveConstraint.allInstances().constrainedProperty()->includes(p)),1.15,,
The client shall be constrained by a DesignObjectiveConstraint.,self.base_Dependency.client->forAll(p | DesignObjectiveConstraint.allInstances().constrainedProperty()->includes(p),1.15,,
every customer who enters a loyalty program be of legal age.,age >= 18,2.1,,
the number of valid cards for every customer must be equal to the number of programs in which the customer participates. ,"programs->size() = cards->select( valid = true )->size()
",2.1,,
male Customers must be approached using the title 'Mr.'.,gender = Gender::male implies title = 'Mr.',2.1,,
validFrom should be earlier than goodThru,validFrom.isBefore(goodThru),2.1,,
selects all transactions on a CustomerCard that have more than 100 points,self.transactions->select( points > 100 )->notEmpty(),2.1,,
a membership must be one of the service levels of the program to which the membership belongs,"programs.levels ->includes(currentLevel)
",2.1,,
the actual service level of a membership must always be a service level of the loyalty program ,programs.levels->includes(currentLevel),2.1,,
the service level of each membership must be a service level known to the loyalty program,"levels->  includesAll(Membership.currentLevel)
",2.1,,
the color of this card must match the service level of the membership,"currentLevel.name = 'Silver' implies card.color = Color::silver
    and
    currentLevel.name = 'Gold' implies card.color = Color::gold",2.1,,
a loyalty program offers at least one service to its customers,partners.deliveredServices->size() >= 1,2.1,,
"if none of the services offered in a LoyaltyProgram credits or debits the LoyaltyAccount instances, then these instances are useless and should not be present","partners.deliveredServices->forAll(
                pointsEarned = 0 and pointsBurned = 0 )
                             implies Membership.account->isEmpty()",2.1,,
the first element of this ordered set must be named Silver as follows,levels->first().name = 'Silver',2.1,,
there is at least one ServiceLevel with the name 'basic',self.levels->exists(name = 'basic'),2.1,,
"the number of participants in a loyalty program must be less than 10,000",self.participants->size() < 10000,2.1,,
the number of the loyalty account must be unique within a loyalty program,self.Membership.account->isUnique( acc | acc.number ) ,2.1,,
the names of all customers of a loyalty program are different,"self.participants->forAll(c1, c2 |
                           c1 <> c2 implies c1.name <> c2.name)",2.1,,
the age of all participants in a loyalty program is less than or equal to 70,participants->forAll( age() <= 70 ),2.1,,
"there may be only one loyalty account that has a number lower than 10,000",self.Membership.account->one( number < 10000 ),2.1,,
the attribute numberOfCustomers of class ProgramPartner. We want to state that this attribute holds the number of customers who participate in one or more loyalty programs offered by this program partner. ,"numberOfCustomers = programs.participants->asSet()->size()
",2.1,,
"the maximum number of points that may be earned by all services of a program partner is equal to 10,000","deliveredServices.transactions       -- all transactions
   ->select( oclIsTypeOf( Earning ) ) -- select earning ones
              .points->sum()               -- sum all points
              < 10,000                -- sum smaller than 10,000",2.1,0 有注释,
all cards that generate transactions on the loyalty account must have the same owner,transactions.card.owner->asSet()->size() = 1,2.1,,
"if the attribute points is greater than zero, there exists a Transaction with points greater than zero",points > 0 implies transactions->exists(t | t.points > 0),2.1,,
you could demand that at least one of the values be 500,"transactions->collect( points )->
                        exists( p : Integer | p = 500 )",2.1,那个exsits括号里的无法正确识别,
the available services for a service level must be offered by a partner of the loyalty program to which the service level belongs,"program.partners
             ->includesAll(self.availableServices.partner)",2.1,,
"The example rule checks every transaction amount in the message and if the number of occurencies of the value 30 is 2, true will be returned.",self.Transaction.Amount->count(30) = 2,2.2,,
"The example rule checks every transaction amount in the message and if the amount 30 is not found, true will be returned.",self.Transaction.Amount->excludes(30),2.2,,
"The example rule checks every transaction in the message and if one of the amounts is greater than 100, true will be returned. First a variable ""a"" is declared for the individual transaction. The condition statement is separated with a ""|""-sign. Then the statement is checked for every transaction in the message. If one of the amounts is greater than 100, true will be returned.", self.Transaction->exists(a|a.Amount > 100),2.2,,
"The example rule checks every transaction in the message if the amount is greater than 30. First a variable ""a"" is declared for the individual transaction. The condition statement is separated with a ""|""-sign. Then the statement is checked for every transaction in the message. If all of the amounts are greater than 30, true will be returned.",self.Transaction->forAll(a|a.Amount > 30),2.2,,
"The example rule checks every transaction amount in the message and if the amount 30 is found, true will be returned.",self.Transaction.Amount->includes(30),2.2,,
The example rule mandates the usage of both Creditor Name. I.e. the size of occurrence number of element Creditor / Name has to be 1.,self.Creditor.Name->size() = 1,2.2,,
" The example sums every transaction amount in the message if the amounts are valid type and compares them to the integer. If the sum is 100, true will be returned.",self.Transaction.Amount->sum() = 100,2.2,,
The example rule returns the absolut value of the first transaction amount and compares it to the right side operand. It's assumed that the value can be negative (this may not be the case in every situation). ,self.Transaction.at(0).Amount.abs() = 30,2.2,,
"The example rule compares the date of <TimeStamp> to the date of <Dt>. If the date of  <TimeStamp> is after the date of <Dt>, true will be returned.",self.TimeStamp.after(self.Dt),2.2,,
"The example rule checks every transaction amount in the message and if the number of instances is two, true will be returned. The size method returns the size of the set returned by the allInstances method. ",self.Transaction.Amount.allInstances()->size() = 2 ,2.2,,
 The example rule checks if the date of <Dt> is within 3 days from the system date., self.Dt.allowedDaysInFuture(3),2.2,,
The example rule checks if the date of <Dt> is within 3 days from the system date.,self.Dt.allowedDaysInPast(3),2.2,,
"The example rule compares the date of <TimeStamp> to the date of <Dt>. If the date of  <TimeStamp> is before the date of <Dt>, true will be returned.", self.Timestamp.before(self.Dt),2.2,,
"Example rule expects the position 1 (the second character in string) to contain ""A"".","self.Id.charAt(1) = ""A""",2.2,0,
"Example rule expects the value of Id to contain characters ""aaaa"".","self.Id.compareTo(""aaaa"") = 0",2.2,0,
"Example rule expects the value of Id to contain characters ""aaaa"", ignoring case considerations.","self.Id.compareToIgnoreCase(""aaaa"") = 0",2.2,0,
"This rule takes debtor name and concatenates it with creditor name, and then verifies that Id contains the concatenated string", self.Debtor.Name.concat(self.Creditor.Name) = self.Id,2.2,,
The example rule checks if the value if element <Id> contains character sequence 'content'.,self.Id.contains('content'),2.2,,
The example decodes the <AttachmentContent> field value and checks that the length of the decoded value does not exceed 1024 characters.,self.AttachmentContent.decodeBase64().size() <= 1024,2.2,,
" The rule is checking if the value of the encoding attribute in XML declaration is ""UTF-8"". If it's not, an error will be given."," self.encoding() = ""UTF-8""",2.2,0,
 The example rule checks if the value of <Id> ends with character a., self.Id.endsWith('a'),2.2,0,
" The example rule compares the intiger quotient of the amount to the integer 30. If the integer quotient is 30, true will be returned. 
",self.Amount.floor() = 30,2.2,,
 The example rule checks if the element <Dt> has a value.,self.Dt.hasValue(),2.2,,
 The rule here checks if character a is found from the value of element <Id>. The rule passes if character a is not found as then the lastIndexOf method returns value -1.,self.Id.indexOf('a') = -1,2.2,0,
The example rule checks if a DTD is given.,self.isDTDPresent(),2.2,,
The example rule checks if the <Id> element value is integer or decimal. The rule returns an error if the value is not numeric.,self.Id.isNumeric(),2.2,,
The example rule check if the value of <Id> element contains only characters and not digits.,self.Id.isOnlyChars(),2.2,,
The example rule checks if the given country code is valid.,self.PstlAdr.Ctry.isValidCountryCode(),2.2,,
The example rule checks if the given creditor identifier is valid.,self.Creditor.Id.isValidCreditorIdentifierEPC(),2.2,,
The example rule checks if the given currency code is valid.,self.Amount.Ccy.isValidCurrencyCode(),2.2,,
The example rule checks that the value in dateString field is valid ISO 8601 datetime.,"self.dateTimeString.isValidDate(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX"")",2.2,0,
The example rule checks if the given IBAN is valid., self.Debtor.IBAN.isValidIBAN(),2.2,,
The example rule checks if the given reference is valid.,self.Amount.REF.isValidReference('FI'),2.2,,
The example rule checks if the given reference is valid.,self.Amount.REF.isValidRF(),2.2,,
The example checks if last string 'content' is found starting from the position 1 of the value of the <Id> element. First position of a string is 0.,self.Id.lastIndexOf('content') = 9,2.2,0,
"The example rule checks if the string contains only lower case letters from a to z.
 ",self.Id.matches('[a-z]*'),2.2,0,
 The example rule compares the larger amount from the first and second transaction amounts to the right side operand. It's assumed that there is at least two transactions. The 'at' method doesn't work with the Bag type so it has to be changed to Sequence.,self.Transaction->asSequence().Amount->at(0).max(self.Transaction->asSequence().Amount->at(1)) = 100,2.2,,
 The example rule compares the lowest amount from the first and second transaction amounts to the right side operand. It's assumed that there is at least two transactions. ,self.Transaction.at(0).Amount.min(self.Transaction.at(1).Amount) = 30,2.2,,
"The example rule compares the date of <TimeStamp> minus 2 days to the date of <Dt>. If the date of  <TimeStamp> after the reduced days equals the date of <Dt>, true will be returned. This works in the same way with months and years.", self.TimeStamp.minusDays(2) = self.Dt,2.2,,
" The example rule compares the date & time of <TimeStamp> minus 2 hours to the date & time of <Dt>. If the date & time of <TimeStamp> after the reduced hours equals the date & time of <Dt>, true will be returned. This works in the same way with minutes and seconds.",self.TimeStamp.minusHours(2) = self.Dt,2.2,,
 The example rule checks if the default namespace is 'http://www.XMLdation.com'.,self.namespace() = 'http://www.XMLdation.com',2.2,0,
The example rule checks if the noNamespaceSchemaLocation is given., self.noNamespaceSchemaLocation()->size() = 1,2.2,,
 The example rule checks if the date of <Dt> converted to a string matches the string on the right side of the equation.,self.Dt.oclAsType(string) = '2018-05-28',2.2,0,
 The example rule checks if the type or supertypes of the value of <Dt> matches the ISO Date type., self.Dt.OclIsKindOf(ISODate),2.2,,
 The example rule checks if the type of the value of <Dt> matches the ISO Date type.,self.Dt.oclIsTypeOf(ISODate),2.2,,
 The example rule checks if the value of <Dt> is undefined.,self.Dt.oclIsUndefined(),2.2,,
" The example rule compares the date of <TimeStamp> plus 2 days to the date of <Dt>. If the date of  <TimeStamp> after the additional days equals the date of <Dt>, true will be returned. This works in the same way with months and years.", self.TimeStamp.plusDays(2) = self.Dt,2.2,,
" The example rule compares the date & time of <TimeStamp> plus 2 hours to the date & time of <Dt>. If the date & time of <TimeStamp> after the additional hours equals the date & time of <Dt>, true will be returned. This works in the same way with minutes and seconds.",self.TimeStamp.plusHours(2) = self.Dt,2.2,,
"The example rule compares the nearest integer of the amount to the integer 30. If the nearest integer is 30, true will be returned. ", self.Amount.round() = 30,2.2,,
 The example rule checks if the schemaLocation attribute is given., self.schemaLocation()->size() = 1,2.2,,
 The example rule check the length of the value of <Id> element and check that it is less than or equal to 20.,self.Id.size() <= 20,2.2,,
"Rule checks whether the returned collection contains two parts. I.e, whether the given string contains char ""-"" in the middle of the string."," self.Id.split(""-"")->size() = 2",2.2,,
The example rule checks if the standalone is 'yes'.,self.standalone() = 'yes',2.2,,
The example rule checks if the value of <Id> starts with character a.,self.Id.startsWith('a'),2.2,,
" The example rule takes first two characters, i.e. characters starting form index 0 and ending before index 2, from the <Id> element value and compares it to string ""FI"". Returns true if the string starts with ""FI"".","self.Id.substring(0,2) = ""FI""",2.2,,
" The example rule converts the value of <Id> element to lower case and compares it to ""idcontent"".","self.Id.toLower() = ""idcontent""",2.2,0,
"The example rule tries to convert the value of <Id> to a real number and then compares it to the number 100,01. If <Id> is convertable and matches 100,01, true will be returned.",self.Id.toReal() = 100.01,2.2,,
 In this example the value of <AttachmentSecureHash> field found from the file is compared to the SHA-1 hash value which is calculated from the value of <AttachmentContent> element of the file., self.AttachmentSecureHash = self.AttachmentContent.toSHA1(),2.2,,
" The example rule checks if the date of <Dt> matches the string '2018-05-28', when converted to a string.",self.Dt.toString() = '2018-05-28',2.2,0,
" The example rule converts <Id> elements value to upper case and compares it to string ""IDCONTENT""
 "," self.Id.toUpper() = ""IDCONTENT""",2.2,0,
" The example rule executes trim to the <Id> element and compares the result to a string ""IdContent""."," self.Id.trim() = ""IdContent""",2.2,0,
" The rule is checking if the value of the version attribute in XML declaration is ""1.0"". If it's not, an error will be given.","self.version() = ""1.0""",2.2,0,
" The example rule checks whether any element within the header contains value ""2015"".", self.xmlData.contains() = 2015,2.2,,
The example rule checks the combined lenght of element values from PartyIdentification child elements.,self.xmlDataSize() = 24,2.2,1,
The example rule checks the lenght of PartyIdentification content including tags and values.,self.xmlElementBlockSize() = 17,2.2,1,
" The example rule compares value of <Id> element to a string ""IdContent"".","self.Id = ""IdContent""",2.2,0,
" The example rule compares value of <Id> element to a string ""IdContent"". The value is expected to be different from the string, otherwise an error will be returned by the rule.
 ","self.Id <> ""IdContent""",2.2,0,
" Compares the value of ControlSum against the sum of values in Transaction, which is defined to be in collection type bag.","self.Header.ControlSum =
self.Transaction->asBag().Amount->sum()",2.2,,
" The example rule compares the integer quotient of the division of the <Id> and 9 to the integer 3. If the integer quotient is 3, true will be returned. Notice the syntax is different from the normal syntax of methods. 
",self.Id.toInteger() div 9 = 3,2.2,,
 The example rule mandates the usage of both Creditor and Debtor name when Amount exceeds 200,"self.Amount > 200 implies

self.Debtor.Name->size() = 1 and self.Creditor.Name->size() = 1",2.2,,
" bc is the object c in the instance set of class BankCard. c represents an object of class BankCard, and c meets:
      The attribute CardID of the object c is equal to cardid","   bc:BankCard = BankCard.allInstance()->any(c:BankCard | c.CardID = cardid)
",3,,
" If (bc existed), take the following as postcondition(s):
      The value of temporary variable CardIDValidated became true
      The object InputCard became bc
      The return value was true
  Otherwise, take the following as postcondition(s):
      The value of temporary variable CardIDValidated became false
      The return value was false","   if
    (bc.oclIsUndefined() = false)
   then
    self.CardIDValidated = true and
    self.InputCard = bc and
    result = true
   else
    self.CardIDValidated = false and
    result = false
   endif
",3,,
" The value of temporary variable CardIDValidated is equal to true
  The object InputCard exists","   self.CardIDValidated = true and
   self.InputCard.oclIsUndefined() = false
",3,,
" If the attribute Password of the object InputCard was equal to password, take the following as postcondition(s):
      The value of temporary variable PasswordValidated became true
      The return value was true
  Otherwise, take the following as postcondition(s):
      The value of temporary variable PasswordValidated became false
      The return value was false","   if
    self.InputCard.Password = password
   then
    self.PasswordValidated = true and
    return = true
   else
    self.PasswordValidated = false and
    return = false
   endif
",3,,
" The value of temporary variable CardIDValidated is equal to true
  The value of temporary variable PasswordValidated is equal to true
  The object InputCard exists","   self.CardIDValidated = true and
   self.PasswordValidated = true and
   self.InputCard.oclIsUndefined() = false
",3,,
" If the value of temporary variable IsWithdraw was equal to true, take the following as postcondition(s):
      The return value was the value of temporary variable WithdrawedNumber
  Otherwise, take the following as postcondition(s):
      If the value of temporary variable IsDeposit was equal to true, take the following as postcondition(s):
          The return value was the value of temporary variable DepositedNumber
      Otherwise, take the following as postcondition(s):
          The return value was 0","   if
    self.IsWithdraw = true
   then
    result = self.WithdrawedNumber
   else
    if
     self.IsDeposit = true
    then
     result = self.DepositedNumber
    else
     result = 0
    endif
   endif
",3,,
" The value of temporary variable PasswordValidated is equal to true
  The value of temporary variable CardIDValidated is equal to true
  The object InputCard exists","   self.PasswordValidated = true and
   self.CardIDValidated = true and
   self.InputCard.oclIsUndefined() = false
",3,,
 The return value was the attribute Balance of the object InputCard,"   result = self.InputCard.Balance
",3,,
" The value of temporary variable PasswordValidated is equal to true
  The value of temporary variable CardIDValidated is equal to true
  The object InputCard exists","   self.PasswordValidated = true and
   self.CardIDValidated = true and
   self.InputCard.oclIsUndefined() = false
",3,,
" The object InputCard became null
  The value of temporary variable PasswordValidated became false
  The value of temporary variable CardIDValidated became false
  The value of temporary variable IsWithdraw became false
  The value of temporary variable IsDeposit became false
  The value of temporary variable WithdrawedNumber became 0
  The value of temporary variable DepositedNumber became 0
  The return value was true","   self.InputCard = null and
   self.PasswordValidated = false and
   self.CardIDValidated = false and
   self.IsWithdraw = false and
   self.IsDeposit = false and
   self.WithdrawedNumber = 0 and
   self.DepositedNumber = 0 and
   result = true
",3,,
" The value of temporary variable PasswordValidated is equal to true
  The value of temporary variable CardIDValidated is equal to true
  The object InputCard exists
  The attribute Balance of the object InputCard is greater than or equal to quantity","   self.PasswordValidated = true and
   self.CardIDValidated = true and
   self.InputCard.oclIsUndefined() = false and
   self.InputCard.Balance >= quantity
",3,,
" The attribute Balance of the object InputCard became the previous value of the attribute Balance of the object InputCard minus quantity
  The value of temporary variable WithdrawedNumber became quantity
  The value of temporary variable IsWithdraw became true
  The return value was true","   self.InputCard.Balance = self.InputCard.Balance@pre - quantity and
   self.WithdrawedNumber = quantity and
   self.IsWithdraw = true and
   result = true
",3,,
" The value of temporary variable PasswordValidated is equal to true
  The value of temporary variable CardIDValidated is equal to true
  The object InputCard exists
  The quantity is greater than or equal to 100","   self.PasswordValidated = true and
   self.CardIDValidated = true and
   self.InputCard.oclIsUndefined() = false and
   quantity >= 100
",3,,
" The attribute Balance of the object InputCard became the previous value of the attribute Balance of the object InputCard plus quantity
  The value of temporary variable IsDeposit became true
  The value of temporary variable DepositedNumber became quantity
  The return value was true","   self.InputCard.Balance = self.InputCard.Balance@pre + quantity and
   self.IsDeposit = true and
   self.DepositedNumber = quantity and
   result = true
",3,,
" bankcard is the object ban in the instance set of class BankCard. ban represents an object of class BankCard, and ban meets:
      The attribute CardID of the object ban is equal to cardid","   bankcard:BankCard = BankCard.allInstance()->any(ban:BankCard | ban.CardID = cardid)
",3,,
 bankcard doesn't exist,"   bankcard.oclIsUndefined() = true
",3,,
" ban represented the object of class BankCard
  The object ban was created
  The attribute CardID of the object ban became cardid
  The attribute CardStatus of the object ban became cardstatus
  The attribute Catalog of the object ban became catalog
  The attribute Password of the object ban became password
  The attribute Balance of the object ban became balance
  The object ban was put into the instance set of class BankCard
  The return value was true","   let ban:BankCard in
   ban.oclIsNew() and
   ban.CardID = cardid and
   ban.CardStatus = cardstatus and
   ban.Catalog = catalog and
   ban.Password = password and
   ban.Balance = balance and
   BankCard.allInstance()->includes(ban) and
   result = true
",3,,
" bankcard is the object ban in the instance set of class BankCard. ban represents an object of class BankCard, and ban meets:
      The attribute CardID of the object ban is equal to cardid","   bankcard:BankCard = BankCard.allInstance()->any(ban:BankCard | ban.CardID = cardid)
",3,,
 bankcard exists,"   bankcard.oclIsUndefined() = false
",3,,
 The return value was bankcard,"   result = bankcard
",3,,
" bankcard is the object ban in the instance set of class BankCard. ban represents an object of class BankCard, and ban meets:
      The attribute CardID of the object ban is equal to cardid","   bankcard:BankCard = BankCard.allInstance()->any(ban:BankCard | ban.CardID = cardid)
",3,0 两个冒号无法正常识别,
 bankcard exists,"   bankcard.oclIsUndefined() = false
",3,,
" The attribute CardID of the object bankcard became cardid
  The attribute CardStatus of the object bankcard became cardstatus
  The attribute Catalog of the object bankcard became catalog
  The attribute Password of the object bankcard became password
  The attribute Balance of the object bankcard became balance
  The return value was true","   bankcard.CardID = cardid and
   bankcard.CardStatus = cardstatus and
   bankcard.Catalog = catalog and
   bankcard.Password = password and
   bankcard.Balance = balance and
   result = true
",3,,
" bankcard is the object ban in the instance set of class BankCard. ban represents an object of class BankCard, and ban meets:
      The attribute CardID of the object ban is equal to cardid","   bankcard:BankCard = BankCard.allInstance()->any(ban:BankCard | ban.CardID = cardid)
",3,,
" bankcard exists
  The object bankcard is in the instance set of class BankCard","   bankcard.oclIsUndefined() = false and
   BankCard.allInstance()->includes(bankcard)
",3,,
" The object bankcard was deleted from the instance set of class BankCard
  The return value was true","   BankCard.allInstance()->excludes(bankcard) and
   result = true
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
 user doesn't exist,"   user.oclIsUndefined() = true
",3,,
" use represented the object of class User
  The object use was created
  The attribute UserID of the object use became userid
  The attribute Name of the object use became name
  The attribute Address of the object use became address
  The object use was put into the instance set of class User
  The return value was true","   let use:User in
   use.oclIsNew() and
   use.UserID = userid and
   use.Name = name and
   use.Address = address and
   User.allInstance()->includes(use) and
   result = true
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
 user exists,"   user.oclIsUndefined() = false
",3,,
 The return value was user,"   result = user
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
 user exists,"   user.oclIsUndefined() = false
",3,,
" The attribute UserID of the object user became userid
  The attribute Name of the object user became name
  The attribute Address of the object user became address
  The return value was true","   user.UserID = userid and
   user.Name = name and
   user.Address = address and
   result = true
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
" user exists
  The object user is in the instance set of class User","   user.oclIsUndefined() = false and
   User.allInstance()->includes(user)
",3,,
" The object user was deleted from the instance set of class User
  The return value was true","   User.allInstance()->excludes(user) and
   result = true
",3,,
 The return value was true,"   result = true
",3,,
" sto is the object s in the instance set of class Store. s represents an object of class Store, and s meets:
      The attribute Id of the object s is equal to storeID","   sto:Store = Store.allInstance()->any(s:Store | s.Id = storeID)
",3,,
" sto exists
  The attribute IsOpened of the object sto is equal to false","   sto.oclIsUndefined() = false and
   sto.IsOpened = false
",3,,
" The object currentStore became sto
  The attribute IsOpened of the object sto became true
  The return value was true","   self.currentStore = sto and
   sto.IsOpened = true and
   result = true
",3,,
" sto is the object s in the instance set of class Store. s represents an object of class Store, and s meets:
      The attribute Id of the object s is equal to storeID","   sto:Store = Store.allInstance()->any(s:Store | s.Id = storeID)
",3,0,
" sto exists
  The attribute IsOpened of the object sto is equal to true","   sto.oclIsUndefined() = false and
   sto.IsOpened = true
",3,,
" The attribute IsOpened of the object sto became false
  The return value was true","   sto.IsOpened = false and
   result = true
",3,,
" cd is the object s in the instance set of class CashDesk. s represents an object of class CashDesk, and s meets:
      The attribute Id of the object s is equal to cashDeskID","   cd:CashDesk = CashDesk.allInstance()->any(s:CashDesk | s.Id = cashDeskID)
",3,,
" cd exists
  The attribute IsOpened of the object cd is equal to false
  currentStore exists
  The attribute IsOpened of the object currentStore is equal to true","   cd.oclIsUndefined() = false and
   cd.IsOpened = false and
   currentStore.oclIsUndefined() = false and
   currentStore.IsOpened = true
",3,,
" The object currentCashDesk became cd
  The attribute IsOpened of the object cd became true
  The return value was true","   self.currentCashDesk = cd and
   cd.IsOpened = true and
   result = true
",3,,
" cd is the object s in the instance set of class CashDesk. s represents an object of class CashDesk, and s meets:
      The attribute Id of the object s is equal to cashDeskID","   cd:CashDesk = CashDesk.allInstance()->any(s:CashDesk | s.Id = cashDeskID)
",3,,
" cd exists
  The attribute IsOpened of the object cd is equal to true
  currentStore exists
  The attribute IsOpened of the object currentStore is equal to true","   cd.oclIsUndefined() = false and
   cd.IsOpened = true and
   currentStore.oclIsUndefined() = false and
   currentStore.IsOpened = true
",3,,
" The object currentCashDesk became cd
  The attribute IsOpened of the object cd became false
  The return value was true","   self.currentCashDesk = cd and
   cd.IsOpened = false and
   result = true
",3,,
" currentCashDesk exists
  The attribute IsOpened of the object currentCashDesk is equal to true
  (currentSale doesn't exist, or (currentSale exists, and the attribute IsComplete of the object currentSale is equal to true))","   currentCashDesk.oclIsUndefined() = false and
   currentCashDesk.IsOpened = true and
   (currentSale.oclIsUndefined() = true or
    (currentSale.oclIsUndefined() = false and
     currentSale.IsComplete = true
    )
   )
",3,,
" s represented the object of class Sale
  The object s was created
  The object s was linked to the object currentCashDesk by BelongedCashDesk
  The object currentCashDesk was linked to the object s by ContainedSales
  The attribute IsComplete of the object s became false
  The attribute IsReadytoPay of the object s became false
  The object s was put into the instance set of class Sale
  The object currentSale became s
  The return value was true","   let s:Sale in
   s.oclIsNew() and
   s.BelongedCashDesk = currentCashDesk and
   currentCashDesk.ContainedSales->includes(s) and
   s.IsComplete = false and
   s.IsReadytoPay = false and
   Sale.allInstance()->includes(s) and
   self.currentSale = s and
   result = true
",3,0,
" item is the object i in the instance set of class Item. i represents an object of class Item, and i meets:
      The attribute Barcode of the object i is equal to barcode","   item:Item = Item.allInstance()->any(i:Item | i.Barcode = barcode)
",3,0,
" currentSale exists
  The attribute IsComplete of the object currentSale is equal to false
  item exists
  The attribute StockNumber of the object item is greater than 0","   currentSale.oclIsUndefined() = false and
   currentSale.IsComplete = false and
   item.oclIsUndefined() = false and
   item.StockNumber > 0
",3,,
" sli represented the object of class SalesLineItem
  The object sli was created
  The object currentSaleLine became sli
  The object sli was linked to the object currentSale by BelongedSale
  The object currentSale was linked to the object sli by ContainedSalesLine
  The attribute Quantity of the object sli became quantity
  The object sli was linked to the object item by BelongedItem
  The attribute StockNumber of the object item became the previous value of the attribute StockNumber of the object item minus quantity
  The attribute Subamount of the object sli became the attribute Price of the object item times quantity
  The object sli was put into the instance set of class SalesLineItem
  The return value was true","   let sli:SalesLineItem in
   sli.oclIsNew() and
   self.currentSaleLine = sli and
   sli.BelongedSale = currentSale and
   currentSale.ContainedSalesLine->includes(sli) and
   sli.Quantity = quantity and
   sli.BelongedItem = item and
   item.StockNumber = item.StockNumber@pre - quantity and
   sli.Subamount = item.Price * quantity and
   SalesLineItem.allInstance()->includes(sli) and
   result = true
",3,0 @符号无法正常识别,
" sls is the Set of class SalesLineItem, including  which currentSale is linked to
  sub is the Set of Real, including the Subamount of each object in the set sls","   sls:Set(SalesLineItem) = currentSale.ContainedSalesLine,
   sub:Set(Real) = sls->collect(s:SalesLineItem | s.Subamount)
",3,,
" currentSale exists
  The attribute IsComplete of the object currentSale is equal to false
  The attribute IsReadytoPay of the object currentSale is equal to false","   currentSale.oclIsUndefined() = false and
   currentSale.IsComplete = false and
   currentSale.IsReadytoPay = false
",3,,
" The attribute Amount of the object currentSale became the sum of sub
  The attribute IsReadytoPay of the object currentSale became true
  The return value was the attribute Amount of the object currentSale","   currentSale.Amount = sub.sum() and
   currentSale.IsReadytoPay = true and
   result = currentSale.Amount
",3,,
" currentSale exists
  The attribute IsComplete of the object currentSale is equal to false
  The attribute IsReadytoPay of the object currentSale is equal to true
  The amount is greater than or equal to the attribute Amount of the object currentSale","   currentSale.oclIsUndefined() = false and
   currentSale.IsComplete = false and
   currentSale.IsReadytoPay = true and
   amount >= currentSale.Amount
",3,,
" cp represented the object of class CashPayment
  The object cp was created
  The attribute AmountTendered of the object cp became amount
  The object cp was linked to the object currentSale by BelongedSale
  The object currentSale was linked to the object cp by AssoicatedPayment
  The object currentSale was linked to the object currentStore by Belongedstore
  The object currentStore was linked to the object currentSale by Sales
  The attribute IsComplete of the object currentSale became true
  The attribute Time of the object currentSale was equal to Now
  The attribute Balance of the object cp became amount minus the attribute Amount of the object currentSale
  The object cp was put into the instance set of class CashPayment
  The return value was true","   let cp:CashPayment in
   cp.oclIsNew() and
   cp.AmountTendered = amount and
   cp.BelongedSale = currentSale and
   currentSale.AssoicatedPayment = cp and
   currentSale.Belongedstore = currentStore and
   currentStore.Sales->includes(currentSale) and
   currentSale.IsComplete = true and
   currentSale.Time.isEqual(Now) and
   cp.Balance = amount - currentSale.Amount and
   CashPayment.allInstance()->includes(cp) and
   result = true
",3,,
" currentSale exists
  The attribute IsComplete of the object currentSale is equal to false
  The attribute IsReadytoPay of the object currentSale is equal to true
  The system operation thirdPartyCardPaymentService is executed","   currentSale.oclIsUndefined() = false and
   currentSale.IsComplete = false and
   currentSale.IsReadytoPay = true and
   thirdPartyCardPaymentService(cardAccountNumber, expiryDate, fee)
",3,,
" cdp represented the object of class CardPayment
  The object cdp was created
  The attribute AmountTendered of the object cdp became fee
  The object cdp was linked to the object currentSale by BelongedSale
  The object currentSale was linked to the object cdp by AssoicatedPayment
  The attribute CardAccountNumber of the object cdp became cardAccountNumber
  The attribute ExpiryDate of the object cdp became expiryDate
  The object cdp was put into the instance set of class CardPayment
  The object currentSale was linked to the object currentStore by Belongedstore
  The object currentStore was linked to the object currentSale by Sales
  The attribute IsComplete of the object currentSale became true
  The attribute Time of the object currentSale was equal to Now
  The return value was true","   let cdp:CardPayment in
   cdp.oclIsNew() and
   cdp.AmountTendered = fee and
   cdp.BelongedSale = currentSale and
   currentSale.AssoicatedPayment = cdp and
   cdp.CardAccountNumber = cardAccountNumber and
   cdp.ExpiryDate = expiryDate and
   CardPayment.allInstance()->includes(cdp) and
   currentSale.Belongedstore = currentStore and
   currentStore.Sales->includes(currentSale) and
   currentSale.IsComplete = true and
   currentSale.Time.isEqual(Now) and
   result = true
",3,,
 The return value was true,"   result = true
",3,,
" op represented the object of class OrderProduct
  The object op was created
  The attribute OrderStatus of the object op became NEW
  The attribute Id of the object op became orderid
  The attribute Time of the object op was equal to Now
  The object op was put into the instance set of class OrderProduct
  The object currentOrderProduct became op
  The return value was true","   let op:OrderProduct in
   op.oclIsNew() and
   op.OrderStatus = OrderStatus::NEW and
   op.Id = orderid and
   op.Time.isEqual(Now) and
   OrderProduct.allInstance()->includes(op) and
   self.currentOrderProduct = op and
   result = true
",3,,
" The return value was the set of class Item, including all item in the instance set of class Item. item represented an object of class Item, and item meet:
      The attribute StockNumber of the object item was equal to 0","   result = Item.allInstance()->select(item:Item | item.StockNumber = 0)
",3,,
" item is the object i in the instance set of class Item. i represents an object of class Item, and i meets:
      The attribute Barcode of the object i is equal to barcode","   item:Item = Item.allInstance()->any(i:Item | i.Barcode = barcode)
",3,,
 item exists,"   item.oclIsUndefined() = false
",3,,
" order represented the object of class OrderEntry
  The object order was created
  The attribute Quantity of the object order became quantity
  The attribute subAmount of the object order became the attribute OrderPrice of the object item times quantity
  The object order was linked to the object item by Item
  The object order was put into the instance set of class OrderEntry
  The object currentOrderProduct was linked to the object order by ContainedEntries
  The return value was true","   let order:OrderEntry in
   order.oclIsNew() and
   order.Quantity = quantity and
   order.subAmount = item.OrderPrice * quantity and
   order.Item = item and
   OrderEntry.allInstance()->includes(order) and
   currentOrderProduct.ContainedEntries->includes(order) and
   result = true
",3,,
" sup is the object s in the instance set of class Supplier. s represents an object of class Supplier, and s meets:
      The attribute Id of the object s is equal to supplierID","   sup:Supplier = Supplier.allInstance()->any(s:Supplier | s.Id = supplierID)
",3,,
" sup exists
  currentOrderProduct exists","   sup.oclIsUndefined() = false and
   currentOrderProduct.oclIsUndefined() = false
",3,,
" The object currentOrderProduct was linked to the object sup by Supplier
  The return value was true","   currentOrderProduct.Supplier = sup and
   result = true
",3,,
 currentOrderProduct exists,"   currentOrderProduct.oclIsUndefined() = false
",3,,
" The attribute OrderStatus of the object currentOrderProduct became REQUESTED
  For each object of class OrderEntry in all objects which currentOrderProduct was linked to by ContainedEntries, o represented it(the object) and the following operations were performed:
      The attribute Amount of the object currentOrderProduct was equal to the previous value of the attribute Amount of the object currentOrderProduct plus the attribute SubAmount of the object o
  The return value was true","   currentOrderProduct.OrderStatus = OrderStatus::REQUESTED and
   currentOrderProduct.ContainedEntries->forAll(o:OrderEntry |
    currentOrderProduct.Amount = currentOrderProduct.Amount@pre + o.SubAmount)
   and
   result = true
",3,,
" item is the object i in the instance set of class Item. i represents an object of class Item, and i meets:
      The attribute Barcode of the object i is equal to barcode","   item:Item = Item.allInstance()->any(i:Item | i.Barcode = barcode)
",3,,
 item exists,"   item.oclIsUndefined() = false
",3,,
" The attribute Price of the object item became newPrice
  The return value was true","   item.Price = newPrice and
   result = true
",3,,
" op is the object i in the instance set of class OrderProduct. i represents an object of class OrderProduct, and i meets:
      The attribute Id of the object i is equal to orderID","   op:OrderProduct = OrderProduct.allInstance()->any(i:OrderProduct | i.Id = orderID)
",3,,
 op exists,"   op.oclIsUndefined() = false
",3,,
" The attribute OrderStatus of the object op became RECEIVED
  For each object of class OrderEntry in all objects which op was linked to by ContainedEntries, oe represented it(the object) and the following operations were performed:
      The attribute StockNumber of the object oe was equal to the previous value of the attribute StockNumber of the object oe plus the attribute Quantity of the object oe
  The return value was true","   op.OrderStatus = OrderStatus::RECEIVED and
   op.ContainedEntries->forAll(oe:OrderEntry |
    oe.Item.StockNumber = oe.Item.StockNumber@pre + oe.Quantity)
   and
   result = true
",3,,
 The return value was the instance set of class Supplier,"   result = Supplier.allInstance()
",3,,
 The return value was the instance set of class Item,"   result = Item.allInstance()
",3,,
" store is the object sto in the instance set of class Store. sto represents an object of class Store, and sto meets:
      The attribute Id of the object sto is equal to id","   store:Store = Store.allInstance()->any(sto:Store | sto.Id = id)
",3,,
 store doesn't exist,"   store.oclIsUndefined() = true
",3,,
" sto represented the object of class Store
  The object sto was created
  The attribute Id of the object sto became id
  The attribute Name of the object sto became name
  The attribute Address of the object sto became address
  The attribute IsOpened of the object sto became isopened
  The object sto was put into the instance set of class Store
  The return value was true","   let sto:Store in
   sto.oclIsNew() and
   sto.Id = id and
   sto.Name = name and
   sto.Address = address and
   sto.IsOpened = isopened and
   Store.allInstance()->includes(sto) and
   result = true
",3,,
" store is the object sto in the instance set of class Store. sto represents an object of class Store, and sto meets:
      The attribute Id of the object sto is equal to id","   store:Store = Store.allInstance()->any(sto:Store | sto.Id = id)
",3,,
 store exists,"   store.oclIsUndefined() = false
",3,,
 The return value was store,"   result = store
",3,,
" store is the object sto in the instance set of class Store. sto represents an object of class Store, and sto meets:
      The attribute Id of the object sto is equal to id","   store:Store = Store.allInstance()->any(sto:Store | sto.Id = id)
",3,,
 store exists,"   store.oclIsUndefined() = false
",3,,
" The attribute Id of the object store became id
  The attribute Name of the object store became name
  The attribute Address of the object store became address
  The attribute IsOpened of the object store became isopened
  The return value was true","   store.Id = id and
   store.Name = name and
   store.Address = address and
   store.IsOpened = isopened and
   result = true
",3,,
" store is the object sto in the instance set of class Store. sto represents an object of class Store, and sto meets:
      The attribute Id of the object sto is equal to id","   store:Store = Store.allInstance()->any(sto:Store | sto.Id = id)
",3,,
" store exists
  The object store is in the instance set of class Store","   store.oclIsUndefined() = false and
   Store.allInstance()->includes(store)
",3,,
" The object store was deleted from the instance set of class Store
  The return value was true","   Store.allInstance()->excludes(store) and
   result = true
",3,,
" productcatalog is the object pro in the instance set of class ProductCatalog. pro represents an object of class ProductCatalog, and pro meets:
      The attribute Id of the object pro is equal to id","   productcatalog:ProductCatalog = ProductCatalog.allInstance()->any(pro:ProductCatalog | pro.Id = id)
",3,,
 productcatalog doesn't exist,"   productcatalog.oclIsUndefined() = true
",3,,
" pro represented the object of class ProductCatalog
  The object pro was created
  The attribute Id of the object pro became id
  The attribute Name of the object pro became name
  The object pro was put into the instance set of class ProductCatalog
  The return value was true","   let pro:ProductCatalog in
   pro.oclIsNew() and
   pro.Id = id and
   pro.Name = name and
   ProductCatalog.allInstance()->includes(pro) and
   result = true
",3,,
" productcatalog is the object pro in the instance set of class ProductCatalog. pro represents an object of class ProductCatalog, and pro meets:
      The attribute Id of the object pro is equal to id","   productcatalog:ProductCatalog = ProductCatalog.allInstance()->any(pro:ProductCatalog | pro.Id = id)
",3,,
 productcatalog exists,"   productcatalog.oclIsUndefined() = false
",3,,
 The return value was productcatalog,"   result = productcatalog
",3,,
" productcatalog is the object pro in the instance set of class ProductCatalog. pro represents an object of class ProductCatalog, and pro meets:
      The attribute Id of the object pro is equal to id","   productcatalog:ProductCatalog = ProductCatalog.allInstance()->any(pro:ProductCatalog | pro.Id = id)
",3,,
 productcatalog exists,"   productcatalog.oclIsUndefined() = false
",3,,
" The attribute Id of the object productcatalog became id
  The attribute Name of the object productcatalog became name
  The return value was true","   productcatalog.Id = id and
   productcatalog.Name = name and
   result = true
",3,,
" productcatalog is the object pro in the instance set of class ProductCatalog. pro represents an object of class ProductCatalog, and pro meets:
      The attribute Id of the object pro is equal to id","   productcatalog:ProductCatalog = ProductCatalog.allInstance()->any(pro:ProductCatalog | pro.Id = id)
",3,,
" productcatalog exists
  The object productcatalog is in the instance set of class ProductCatalog","   productcatalog.oclIsUndefined() = false and
   ProductCatalog.allInstance()->includes(productcatalog)
",3,,
" The object productcatalog was deleted from the instance set of class ProductCatalog
  The return value was true","   ProductCatalog.allInstance()->excludes(productcatalog) and
   result = true
",3,,
" cashdesk is the object cas in the instance set of class CashDesk. cas represents an object of class CashDesk, and cas meets:
      The attribute Id of the object cas is equal to id","   cashdesk:CashDesk = CashDesk.allInstance()->any(cas:CashDesk | cas.Id = id)
",3,,
 cashdesk doesn't exist,"   cashdesk.oclIsUndefined() = true
",3,,
" cas represented the object of class CashDesk
  The object cas was created
  The attribute Id of the object cas became id
  The attribute Name of the object cas became name
  The attribute IsOpened of the object cas became isopened
  The object cas was put into the instance set of class CashDesk
  The return value was true","   let cas:CashDesk in
   cas.oclIsNew() and
   cas.Id = id and
   cas.Name = name and
   cas.IsOpened = isopened and
   CashDesk.allInstance()->includes(cas) and
   result = true
",3,,
" cashdesk is the object cas in the instance set of class CashDesk. cas represents an object of class CashDesk, and cas meets:
      The attribute Id of the object cas is equal to id","   cashdesk:CashDesk = CashDesk.allInstance()->any(cas:CashDesk | cas.Id = id)
",3,,
 cashdesk exists,"   cashdesk.oclIsUndefined() = false
",3,,
 The return value was cashdesk,"   result = cashdesk
",3,,
" cashdesk is the object cas in the instance set of class CashDesk. cas represents an object of class CashDesk, and cas meets:
      The attribute Id of the object cas is equal to id","   cashdesk:CashDesk = CashDesk.allInstance()->any(cas:CashDesk | cas.Id = id)
",3,,
 cashdesk exists,"   cashdesk.oclIsUndefined() = false
",3,,
" The attribute Id of the object cashdesk became id
  The attribute Name of the object cashdesk became name
  The attribute IsOpened of the object cashdesk became isopened
  The return value was true","   cashdesk.Id = id and
   cashdesk.Name = name and
   cashdesk.IsOpened = isopened and
   result = true
",3,,
" cashdesk is the object cas in the instance set of class CashDesk. cas represents an object of class CashDesk, and cas meets:
      The attribute Id of the object cas is equal to id","   cashdesk:CashDesk = CashDesk.allInstance()->any(cas:CashDesk | cas.Id = id)
",3,,
" cashdesk exists
  The object cashdesk is in the instance set of class CashDesk","   cashdesk.oclIsUndefined() = false and
   CashDesk.allInstance()->includes(cashdesk)
",3,,
" The object cashdesk was deleted from the instance set of class CashDesk
  The return value was true","   CashDesk.allInstance()->excludes(cashdesk) and
   result = true
",3,,
" cashier is the object cas in the instance set of class Cashier. cas represents an object of class Cashier, and cas meets:
      The attribute Id of the object cas is equal to id","   cashier:Cashier = Cashier.allInstance()->any(cas:Cashier | cas.Id = id)
",3,,
 cashier doesn't exist,"   cashier.oclIsUndefined() = true
",3,,
" cas represented the object of class Cashier
  The object cas was created
  The attribute Id of the object cas became id
  The attribute Name of the object cas became name
  The object cas was put into the instance set of class Cashier
  The return value was true","   let cas:Cashier in
   cas.oclIsNew() and
   cas.Id = id and
   cas.Name = name and
   Cashier.allInstance()->includes(cas) and
   result = true
",3,0,
" cashier is the object cas in the instance set of class Cashier. cas represents an object of class Cashier, and cas meets:
      The attribute Id of the object cas is equal to id","   cashier:Cashier = Cashier.allInstance()->any(cas:Cashier | cas.Id = id)
",3,,
 cashier exists,"   cashier.oclIsUndefined() = false
",3,,
 The return value was cashier,"   result = cashier
",3,,
" cashier is the object cas in the instance set of class Cashier. cas represents an object of class Cashier, and cas meets:
      The attribute Id of the object cas is equal to id","   cashier:Cashier = Cashier.allInstance()->any(cas:Cashier | cas.Id = id)
",3,,
 cashier exists,"   cashier.oclIsUndefined() = false
",3,,
" The attribute Id of the object cashier became id
  The attribute Name of the object cashier became name
  The return value was true","   cashier.Id = id and
   cashier.Name = name and
   result = true
",3,,
" cashier is the object cas in the instance set of class Cashier. cas represents an object of class Cashier, and cas meets:
      The attribute Id of the object cas is equal to id","   cashier:Cashier = Cashier.allInstance()->any(cas:Cashier | cas.Id = id)
",3,,
" cashier exists
  The object cashier is in the instance set of class Cashier","   cashier.oclIsUndefined() = false and
   Cashier.allInstance()->includes(cashier)
",3,,
" The object cashier was deleted from the instance set of class Cashier
  The return value was true","   Cashier.allInstance()->excludes(cashier) and
   result = true
",3,,
" item is the object ite in the instance set of class Item. ite represents an object of class Item, and ite meets:
      The attribute Barcode of the object ite is equal to barcode","   item:Item = Item.allInstance()->any(ite:Item | ite.Barcode = barcode)
",3,,
 item doesn't exist,"   item.oclIsUndefined() = true
",3,,
" ite represented the object of class Item
  The object ite was created
  The attribute Barcode of the object ite became barcode
  The attribute Name of the object ite became name
  The attribute Price of the object ite became price
  The attribute StockNumber of the object ite became stocknumber
  The attribute OrderPrice of the object ite became orderprice
  The object ite was put into the instance set of class Item
  The return value was true","   let ite:Item in
   ite.oclIsNew() and
   ite.Barcode = barcode and
   ite.Name = name and
   ite.Price = price and
   ite.StockNumber = stocknumber and
   ite.OrderPrice = orderprice and
   Item.allInstance()->includes(ite) and
   result = true
",3,,
" item is the object ite in the instance set of class Item. ite represents an object of class Item, and ite meets:
      The attribute Barcode of the object ite is equal to barcode","   item:Item = Item.allInstance()->any(ite:Item | ite.Barcode = barcode)
",3,,
 item exists,"   item.oclIsUndefined() = false
",3,,
 The return value was item,"   result = item
",3,,
" item is the object ite in the instance set of class Item. ite represents an object of class Item, and ite meets:
      The attribute Barcode of the object ite is equal to barcode","   item:Item = Item.allInstance()->any(ite:Item | ite.Barcode = barcode)
",3,,
 item exists,"   item.oclIsUndefined() = false
",3,,
" The attribute Barcode of the object item became barcode
  The attribute Name of the object item became name
  The attribute Price of the object item became price
  The attribute StockNumber of the object item became stocknumber
  The attribute OrderPrice of the object item became orderprice
  The return value was true","   item.Barcode = barcode and
   item.Name = name and
   item.Price = price and
   item.StockNumber = stocknumber and
   item.OrderPrice = orderprice and
   result = true
",3,,
" item is the object ite in the instance set of class Item. ite represents an object of class Item, and ite meets:
      The attribute Barcode of the object ite is equal to barcode","   item:Item = Item.allInstance()->any(ite:Item | ite.Barcode = barcode)
",3,,
" item exists
  The object item is in the instance set of class Item","   item.oclIsUndefined() = false and
   Item.allInstance()->includes(item)
",3,,
" The object item was deleted from the instance set of class Item
  The return value was true","   Item.allInstance()->excludes(item) and
   result = true
",3,,
" supplier is the object sup in the instance set of class Supplier. sup represents an object of class Supplier, and sup meets:
      The attribute Id of the object sup is equal to id","   supplier:Supplier = Supplier.allInstance()->any(sup:Supplier | sup.Id = id)
",3,,
 supplier doesn't exist,"   supplier.oclIsUndefined() = true
",3,,
" sup represented the object of class Supplier
  The object sup was created
  The attribute Id of the object sup became id
  The attribute Name of the object sup became name
  The object sup was put into the instance set of class Supplier
  The return value was true","   let sup:Supplier in
   sup.oclIsNew() and
   sup.Id = id and
   sup.Name = name and
   Supplier.allInstance()->includes(sup) and
   result = true
",3,,
" supplier is the object sup in the instance set of class Supplier. sup represents an object of class Supplier, and sup meets:
      The attribute Id of the object sup is equal to id","   supplier:Supplier = Supplier.allInstance()->any(sup:Supplier | sup.Id = id)
",3,,
 supplier exists,"   supplier.oclIsUndefined() = false
",3,,
 The return value was supplier,"   result = supplier
",3,,
" supplier is the object sup in the instance set of class Supplier. sup represents an object of class Supplier, and sup meets:
      The attribute Id of the object sup is equal to id","   supplier:Supplier = Supplier.allInstance()->any(sup:Supplier | sup.Id = id)
",3,,
 supplier exists,"   supplier.oclIsUndefined() = false
",3,,
" The attribute Id of the object supplier became id
  The attribute Name of the object supplier became name
  The return value was true","   supplier.Id = id and
   supplier.Name = name and
   result = true
",3,,
" supplier is the object sup in the instance set of class Supplier. sup represents an object of class Supplier, and sup meets:
      The attribute Id of the object sup is equal to id","   supplier:Supplier = Supplier.allInstance()->any(sup:Supplier | sup.Id = id)
",3,,
" supplier exists
  The object supplier is in the instance set of class Supplier","   supplier.oclIsUndefined() = false and
   Supplier.allInstance()->includes(supplier)
",3,,
" The object supplier was deleted from the instance set of class Supplier
  The return value was true","   Supplier.allInstance()->excludes(supplier) and
   result = true
",3,,
 The type of parameter barcode is equal to String,"   barcode.oclIsTypeOf(String)
",3,,
" The return value was the set of class Book, including all book in the instance set of class Book. book represented an object of class Book, and book meet:
      At least one c existed in all objects which book was linked to by Copys. c represented an object of class BookCopy, and c meet:
          The attribute Barcode of the object c was equal to barcode","   result = Book.allInstance()->select(book:Book | book.Copys->exists(c:BookCopy | c.Barcode = barcode))
",3,,
 The title is not equal to null,"   title <> """"
",3,,
" The return value was the set of class Book, including all book in the instance set of class Book. book represented an object of class Book, and book meet:
      The attribute Title of the object book was equal to title","   result = Book.allInstance()->select(book:Book | book.Title = title)
",3,,
 The authorname is not equal to null,"   authorname <> """"
",3,,
" The return value was the set of class Book, including all book in the instance set of class Book. book represented an object of class Book, and book meet:
      The attribute Author of the object book was equal to authorname","   result = Book.allInstance()->select(book:Book | book.Author = authorname)
",3,,
 The type of parameter iSBNnumber is equal to String,"   iSBNnumber.oclIsTypeOf(String)
",3,,
" The return value was the set of class Book, including all book in the instance set of class Book. book represented an object of class Book, and book meet:
      The attribute ISBn of the object book was equal to iSBNnumber","   result = Book.allInstance()->select(book:Book | book.ISBn = iSBNnumber)
",3,,
 The type of parameter subject is equal to String,"   subject.oclIsTypeOf(String)
",3,,
" The return value was the set of class Book, including all book in the instance set of class Book. book represented an object of class Book, and book meet:
      At least one s existed in all objects which book was linked to by Subject. s represented an object of class Subject, and s meet:
          The attribute Name of the object s was equal to subject","   result = Book.allInstance()->select(book:Book | book.Subject->exists(s:Subject | s.Name = subject))
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  copy is the object bc in the instance set of class BookCopy. bc represents an object of class BookCopy, and bc meets:
      The attribute Barcode of the object bc is equal to barcode","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   copy:BookCopy = BookCopy.allInstance()->any(bc:BookCopy | bc.Barcode = barcode)
",3,,
" user exists
  copy exists
  The attribute Status of the object copy is equal to LOANED
  The attribute IsReserved of the object copy is equal to false","   user.oclIsUndefined() = false and
   copy.oclIsUndefined() = false and
   copy.Status = CopyStatus::LOANED and
   copy.IsReserved = false
",3,,
" res represented the object of class Reserve
  The object res was created
  The attribute IsReserved of the object copy became true
  The attribute IsReserveClosed of the object res became false
  The attribute ReserveDate of the object res was equal to Today
  The object res was linked to the object user by ReservedUser
  The object res was linked to the object copy by ReservedCopy
  The object user was linked to the object res by ReservedBook
  The object copy was linked to the object res by ReservationRecord
  The object res was put into the instance set of class Reserve
  The return value was true","   let res:Reserve in
   res.oclIsNew() and
   copy.IsReserved = true and
   res.IsReserveClosed = false and
   res.ReserveDate.isEqual(Today) and
   res.ReservedUser = user and
   res.ReservedCopy = copy and
   user.ReservedBook->includes(res) and
   copy.ReservationRecord->includes(res) and
   Reserve.allInstance()->includes(res) and
   result = true
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  copy is the object bc in the instance set of class BookCopy. bc represents an object of class BookCopy, and bc meets:
      The attribute Barcode of the object bc is equal to barcode
  res is the object r in the instance set of class Reserve. r represents an object of class Reserve, and r meets:
      The object r is linked to the object copy by ReservedCopy
      The object r is linked to the object user by ReservedUser","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   copy:BookCopy = BookCopy.allInstance()->any(bc:BookCopy | bc.Barcode = barcode),
   res:Reserve = Reserve.allInstance()->any(r:Reserve | r.ReservedCopy = copy and r.ReservedUser = user)
",3,,
" user exists
  copy exists
  The attribute Status of the object copy is equal to LOANED
  The attribute IsReserved of the object copy is equal to true
  res exists
  The attribute IsReserveClosed of the object res is equal to false","   user.oclIsUndefined() = false and
   copy.oclIsUndefined() = false and
   copy.Status = CopyStatus::LOANED and
   copy.IsReserved = true and
   res.oclIsUndefined() = false and
   res.IsReserveClosed = false
",3,,
" The attribute IsReserved of the object copy became false
  The attribute IsReserveClosed of the object res became true
  The return value was true","   copy.IsReserved = false and
   res.IsReserveClosed = true and
   result = true
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  stu is the object s in the instance set of class Student. s represents an object of class Student, and s meets:
      The attribute UserID of the object s is equal to uid
  fac is the object f in the instance set of class Faculty. f represents an object of class Faculty, and f meets:
      The attribute UserID of the object f is equal to uid
  copy is the object bc in the instance set of class BookCopy. bc represents an object of class BookCopy, and bc meets:
      The attribute Barcode of the object bc is equal to barcode
  res is the object r in the instance set of class Reserve. r represents an object of class Reserve, and r meets:
      The object r is linked to the object copy by ReservedCopy
      The object r is linked to the object user by ReservedUser
      The attribute IsReserveClosed of the object r is equal to false","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   stu:Student = Student.allInstance()->any(s:Student | s.UserID = uid),
   fac:Faculty = Faculty.allInstance()->any(f:Faculty | f.UserID = uid),
   copy:BookCopy = BookCopy.allInstance()->any(bc:BookCopy | bc.Barcode = barcode),
   res:Reserve = Reserve.allInstance()->any(r:Reserve | r.ReservedCopy = copy and r.ReservedUser = user and r.IsReserveClosed = false)
",3,,
" user exists
  copy exists
  The attribute BorrowStatus of the object user is equal to NORMAL
  The attribute SuspensionDays of the object user is equal to 0
  If the type of parameter user is equal to Student, take the following as precondition(s):
      If the attribute Programme of the object stu is equal to BACHELOR, take the following as precondition(s):
          The attribute LoanedNumber of the object stu is less than 20
      Otherwise, take the following as precondition(s):
          If the attribute Programme of the object stu is equal to MASTER, take the following as precondition(s):
              The attribute LoanedNumber of the object stu is less than 40
          Otherwise, take the following as precondition(s):
              The attribute LoanedNumber of the object stu is less than 60
  Otherwise, take the following as precondition(s):
      The attribute LoanedNumber of the object fac is less than 60
  (the attribute Status of the object copy is equal to AVAILABLE, or (the attribute Status of the object copy is equal to ONHOLDSHELF, and the attribute IsReserved of the object copy is equal to true, and res exists, and the attribute IsReserveClosed of the object res is equal to false))","   user.oclIsUndefined() = false and
   copy.oclIsUndefined() = false and
   user.BorrowStatus = BorrowStatus::NORMAL and
   user.SuspensionDays = 0 and
   if
    user.oclIsTypeOf(Student)
   then
    if
     stu.Programme = Programme::BACHELOR
    then
     stu.LoanedNumber < 20
    else
     if
      stu.Programme = Programme::MASTER
     then
      stu.LoanedNumber < 40
     else
      stu.LoanedNumber < 60
     endif
    endif
   else
    fac.LoanedNumber < 60
   endif and
   (copy.Status = CopyStatus::AVAILABLE or
    (copy.Status = CopyStatus::ONHOLDSHELF and
     copy.IsReserved = true and
     res.oclIsUndefined() = false and
     res.IsReserveClosed = false
    )
   )
",3,,
" loan represented the object of class Loan
  The object loan was created
  The object loan was linked to the object user by LoanedUser
  The object loan was linked to the object copy by LoanedCopy
  The attribute IsReturned of the object loan became false
  The attribute LoanDate of the object loan became Today
  The attribute LoanedNumber of the object user became the previous value of the attribute LoanedNumber of the object user plus 1
  The object user was linked to the object loan by LoanedBook
  The object copy was linked to the object loan by LoanedRecord
  If the type of parameter user was equal to Student, take the following as postcondition(s):
      The attribute DueDate of the object loan became the day 30 days after Today
  Otherwise, take the following as postcondition(s):
      The attribute DueDate of the object loan became the day 60 days after Today
  If the previous value of the attribute Status of the object copy was equal to ONHOLDSHELF, take the following as postcondition(s):
      The attribute IsReserved of the object copy became false
      The attribute IsReserveClosed of the object res became true
  The attribute Status of the object copy became LOANED
  The attribute OverDue3Days of the object loan became false
  The attribute OverDue10Days of the object loan became false
  The attribute OverDue17Days of the object loan became false
  The attribute OverDue31Days of the object loan became false
  The object loan was put into the instance set of class Loan
  The return value was true","   let loan:Loan in
   loan.oclIsNew() and
   loan.LoanedUser = user and
   loan.LoanedCopy = copy and
   loan.IsReturned = false and
   loan.LoanDate = Today and
   user.LoanedNumber = user.LoanedNumber@pre + 1 and
   user.LoanedBook->includes(loan) and
   copy.LoanedRecord->includes(loan) and
   if
    user.oclIsTypeOf(Student)
   then
    loan.DueDate = Today.After(30)
   else
    loan.DueDate = Today.After(60)
   endif and
   if
    copy.Status@pre = CopyStatus::ONHOLDSHELF
   then
    copy.IsReserved = false and
    res.IsReserveClosed = true
   endif and
   copy.Status = CopyStatus::LOANED and
   loan.OverDue3Days = false and
   loan.OverDue10Days = false and
   loan.OverDue17Days = false and
   loan.OverDue31Days = false and
   Loan.allInstance()->includes(loan) and
   result = true
",3,,
" copy is the object bc in the instance set of class BookCopy. bc represents an object of class BookCopy, and bc meets:
      The attribute Barcode of the object bc is equal to barcode
      The attribute Status of the object bc is equal to LOANED
  loan is the object l in the instance set of class Loan. l represents an object of class Loan, and l meets:
      The object l is linked to the object copy by LoanedCopy
      The attribute IsReturned of the object l is equal to false
  loans is the set of class Loan, including all l in the instance set of class Loan. l represents an object of class Loan, and l meets:
      The object l is linked to the object the object which loan is linked to by LoanedUser by LoanedUser
      The attribute IsReturned of the object l is equal to false
      The attribute DueDate of the object l is after Today
  res is the object r in all objects which copy is linked to by ReservationRecord. r represents an object of class Reserve, and r meets:
      The object r is linked to the object copy by ReservedCopy","   copy:BookCopy = BookCopy.allInstance()->any(bc:BookCopy | bc.Barcode = barcode and bc.Status = CopyStatus::LOANED),
   loan:Loan = Loan.allInstance()->any(l:Loan | l.LoanedCopy = copy and l.IsReturned = false),
   loans:Set(Loan) = Loan.allInstance()->select(l:Loan | l.LoanedUser = loan.LoanedUser and l.IsReturned = false and l.DueDate.isAfter(Today)),
   res:Reserve = copy.ReservationRecord->any(r:Reserve | r.ReservedCopy = copy)
",3,,
" copy exists
  loan exists","   copy.oclIsUndefined() = false and
   loan.oclIsUndefined() = false
",3,,
" The attribute LoanedNumber of the object loan became the previous value of the attribute LoanedNumber of the object loan minus 1
  The attribute IsReturned of the object loan became true
  The attribute ReturnDate of the object loan became Today
  If the attribute IsReserved of the object copy was equal to true, take the following as postcondition(s):
      The attribute Status of the object copy became ONHOLDSHELF
      The system operation sendNotificationEmail was executed
  Otherwise, take the following as postcondition(s):
      The attribute Status of the object copy became AVAILABLE
  The return value was true","   loan.LoanedUser.LoanedNumber = loan.LoanedUser.LoanedNumber@pre - 1 and
   loan.IsReturned = true and
   loan.ReturnDate = Today and
   if
    copy.IsReserved = true
   then
    copy.Status = CopyStatus::ONHOLDSHELF and
    sendNotificationEmail(res.ReservedUser.Email)
   else
    copy.Status = CopyStatus::AVAILABLE
   endif and
   result = true
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  stu is the object s in the instance set of class Student. s represents an object of class Student, and s meets:
      The attribute UserID of the object s is equal to uid
  fac is the object f in the instance set of class Faculty. f represents an object of class Faculty, and f meets:
      The attribute UserID of the object f is equal to uid
  copy is the object bc in the instance set of class BookCopy. bc represents an object of class BookCopy, and bc meets:
      The attribute Barcode of the object bc is equal to barcode
      The attribute Status of the object bc is equal to LOANED
  loan is the object l in the instance set of class Loan. l represents an object of class Loan, and l meets:
      The object l is linked to the object user by LoanedUser
      The object l is linked to the object copy by LoanedCopy","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   stu:Student = Student.allInstance()->any(s:Student | s.UserID = uid),
   fac:Faculty = Faculty.allInstance()->any(f:Faculty | f.UserID = uid),
   copy:BookCopy = BookCopy.allInstance()->any(bc:BookCopy | bc.Barcode = barcode and bc.Status = CopyStatus::LOANED),
   loan:Loan = Loan.allInstance()->any(l:Loan | l.LoanedUser = user and l.LoanedCopy = copy)
",3,,
" The attribute BorrowStatus of the object user is equal to NORMAL
  user exists
  copy exists
  loan exists
  The attribute IsReserved of the object copy is equal to false
  The attribute DueDate of the object loan is after Today
  If the type of parameter user is equal to Student, take the following as precondition(s):
      The attribute RenewedTimes of the object loan is less than 3
  Otherwise, take the following as precondition(s):
      The attribute RenewedTimes of the object loan is less than 6
  The attribute OverDueFee of the object loan is equal to 0","   user.BorrowStatus = BorrowStatus::NORMAL and
   user.oclIsUndefined() = false and
   copy.oclIsUndefined() = false and
   loan.oclIsUndefined() = false and
   copy.IsReserved = false and
   loan.DueDate.isAfter(Today) and
   if
    user.oclIsTypeOf(Student)
   then
    loan.RenewedTimes < 3
   else
    loan.RenewedTimes < 6
   endif and
   loan.OverDueFee = 0
",3,,
" The attribute RenewedTimes of the object loan became the previous value of the attribute RenewedTimes of the object loan plus 1
  The attribute RenewDate of the object loan became Today
  If the type of parameter user was equal to Student, take the following as postcondition(s):
      If the attribute Programme of the object stu was equal to BACHELOR, take the following as postcondition(s):
          The attribute DueDate of the object loan became the day 20 days after previous value of the attribute DueDate of the object loan
      Otherwise, take the following as postcondition(s):
          If the attribute Programme of the object stu was equal to MASTER, take the following as postcondition(s):
              The attribute DueDate of the object loan became the day 40 days after previous value of the attribute DueDate of the object loan
          Otherwise, take the following as postcondition(s):
              The attribute DueDate of the object loan became the day 60 days after previous value of the attribute DueDate of the object loan
  Otherwise, take the following as postcondition(s):
      The attribute DueDate of the object loan became the day 60 days after previous value of the attribute DueDate of the object loan
  The return value was true","   loan.RenewedTimes = loan.RenewedTimes@pre + 1 and
   loan.RenewDate = Today and
   if
    user.oclIsTypeOf(Student)
   then
    if
     stu.Programme = Programme::BACHELOR
    then
     loan.DueDate = loan.DueDate@pre.After(20)
    else
     if
      stu.Programme = Programme::MASTER
     then
      loan.DueDate = loan.DueDate@pre.After(40)
     else
      loan.DueDate = loan.DueDate@pre.After(60)
     endif
    endif
   else
    loan.DueDate = loan.DueDate@pre.After(60)
   endif and
   result = true
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  loans is the set of class Loan, including all l in the instance set of class Loan. l represents an object of class Loan, and l meets:
      The object l is linked to the object user by LoanedUser
      The attribute DueDate of the object l is before Today
      The attribute IsReturned of the object l is equal to true
      The attribute OverDueFee of the object l is greater than 0","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   loans:Set(Loan) = Loan.allInstance()->select(l:Loan | l.LoanedUser = user and l.DueDate.isBefore(Today)and l.IsReturned = true and l.OverDueFee > 0)
",3,,
" user exists
  The set loans is not empty
  The fee is greater than or equal to the attribute OverDueFee of the object user","   user.oclIsUndefined() = false and
   loans.notEmpty() and
   fee >= user.OverDueFee
",3,,
" The attribute OverDueFee of the object user became 0
  For each object of class Loan in the set loans, l represented it(the object) and the following operations were performed:
      The attribute OverDueFee of the object l was equal to 0
  The return value was true","   user.OverDueFee = 0 and
   loans->forAll(l:Loan |
    l.OverDueFee = 0)
   and
   result = true
",3,,
" users is the set of class User, including all user in the instance set of class User. user represents an object of class User, and user meets:
      At least one loan exists in all objects which user is linked to by LoanedBook. loan represents an object of class Loan, and loan meets:
          The attribute IsReturned of the object loan is equal to false
          The day 3 days after Today is after the attribute DueDate of the object loan","   users:Set(User) = User.allInstance()->select(user:User | user.LoanedBook->exists(loan:Loan | loan.IsReturned = false and Today.After(3).isAfter(loan.DueDate)))
",3,,
" loans is the set of class Loan, including all loan in the instance set of class Loan. loan represents an object of class Loan, and loan meets:
      The attribute IsReturned of the object loan is equal to false
      The attribute DueDate of the object loan is before Today","   loans:Set(Loan) = Loan.allInstance()->select(loan:Loan | loan.IsReturned = false and loan.DueDate.isBefore(Today))
",3,,
" For each object of class Loan in the set loans, loan represented it(the object) and the following operations were performed:
      The attribute IsReturned of the object loan was equal to false
      If the day 3 days before Today was after the attribute DueDate of the object loan, and the attribute OverDue3Days of the object loan was equal to false, take the following as postcondition(s):
          The attribute BorrowStatus of the object loan became SUSPEND
          The system operation sendNotificationEmail was executed
          The attribute OverDue3Days of the object loan became true
      If the day 10 days before Today was after the attribute DueDate of the object loan, and the attribute OverDue10Days of the object loan was equal to false, take the following as postcondition(s):
          The attribute SuspensionDays of the object loan became the previous value of the attribute SuspensionDays of the object loan plus 14
          The system operation sendNotificationEmail was executed
          The attribute OverDue10Days of the object loan became true
      If the day 17 days before Today was after the attribute DueDate of the object loan, and the attribute OverDue17Days of the object loan was equal to false, take the following as postcondition(s):
          The attribute SuspensionDays of the object loan became the previous value of the attribute SuspensionDays of the object loan plus 30
          The system operation sendNotificationEmail was executed
          The attribute OverDue17Days of the object loan became true
      If the day 31 days before Today was after the attribute DueDate of the object loan, and the attribute OverDue31Days of the object loan was equal to false, take the following as postcondition(s):
          The attribute OverDueFee of the object loan became 60
          The system operation sendNotificationEmail was executed
          The attribute OverDue31Days of the object loan became true
          The attribute OverDueFee of the object loan became the previous value of the attribute OverDueFee of the object loan plus the attribute OverDueFee of the object loan","   loans->forAll(loan:Loan |
    loan.IsReturned = false and
    if
     Today.Before(3).isAfter(loan.DueDate) and
     loan.OverDue3Days = false
    then
     loan.LoanedUser.BorrowStatus = BorrowStatus::SUSPEND and
     sendNotificationEmail(loan.LoanedUser.Email) and
     loan.OverDue3Days = true
    endif and
    if
     Today.Before(10).isAfter(loan.DueDate) and
     loan.OverDue10Days = false
    then
     loan.LoanedUser.SuspensionDays = loan.LoanedUser.SuspensionDays@pre + 14 and
     sendNotificationEmail(loan.LoanedUser.Email) and
     loan.OverDue10Days = true
    endif and
    if
     Today.Before(17).isAfter(loan.DueDate) and
     loan.OverDue17Days = false
    then
     loan.LoanedUser.SuspensionDays = loan.LoanedUser.SuspensionDays@pre + 30 and
     sendNotificationEmail(loan.LoanedUser.Email) and
     loan.OverDue17Days = true
    endif and
    if
     Today.Before(31).isAfter(loan.DueDate) and
     loan.OverDue31Days = false
    then
     loan.OverDueFee = 60 and
     sendNotificationEmail(loan.LoanedUser.Email) and
     loan.OverDue31Days = true and
     loan.LoanedUser.OverDueFee = loan.LoanedUser.OverDueFee@pre + loan.OverDueFee
    endif
   )
",3,,
 None,"   true
",3,,
" For each object of class User in the set users, u represented it(the object) and the following operations were performed:
      The attribute SuspensionDays of the object u was equal to the previous value of the attribute SuspensionDays of the object u minus 1
      If the attribute BorrowStatus of the object u was equal to SUSPEND, and the attribute OverDueFee of the object u was equal to 0, and the attribute SuspensionDays of the object u was equal to 0, take the following as postcondition(s):
          The attribute BorrowStatus of the object u became NORMAL","   users->forAll(u:User |
    u.SuspensionDays = u.SuspensionDays@pre - 1 and
    if
     u.BorrowStatus = BorrowStatus::SUSPEND and
     u.OverDueFee = 0 and
     u.SuspensionDays = 0
    then
     u.BorrowStatus = BorrowStatus::NORMAL
    endif
   )
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid","   user:User = User.allInstance()->any(u:User | u.UserID = uid)
",3,,
 user exists,"   user.oclIsUndefined() = false
  // postcondition: result = user.LoanedBook->collect(l:Loan| l.LoanedCopy)
",3,,
 The return value was the object which user was linked to by LoanedBook,"   result = user.LoanedBook
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid","   user:User = User.allInstance()->any(u:User | u.UserID = uid)
",3,,
 user exists,"   user.oclIsUndefined() = false
",3,,
" The return value was the set of class Loan, including all l in all objects which user was linked to by LoanedBook. l represented an object of class Loan, and l meet:
      The attribute IsReturned of the object l was equal to false","   result = user.LoanedBook->select(l:Loan | l.IsReturned = false)
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  loans is the set of class Loan, including all l in all objects which user is linked to by LoanedBook. l represents an object of class Loan, and l meets:
      The attribute IsReturned of the object l is equal to false
      The attribute OverDueFee of the object l is greater than 0","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   loans:Set(Loan) = user.LoanedBook->select(l:Loan | l.IsReturned = false and l.OverDueFee > 0)
",3,,
" user exists
  loans exists","   user.oclIsUndefined() = false and
   loans.oclIsUndefined() = false
",3,,
 The return value was all objects which each object in the set loans was linked to by LoanedCopy,"   result = loans->collect(l:Loan | l.LoanedCopy)
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  res is the Set of class Reserve, including  which user is linked to","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   res:Set(Reserve) = user.ReservedBook
",3,,
" user exists
  res exists","   user.oclIsUndefined() = false and
   res.oclIsUndefined() = false
",3,,
 The return value was all objects which each object in the set res was linked to by ReservedCopy,"   result = res->collect(r:Reserve | r.ReservedCopy)
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  rBooks is the Set of class RecommendBook, including  which user is linked to","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   rBooks:Set(RecommendBook) = user.RecommendedBook
",3,,
" user exists
  rBooks exists","   user.oclIsUndefined() = false and
   rBooks.oclIsUndefined() = false
",3,,
 The return value was rBooks,"   result = rBooks
",3,,
" user is the object u in the instance set of class User. u represents an object of class User, and u meets:
      The attribute UserID of the object u is equal to uid
  rb is the object r in the instance set of class RecommendBook. r represents an object of class RecommendBook, and r meets:
      The attribute CallNo of the object r is equal to callNo","   user:User = User.allInstance()->any(u:User | u.UserID = uid),
   rb:RecommendBook = RecommendBook.allInstance()->any(r:RecommendBook | r.CallNo = callNo)
",3,,
" user exists
  rb doesn't exist","   user.oclIsUndefined() = false and
   rb.oclIsUndefined() = true
",3,,
" r represented the object of class RecommendBook
  The object r was created
  The attribute CallNo of the object r became callNo
  The attribute Title of the object r became title
  The attribute Edition of the object r became edition
  The attribute Author of the object r became author
  The attribute Publisher of the object r became publisher
  The attribute Description of the object r became description
  The attribute ISBn of the object r became isbn
  The attribute RecommendDate of the object r became Today
  The object r was linked to the object user by RecommendUser
  The object user was linked to the object r by RecommendedBook
  The object r was put into the instance set of class RecommendBook
  The return value was true","   let r:RecommendBook in
   r.oclIsNew() and
   r.CallNo = callNo and
   r.Title = title and
   r.Edition = edition and
   r.Author = author and
   r.Publisher = publisher and
   r.Description = description and
   r.ISBn = isbn and
   r.RecommendDate = Today and
   r.RecommendUser = user and
   user.RecommendedBook->includes(r) and
   RecommendBook.allInstance()->includes(r) and
   result = true
",3,,
" user is the object u in the instance set of class Student. u represents an object of class Student, and u meets:
      The attribute UserID of the object u is equal to userID","   user:Student = Student.allInstance()->any(u:Student | u.UserID = userID)
",3,,
 user doesn't exist,"   user.oclIsUndefined() = true
",3,,
" u represented the object of class Student
  The object u was created
  The attribute UserID of the object u became userID
  The attribute Name of the object u became name
  The attribute Email of the object u became email
  The attribute Password of the object u became password
  The attribute Sex of the object u became sex
  The attribute Faculty of the object u became faculty
  The attribute LoanedNumber of the object u became 0
  The attribute BorrowStatus of the object u became NORMAL
  The attribute SuspensionDays of the object u became 0
  The attribute OverDueFee of the object u became 0
  The attribute Major of the object u became major
  The attribute Programme of the object u became programme
  The attribute RegistrationStatus of the object u became registrationStatus
  The object u was put into the instance set of class User
  The object u was put into the instance set of class Student
  The return value was true","   let u:Student in
   u.oclIsNew() and
   u.UserID = userID and
   u.Name = name and
   u.Email = email and
   u.Password = password and
   u.Sex = sex and
   u.Faculty = faculty and
   u.LoanedNumber = 0 and
   u.BorrowStatus = BorrowStatus::NORMAL and
   u.SuspensionDays = 0 and
   u.OverDueFee = 0 and
   u.Major = major and
   u.Programme = programme and
   u.RegistrationStatus = registrationStatus and
   User.allInstance()->includes(u) and
   Student.allInstance()->includes(u) and
   result = true
",3,,
" user is the object u in the instance set of class Student. u represents an object of class Student, and u meets:
      The attribute UserID of the object u is equal to userID","   user:Student = Student.allInstance()->any(u:Student | u.UserID = userID)
",3,,
 user exists,"   user.oclIsUndefined() = false
",3,,
" The attribute UserID of the object user became userID
  The attribute Name of the object user became name
  The attribute Email of the object user became email
  The attribute Password of the object user became password
  The attribute Sex of the object user became sex
  The attribute Faculty of the object user became faculty
  The attribute LoanedNumber of the object user became 0
  The attribute BorrowStatus of the object user became NORMAL
  The attribute SuspensionDays of the object user became 0
  The attribute OverDueFee of the object user became 0
  The attribute Major of the object user became major
  The attribute Programme of the object user became programme
  The attribute RegistrationStatus of the object user became registrationStatus
  The return value was true","   user.UserID = userID and
   user.Name = name and
   user.Email = email and
   user.Password = password and
   user.Sex = sex and
   user.Faculty = faculty and
   user.LoanedNumber = 0 and
   user.BorrowStatus = BorrowStatus::NORMAL and
   user.SuspensionDays = 0 and
   user.OverDueFee = 0 and
   user.Major = major and
   user.Programme = programme and
   user.RegistrationStatus = registrationStatus and
   result = true
",3,,
" user is the object u in the instance set of class Faculty. u represents an object of class Faculty, and u meets:
      The attribute UserID of the object u is equal to userID","   user:Faculty = Faculty.allInstance()->any(u:Faculty | u.UserID = userID)
",3,,
 user doesn't exist,"   user.oclIsUndefined() = true
",3,,
" u represented the object of class Faculty
  The object u was created
  The attribute UserID of the object u became userID
  The attribute Name of the object u became name
  The attribute Email of the object u became email
  The attribute Password of the object u became password
  The attribute Sex of the object u became sex
  The attribute Faculty of the object u became faculty
  The attribute LoanedNumber of the object u became 0
  The attribute BorrowStatus of the object u became NORMAL
  The attribute SuspensionDays of the object u became 0
  The attribute OverDueFee of the object u became 0
  The attribute Position of the object u became position
  The attribute Status of the object u became status
  The object u was put into the instance set of class User
  The object u was put into the instance set of class Faculty
  The return value was true","   let u:Faculty in
   u.oclIsNew() and
   u.UserID = userID and
   u.Name = name and
   u.Email = email and
   u.Password = password and
   u.Sex = sex and
   u.Faculty = faculty and
   u.LoanedNumber = 0 and
   u.BorrowStatus = BorrowStatus::NORMAL and
   u.SuspensionDays = 0 and
   u.OverDueFee = 0 and
   u.Position = position and
   u.Status = status and
   User.allInstance()->includes(u) and
   Faculty.allInstance()->includes(u) and
   result = true
",3,,
" user is the object u in the instance set of class Faculty. u represents an object of class Faculty, and u meets:
      The attribute UserID of the object u is equal to userID","   user:Faculty = Faculty.allInstance()->any(u:Faculty | u.UserID = userID)
",3,,
 user exists,"   user.oclIsUndefined() = false
",3,,
" The attribute UserID of the object user became userID
  The attribute Name of the object user became name
  The attribute Email of the object user became email
  The attribute Password of the object user became password
  The attribute Sex of the object user became sex
  The attribute Faculty of the object user became faculty
  The attribute LoanedNumber of the object user became 0
  The attribute BorrowStatus of the object user became NORMAL
  The attribute SuspensionDays of the object user became 0
  The attribute OverDueFee of the object user became 0
  The attribute Position of the object user became position
  The attribute Status of the object user became status
  The return value was true","   user.UserID = userID and
   user.Name = name and
   user.Email = email and
   user.Password = password and
   user.Sex = sex and
   user.Faculty = faculty and
   user.LoanedNumber = 0 and
   user.BorrowStatus = BorrowStatus::NORMAL and
   user.SuspensionDays = 0 and
   user.OverDueFee = 0 and
   user.Position = position and
   user.Status = status and
   result = true
",3,,
 The email is not equal to null,"   email <> """"
",3,,
 The return value was true,"   result = true
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
 user doesn't exist,"   user.oclIsUndefined() = true
",3,,
" use represented the object of class User
  The object use was created
  The attribute UserID of the object use became userid
  The attribute Name of the object use became name
  The attribute Sex of the object use became sex
  The attribute Password of the object use became password
  The attribute Email of the object use became email
  The attribute Faculty of the object use became faculty
  The attribute LoanedNumber of the object use became loanednumber
  The attribute BorrowStatus of the object use became borrowstatus
  The attribute SuspensionDays of the object use became suspensiondays
  The attribute OverDueFee of the object use became overduefee
  The object use was put into the instance set of class User
  The return value was true","   let use:User in
   use.oclIsNew() and
   use.UserID = userid and
   use.Name = name and
   use.Sex = sex and
   use.Password = password and
   use.Email = email and
   use.Faculty = faculty and
   use.LoanedNumber = loanednumber and
   use.BorrowStatus = borrowstatus and
   use.SuspensionDays = suspensiondays and
   use.OverDueFee = overduefee and
   User.allInstance()->includes(use) and
   result = true
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
 user exists,"   user.oclIsUndefined() = false
",3,,
 The return value was user,"   result = user
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
 user exists,"   user.oclIsUndefined() = false
",3,,
" The attribute UserID of the object user became userid
  The attribute Name of the object user became name
  The attribute Sex of the object user became sex
  The attribute Password of the object user became password
  The attribute Email of the object user became email
  The attribute Faculty of the object user became faculty
  The attribute LoanedNumber of the object user became loanednumber
  The attribute BorrowStatus of the object user became borrowstatus
  The attribute SuspensionDays of the object user became suspensiondays
  The attribute OverDueFee of the object user became overduefee
  The return value was true","   user.UserID = userid and
   user.Name = name and
   user.Sex = sex and
   user.Password = password and
   user.Email = email and
   user.Faculty = faculty and
   user.LoanedNumber = loanednumber and
   user.BorrowStatus = borrowstatus and
   user.SuspensionDays = suspensiondays and
   user.OverDueFee = overduefee and
   result = true
",3,,
" user is the object use in the instance set of class User. use represents an object of class User, and use meets:
      The attribute UserID of the object use is equal to userid","   user:User = User.allInstance()->any(use:User | use.UserID = userid)
",3,,
" user exists
  The object user is in the instance set of class User","   user.oclIsUndefined() = false and
   User.allInstance()->includes(user)
",3,,
" The object user was deleted from the instance set of class User
  The return value was true","   User.allInstance()->excludes(user) and
   result = true
",3,,
" book is the object boo in the instance set of class Book. boo represents an object of class Book, and boo meets:
      The attribute CallNo of the object boo is equal to callno","   book:Book = Book.allInstance()->any(boo:Book | boo.CallNo = callno)
",3,,
 book doesn't exist,"   book.oclIsUndefined() = true
",3,,
" boo represented the object of class Book
  The object boo was created
  The attribute CallNo of the object boo became callno
  The attribute Title of the object boo became title
  The attribute Edition of the object boo became edition
  The attribute Author of the object boo became author
  The attribute Publisher of the object boo became publisher
  The attribute Description of the object boo became description
  The attribute ISBn of the object boo became isbn
  The attribute CopyNum of the object boo became copynum
  The object boo was put into the instance set of class Book
  The return value was true","   let boo:Book in
   boo.oclIsNew() and
   boo.CallNo = callno and
   boo.Title = title and
   boo.Edition = edition and
   boo.Author = author and
   boo.Publisher = publisher and
   boo.Description = description and
   boo.ISBn = isbn and
   boo.CopyNum = copynum and
   Book.allInstance()->includes(boo) and
   result = true
",3,,
" book is the object boo in the instance set of class Book. boo represents an object of class Book, and boo meets:
      The attribute CallNo of the object boo is equal to callno","   book:Book = Book.allInstance()->any(boo:Book | boo.CallNo = callno)
",3,,
 book exists,"   book.oclIsUndefined() = false
",3,,
 The return value was book,"   result = book
",3,,
" book is the object boo in the instance set of class Book. boo represents an object of class Book, and boo meets:
      The attribute CallNo of the object boo is equal to callno","   book:Book = Book.allInstance()->any(boo:Book | boo.CallNo = callno)
",3,,
 book exists,"   book.oclIsUndefined() = false
",3,,
" The attribute CallNo of the object book became callno
  The attribute Title of the object book became title
  The attribute Edition of the object book became edition
  The attribute Author of the object book became author
  The attribute Publisher of the object book became publisher
  The attribute Description of the object book became description
  The attribute ISBn of the object book became isbn
  The attribute CopyNum of the object book became copynum
  The return value was true","   book.CallNo = callno and
   book.Title = title and
   book.Edition = edition and
   book.Author = author and
   book.Publisher = publisher and
   book.Description = description and
   book.ISBn = isbn and
   book.CopyNum = copynum and
   result = true
",3,,
" book is the object boo in the instance set of class Book. boo represents an object of class Book, and boo meets:
      The attribute CallNo of the object boo is equal to callno","   book:Book = Book.allInstance()->any(boo:Book | boo.CallNo = callno)
",3,,
" book exists
  The object book is in the instance set of class Book","   book.oclIsUndefined() = false and
   Book.allInstance()->includes(book)
",3,,
" The object book was deleted from the instance set of class Book
  The return value was true","   Book.allInstance()->excludes(book) and
   result = true
",3,,
" subject is the object sub in the instance set of class Subject. sub represents an object of class Subject, and sub meets:
      The attribute Name of the object sub is equal to name","   subject:Subject = Subject.allInstance()->any(sub:Subject | sub.Name = name)
",3,,
 subject doesn't exist,"   subject.oclIsUndefined() = true
",3,,
" sub represented the object of class Subject
  The object sub was created
  The attribute Name of the object sub became name
  The object sub was put into the instance set of class Subject
  The return value was true","   let sub:Subject in
   sub.oclIsNew() and
   sub.Name = name and
   Subject.allInstance()->includes(sub) and
   result = true
",3,,
" subject is the object sub in the instance set of class Subject. sub represents an object of class Subject, and sub meets:
      The attribute Name of the object sub is equal to name","   subject:Subject = Subject.allInstance()->any(sub:Subject | sub.Name = name)
",3,,
 subject exists,"   subject.oclIsUndefined() = false
",3,,
 The return value was subject,"   result = subject
",3,,
" subject is the object sub in the instance set of class Subject. sub represents an object of class Subject, and sub meets:
      The attribute Name of the object sub is equal to name","   subject:Subject = Subject.allInstance()->any(sub:Subject | sub.Name = name)
",3,,
 subject exists,"   subject.oclIsUndefined() = false
",3,,
" The attribute Name of the object subject became name
  The return value was true","   subject.Name = name and
   result = true
",3,,
" subject is the object sub in the instance set of class Subject. sub represents an object of class Subject, and sub meets:
      The attribute Name of the object sub is equal to name","   subject:Subject = Subject.allInstance()->any(sub:Subject | sub.Name = name)
",3,,
" subject exists
  The object subject is in the instance set of class Subject","   subject.oclIsUndefined() = false and
   Subject.allInstance()->includes(subject)
",3,,
" The object subject was deleted from the instance set of class Subject
  The return value was true","   Subject.allInstance()->excludes(subject) and
   result = true
",3,,
" book is the object b in the instance set of class Book. b represents an object of class Book, and b meets:
      The attribute CallNo of the object b is equal to callNo
  bc is the object c in all objects which book is linked to by Copys. c represents an object of class BookCopy, and c meets:
      The attribute Barcode of the object c is equal to barcode","   book:Book = Book.allInstance()->any(b:Book | b.CallNo = callNo),
   bc:BookCopy = book.Copys->any(c:BookCopy | c.Barcode = barcode)
",3,,
" book exists
  bc doesn't exist","   book.oclIsUndefined() = false and
   bc.oclIsUndefined() = true
",3,,
" copy represented the object of class BookCopy
  The object copy was created
  The attribute Barcode of the object copy became barcode
  The attribute Status of the object copy became AVAILABLE
  The attribute Location of the object copy became location
  The attribute IsReserved of the object copy became false
  The object book was linked to the object copy by Copys
  The object copy was linked to the object book by BookBelongs
  The attribute CopyNum of the object book became the previous value of the attribute CopyNum of the object book plus 1
  The object copy was put into the instance set of class BookCopy
  The return value was true","   let copy:BookCopy in
   copy.oclIsNew() and
   copy.Barcode = barcode and
   copy.Status = CopyStatus::AVAILABLE and
   copy.Location = location and
   copy.IsReserved = false and
   book.Copys->includes(copy) and
   copy.BookBelongs = book and
   book.CopyNum = book.CopyNum@pre + 1 and
   BookCopy.allInstance()->includes(copy) and
   result = true
",3,,
" bookcopy is the object boo in the instance set of class BookCopy. boo represents an object of class BookCopy, and boo meets:
      The attribute Barcode of the object boo is equal to barcode","   bookcopy:BookCopy = BookCopy.allInstance()->any(boo:BookCopy | boo.Barcode = barcode)
",3,,
 bookcopy exists,"   bookcopy.oclIsUndefined() = false
",3,,
 The return value was bookcopy,"   result = bookcopy
",3,,
" bookcopy is the object boo in the instance set of class BookCopy. boo represents an object of class BookCopy, and boo meets:
      The attribute Barcode of the object boo is equal to barcode","   bookcopy:BookCopy = BookCopy.allInstance()->any(boo:BookCopy | boo.Barcode = barcode)
",3,,
 bookcopy exists,"   bookcopy.oclIsUndefined() = false
",3,,
" The attribute Barcode of the object bookcopy became barcode
  The attribute Status of the object bookcopy became status
  The attribute Location of the object bookcopy became location
  The attribute IsReserved of the object bookcopy became isreserved
  The return value was true","   bookcopy.Barcode = barcode and
   bookcopy.Status = status and
   bookcopy.Location = location and
   bookcopy.IsReserved = isreserved and
   result = true
",3,,
" bookcopy is the object boo in the instance set of class BookCopy. boo represents an object of class BookCopy, and boo meets:
      The attribute Barcode of the object boo is equal to barcode","   bookcopy:BookCopy = BookCopy.allInstance()->any(boo:BookCopy | boo.Barcode = barcode)
",3,,
" bookcopy exists
  The object bookcopy is in the instance set of class BookCopy","   bookcopy.oclIsUndefined() = false and
   BookCopy.allInstance()->includes(bookcopy)
",3,,
" The object bookcopy was deleted from the instance set of class BookCopy
  The return value was true","   BookCopy.allInstance()->excludes(bookcopy) and
   result = true
",3,,
" librarian is the object lib in the instance set of class Librarian. lib represents an object of class Librarian, and lib meets:
      The attribute LibrarianID of the object lib is equal to librarianid","   librarian:Librarian = Librarian.allInstance()->any(lib:Librarian | lib.LibrarianID = librarianid)
",3,,
 librarian doesn't exist,"   librarian.oclIsUndefined() = true
",3,,
" lib represented the object of class Librarian
  The object lib was created
  The attribute LibrarianID of the object lib became librarianid
  The attribute Name of the object lib became name
  The attribute Password of the object lib became password
  The object lib was put into the instance set of class Librarian
  The return value was true","   let lib:Librarian in
   lib.oclIsNew() and
   lib.LibrarianID = librarianid and
   lib.Name = name and
   lib.Password = password and
   Librarian.allInstance()->includes(lib) and
   result = true
",3,,
" librarian is the object lib in the instance set of class Librarian. lib represents an object of class Librarian, and lib meets:
      The attribute LibrarianID of the object lib is equal to librarianid","   librarian:Librarian = Librarian.allInstance()->any(lib:Librarian | lib.LibrarianID = librarianid)
",3,,
 librarian exists,"   librarian.oclIsUndefined() = false
",3,,
 The return value was librarian,"   result = librarian
",3,,
" librarian is the object lib in the instance set of class Librarian. lib represents an object of class Librarian, and lib meets:
      The attribute LibrarianID of the object lib is equal to librarianid","   librarian:Librarian = Librarian.allInstance()->any(lib:Librarian | lib.LibrarianID = librarianid)
",3,,
 librarian exists,"   librarian.oclIsUndefined() = false
",3,,
" The attribute LibrarianID of the object librarian became librarianid
  The attribute Name of the object librarian became name
  The attribute Password of the object librarian became password
  The return value was true","   librarian.LibrarianID = librarianid and
   librarian.Name = name and
   librarian.Password = password and
   result = true
",3,,
" librarian is the object lib in the instance set of class Librarian. lib represents an object of class Librarian, and lib meets:
      The attribute LibrarianID of the object lib is equal to librarianid","   librarian:Librarian = Librarian.allInstance()->any(lib:Librarian | lib.LibrarianID = librarianid)
",3,,
" librarian exists
  The object librarian is in the instance set of class Librarian","   librarian.oclIsUndefined() = false and
   Librarian.allInstance()->includes(librarian)
",3,,
" The object librarian was deleted from the instance set of class Librarian
  The return value was true","   Librarian.allInstance()->excludes(librarian) and
   result = true
",3,,
" loanrequest is the object loa in the instance set of class LoanRequest. loa represents an object of class LoanRequest, and loa meets:
      The attribute RequestID of the object loa is equal to requestid","   loanrequest:LoanRequest = LoanRequest.allInstance()->any(loa:LoanRequest | loa.RequestID = requestid)
",3,,
 loanrequest doesn't exist,"   loanrequest.oclIsUndefined() = true
",3,,
" loa represented the object of class LoanRequest
  The object loa was created
  The attribute RequestID of the object loa became requestid
  The attribute Name of the object loa became name
  The attribute LoanAmount of the object loa became loanamount
  The attribute LoanPurpose of the object loa became loanpurpose
  The attribute Income of the object loa became income
  The attribute PhoneNumber of the object loa became phonenumber
  The attribute PostalAddress of the object loa became postaladdress
  The attribute ZipCode of the object loa became zipcode
  The attribute Email of the object loa became email
  The attribute WorkReferences of the object loa became workreferences
  The attribute CreditReferences of the object loa became creditreferences
  The attribute CheckingAccountNumber of the object loa became checkingaccountnumber
  The attribute SecurityNumber of the object loa became securitynumber
  The object loa was put into the instance set of class LoanRequest
  The object CurrentLoanRequest became loa
  The return value was true","   let loa:LoanRequest in
   loa.oclIsNew() and
   loa.RequestID = requestid and
   loa.Name = name and
   loa.LoanAmount = loanamount and
   loa.LoanPurpose = loanpurpose and
   loa.Income = income and
   loa.PhoneNumber = phonenumber and
   loa.PostalAddress = postaladdress and
   loa.ZipCode = zipcode and
   loa.Email = email and
   loa.WorkReferences = workreferences and
   loa.CreditReferences = creditreferences and
   loa.CheckingAccountNumber = checkingaccountnumber and
   loa.SecurityNumber = securitynumber and
   LoanRequest.allInstance()->includes(loa) and
   self.CurrentLoanRequest = loa and
   result = true
",3,,
 The object CurrentLoanRequest exists,"   self.CurrentLoanRequest.oclIsUndefined() = false
",3,,
" his represented the object of class CreditHistory
  The object his was created
  his became the return value of system operation getCreditHistory
  The object CurrentLoanRequest was linked to the object his by RequestedCreditHistory
  The object his was put into the instance set of class CreditHistory
  The return value was true","   let his:CreditHistory in
   his.oclIsNew() and
   his = getCreditHistory(CurrentLoanRequest.SecurityNumber, CurrentLoanRequest.Name) and
   CurrentLoanRequest.RequestedCreditHistory = his and
   CreditHistory.allInstance()->includes(his) and
   result = true
",3,,
 The object CurrentLoanRequest exists,"   self.CurrentLoanRequest.oclIsUndefined() = false
",3,,
" ca represented the object of class CheckingAccount
  The object ca was created
  ca became the return value of system operation getCheckingAccountStatus
  The object CurrentLoanRequest was linked to the object ca by RequestedCAHistory
  The object ca was put into the instance set of class CheckingAccount
  The return value was true","   let ca:CheckingAccount in
   ca.oclIsNew() and
   ca = getCheckingAccountStatus(self.CurrentLoanRequest.CheckingAccountNumber) and
   self.CurrentLoanRequest.RequestedCAHistory = ca and
   CheckingAccount.allInstance()->includes(ca) and
   result = true
",3,,
" The object CurrentLoanRequest exists
  CurrentLoanRequest exists
  CurrentLoanRequest exists","   self.CurrentLoanRequest.oclIsUndefined() = false and
   CurrentLoanRequest.RequestedCAHistory.oclIsUndefined() = false and
   CurrentLoanRequest.RequestedCreditHistory.oclIsUndefined() = false
",3,,
" The attribute CreditScore of the object CurrentLoanRequest became 100
  The attribute Status of the object CurrentLoanRequest became SUBMITTED
  The return value was the attribute CreditScore of the object CurrentLoanRequest","
   self.CurrentLoanRequest.CreditScore = 100 and
   self.CurrentLoanRequest.Status = LoanRequestStatus::SUBMITTED and
   result = self.CurrentLoanRequest.CreditScore
",3,,
" rs is the set of class LoanRequest, including all r in the instance set of class LoanRequest. r represents an object of class LoanRequest, and r meets:
      The attribute Status of the object r is equal to SUBMITTED","   rs:Set(LoanRequest) = LoanRequest.allInstance()->select(r:LoanRequest | r.Status =  LoanRequestStatus::SUBMITTED)
",3,,
 The size of rs is greater than 0,"   rs.size() > 0
",3,,
" The value of temporary variable CurrentLoanRequests became rs
  The return value was rs","   self.CurrentLoanRequests = rs and
   result = rs
",3,,
" rs is the object r in the set CurrentLoanRequests. r represents an object of class LoanRequest, and r meets:
      The attribute RequestID of the object r is equal to requestid","   rs:LoanRequest = self.CurrentLoanRequests->any(r:LoanRequest | r.RequestID = requestid)
",3,,
 rs exists,"   rs.oclIsUndefined() = false
",3,,
" The object CurrentLoanRequest became rs
  The return value was rs","   self.CurrentLoanRequest = rs and
   result = rs
",3,,
 The object CurrentLoanRequest exists,"   self.CurrentLoanRequest.oclIsUndefined() = false
",3,,
" The attribute Status of the object CurrentLoanRequest became REFERENCESVALIDATED
  The return value was true","   self.CurrentLoanRequest.Status = LoanRequestStatus::REFERENCESVALIDATED and
   result = true
",3,,
" rs is the set of class LoanRequest, including all r in the instance set of class LoanRequest. r represents an object of class LoanRequest, and r meets:
      The attribute Status of the object r is equal to REFERENCESVALIDATED","   rs:Set(LoanRequest) = LoanRequest.allInstance()->select(r:LoanRequest | r.Status =  LoanRequestStatus::REFERENCESVALIDATED)
",3,,
 rs exists,"   rs.oclIsUndefined() = false
",3,,
" The value of temporary variable CurrentLoanRequests became rs
  The return value was rs","   self.CurrentLoanRequests = rs and
   result = rs
",3,,
" rs is the object r in the set CurrentLoanRequests. r represents an object of class LoanRequest, and r meets:
      The attribute RequestID of the object r is equal to requestid","   rs:LoanRequest = self.CurrentLoanRequests->any(r:LoanRequest | r.RequestID = requestid)
",3,,
 rs exists,"   rs.oclIsUndefined() = false
",3,,
" The object CurrentLoanRequest became rs
  The return value was rs","   self.CurrentLoanRequest = rs and
   result = rs
",3,,
" The object CurrentLoanRequest exists
  CurrentLoanRequest exists","   self.CurrentLoanRequest.oclIsUndefined() = false and
   CurrentLoanRequest.RequestedCreditHistory.oclIsUndefined() = false
",3,,
 The return value was the object which CurrentLoanRequest was linked to by RequestedCreditHistory,"   result = CurrentLoanRequest.RequestedCreditHistory
",3,,
" The object CurrentLoanRequest exists
  CurrentLoanRequest exists","   self.CurrentLoanRequest.oclIsUndefined() = false and
   CurrentLoanRequest.RequestedCAHistory.oclIsUndefined() = false
",3,,
 The return value was the object which CurrentLoanRequest was linked to by RequestedCAHistory,"   result = CurrentLoanRequest.RequestedCAHistory
",3,,
 The return value was the instance set of class LoanTerm,"   result = LoanTerm.allInstance()
",3,,
" loanterm is the object loa in the instance set of class LoanTerm. loa represents an object of class LoanTerm, and loa meets:
      The attribute ItemID of the object loa is equal to termid","   loanterm:LoanTerm = LoanTerm.allInstance()->any(loa:LoanTerm | loa.ItemID = termid)
",3,,
" The object CurrentLoanRequest exists
  loanterm exists","   self.CurrentLoanRequest.oclIsUndefined() = false and
   loanterm.oclIsUndefined() = false
",3,,
" The object CurrentLoanRequest was linked to the object loanterm by AttachedLoanTerms
  The return value was true","   CurrentLoanRequest.AttachedLoanTerms->includes(loanterm) and
   result = true
",3,,
 The object CurrentLoanRequest exists,"   self.CurrentLoanRequest.oclIsUndefined() = false
",3,,
" The attribute Status of the object CurrentLoanRequest became APPROVED
  The return value was true","   self.CurrentLoanRequest.Status = LoanRequestStatus::APPROVED and
   result = true
",3,,
" rs is the set of class LoanRequest, including all r in the instance set of class LoanRequest. r represents an object of class LoanRequest, and r meets:
      The attribute Status of the object r is equal to APPROVED","   rs:Set(LoanRequest) = LoanRequest.allInstance()->select(r:LoanRequest | r.Status =  LoanRequestStatus::APPROVED)
",3,,
 rs exists,"   rs.oclIsUndefined() = false
",3,,
" The value of temporary variable CurrentLoanRequests became rs
  The return value was rs","   self.CurrentLoanRequests = rs and
   result = rs
",3,,
" r is the object lr in the instance set of class LoanRequest. lr represents an object of class LoanRequest, and lr meets:
      The attribute RequestID of the object lr is equal to id","   r:LoanRequest = LoanRequest.allInstance()->any(lr:LoanRequest | lr.RequestID = id)
",3,,
 r exists,"   r.oclIsUndefined() = false
",3,,
" l represented the object of class ApprovalLetter
  The object l was created
  The attribute Content of the object l became ""ApprovalLetterContent""
  The object r was linked to the object l by AttachedApprovalLetter
  The object CurrentLoanRequest became r
  The object l was put into the instance set of class ApprovalLetter
  The return value was true","   let l:ApprovalLetter in
   l.oclIsNew() and
   l.Content = ""ApprovalLetterContent"" and
   r.AttachedApprovalLetter = l and
   self.CurrentLoanRequest = r and
   ApprovalLetter.allInstance()->includes(l) and
   result = true
",3,,
 The object CurrentLoanRequest exists,"   self.CurrentLoanRequest.oclIsUndefined() = false
",3,,
 The object CurrentLoanRequest exists,"   self.CurrentLoanRequest.oclIsUndefined() = false
",3,,
" la represented the object of class LoanAgreement
  The object la was created
  The attribute Content of the object la became ""Loan Agreement""
  The object CurrentLoanRequest was linked to the object la by AttachedLoanAgreement
  The object la was put into the instance set of class LoanAgreement
  The return value was true","   let la:LoanAgreement in
   la.oclIsNew() and
   la.Content = ""Loan Agreement"" and
   self.CurrentLoanRequest.AttachedLoanAgreement = la and
   LoanAgreement.allInstance()->includes(la) and
   result = true
",3,,
 The object CurrentLoanRequest exists,"   self.CurrentLoanRequest.oclIsUndefined() = false
",3,,
" The system operation print was executed
  The return value was true","   print(CurrentLoanRequest.AttachedLoanAgreement.Content, number) and
   result = true
",3,,
" loan is the object loa in the instance set of class Loan. loa represents an object of class Loan, and loa meets:
      The attribute LoanID of the object loa is equal to loanid
  r is the object lr in the instance set of class LoanRequest. lr represents an object of class LoanRequest, and lr meets:
      The attribute RequestID of the object lr is equal to requestid
  la is the object lacc in the instance set of class LoanAccount. lacc represents an object of class LoanAccount, and lacc meets:
      The attribute LoanAccountID of the object lacc is equal to accountid","   loan:Loan = Loan.allInstance()->any(loa:Loan | loa.LoanID = loanid),
   r:LoanRequest = LoanRequest.allInstance()->any(lr:LoanRequest | lr.RequestID = requestid),
   la:LoanAccount = LoanAccount.allInstance()->any(lacc:LoanAccount | lacc.LoanAccountID = accountid)
",3,,
" loan doesn't exist
  r exists","   loan.oclIsUndefined() = true and
   r.oclIsUndefined() = false
",3,,
" loa represented the object of class Loan
  lacc represented the object of class LoanAccount
  The object loa was created
  The attribute LoanID of the object loa became loanid
  The attribute StartDate of the object loa became startdate
  The attribute EndDate of the object loa became enddate
  The attribute RePaymentDays of the object loa became repaymentdays
  The attribute Status of the object loa became LSOPEN
  The attribute RepaymentAmount of the object loa became the attribute LoanAmount of the object r
  The attribute CurrentOverDueDate of the object loa became the day repaymentdays after startdate
  If la didn't exist, take the following as postcondition(s):
      lacc became the return value of system operation createLoanAccount
      The object lacc was put into the instance set of class LoanAccount
      The attribute Balance of the object lacc became the attribute LoanAmount of the object r
      The object loa was linked to the object lacc by BelongedLoanAccount
  Otherwise, take the following as postcondition(s):
      The attribute Balance of the object la became the previous value of the attribute Balance of the object la plus the attribute LoanAmount of the object r
  The system operation transferFunds was executed
  The attribute RemainAmountToPay of the object loa became the attribute LoanAmount of the object r
  The object loa was put into the instance set of class Loan
  The object r was linked to the object loa by ApprovalLoan
  The object loa was linked to the object r by ReferedLoanRequest
  The return value was true","   let loa:Loan, lacc:LoanAccount in
   loa.oclIsNew() and
   loa.LoanID = loanid and
   loa.StartDate = startdate and
   loa.EndDate = enddate and
   loa.RePaymentDays = repaymentdays and
   loa.Status = LoanStatus::LSOPEN and
   loa.RepaymentAmount = r.LoanAmount and
   loa.CurrentOverDueDate = startdate.After(repaymentdays) and
   if
    la.oclIsUndefined() = true
   then
    lacc = createLoanAccount(accountid) and
    LoanAccount.allInstance()->includes(lacc) and
    lacc.Balance = r.LoanAmount and
    loa.BelongedLoanAccount = lacc
   else
    la.Balance = la.Balance@pre + r.LoanAmount
   endif and
   transferFunds(accountid, r.LoanAmount) and
   loa.RemainAmountToPay = r.LoanAmount and
   Loan.allInstance()->includes(loa) and
   r.ApprovalLoan = loa and
   loa.ReferedLoanRequest = r and
   result = true
",3,,
" loans is the set of class Loan, including all loa in the instance set of class Loan. loa represents an object of class Loan, and loa meets:
      The attribute Status of the object loa is equal to LSOPEN
      The day 3 days after Today is after the attribute CurrentOverDueDate of the object loa","   loans:Set(Loan) = Loan.allInstance()->select(loa:Loan | loa.Status = LoanStatus::LSOPEN and Today.After(3).isAfter(loa.CurrentOverDueDate))
",3,,
 loans exists,"   loans.oclIsUndefined() = false
",3,,
" For each object of class Loan in the set loans, l represented it(the object) and the following operations were performed:
      The system operation sendEmail was executed
  The return value was true","   loans->forAll(l:Loan |
    sendEmail(l.ReferedLoanRequest.Email, ""OverDueSoon"", ""You account is OverDueSoon""))
   and
   result = true
",3,,
" loans is the set of class Loan, including all loa in the instance set of class Loan. loa represents an object of class Loan, and loa meets:
      The attribute Status of the object loa is equal to LSOPEN
      Today is after the attribute CurrentOverDueDate of the object loa","   loans:Set(Loan) = Loan.allInstance()->select(loa:Loan | loa.Status = LoanStatus::LSOPEN and Today.isAfter(loa.CurrentOverDueDate))
",3,,
 loans exists,"   loans.oclIsUndefined() = false
",3,,
" For each object of class Loan in the set loans, l represented it(the object) and the following operations were performed:
      The system operation sendEmail was executed
  The return value was true","   loans->forAll(l:Loan |
    sendEmail(l.ReferedLoanRequest.Email, ""OverDued"", ""You are overdued, please repayment ASAP""))
   and
   result = true
",3,,
" loan is the object loa in the instance set of class Loan. loa represents an object of class Loan, and loa meets:
      The attribute LoanID of the object loa is equal to loanid","   loan:Loan = Loan.allInstance()->any(loa:Loan | loa.LoanID = loanid)
",3,,
" loan exists
  The attribute Status of the object loan is equal to LSOPEN","   loan.oclIsUndefined() = false and
   loan.Status = LoanStatus::LSOPEN
",3,,
" The attribute RemainAmountToPay of the object loan became the previous value of the attribute RemainAmountToPay of the object loan minus the attribute RepaymentAmount of the object loan
  The return value was true","   loan.RemainAmountToPay = loan.RemainAmountToPay@pre - loan.RepaymentAmount and
   result = true
",3,,
" loan is the object loa in the instance set of class Loan. loa represents an object of class Loan, and loa meets:
      The attribute LoanID of the object loa is equal to loanid","   loan:Loan = Loan.allInstance()->any(loa:Loan | loa.LoanID = loanid)
",3,,
" loan exists
  The attribute Status of the object loan is equal to LSOPEN","   loan.oclIsUndefined() = false and
   loan.Status = LoanStatus::LSOPEN
",3,,
" The attribute Status of the object loan became CLOSED
  The return value was true","   loan.Status = LoanStatus::CLOSED and
   result = true
",3,,
" loanterm is the object loa in the instance set of class LoanTerm. loa represents an object of class LoanTerm, and loa meets:
      The attribute ItemID of the object loa is equal to itemid","   loanterm:LoanTerm = LoanTerm.allInstance()->any(loa:LoanTerm | loa.ItemID = itemid)
",3,,
 loanterm doesn't exist,"   loanterm.oclIsUndefined() = true
",3,,
" loa represented the object of class LoanTerm
  The object loa was created
  The attribute ItemID of the object loa became itemid
  The attribute Content of the object loa became content
  The object loa was put into the instance set of class LoanTerm
  The return value was true","   let loa:LoanTerm in
   loa.oclIsNew() and
   loa.ItemID = itemid and
   loa.Content = content and
   LoanTerm.allInstance()->includes(loa) and
   result = true
",3,,
" loanterm is the object loa in the instance set of class LoanTerm. loa represents an object of class LoanTerm, and loa meets:
      The attribute ItemID of the object loa is equal to itemid","   loanterm:LoanTerm = LoanTerm.allInstance()->any(loa:LoanTerm | loa.ItemID = itemid)
",3,,
 loanterm exists,"   loanterm.oclIsUndefined() = false
",3,,
 The return value was loanterm,"   result = loanterm
",3,,
" loanterm is the object loa in the instance set of class LoanTerm. loa represents an object of class LoanTerm, and loa meets:
      The attribute ItemID of the object loa is equal to itemid","   loanterm:LoanTerm = LoanTerm.allInstance()->any(loa:LoanTerm | loa.ItemID = itemid)
",3,,
 loanterm exists,"   loanterm.oclIsUndefined() = false
",3,,
" The attribute ItemID of the object loanterm became itemid
  The attribute Content of the object loanterm became content
  The return value was true","   loanterm.ItemID = itemid and
   loanterm.Content = content and
   result = true
",3,,
" loanterm is the object loa in the instance set of class LoanTerm. loa represents an object of class LoanTerm, and loa meets:
      The attribute ItemID of the object loa is equal to itemid","   loanterm:LoanTerm = LoanTerm.allInstance()->any(loa:LoanTerm | loa.ItemID = itemid)
",3,,
" loanterm exists
  The object loanterm is in the instance set of class LoanTerm","   loanterm.oclIsUndefined() = false and
   LoanTerm.allInstance()->includes(loanterm)
",3,,
" The object loanterm was deleted from the instance set of class LoanTerm
  The return value was true","   LoanTerm.allInstance()->excludes(loanterm) and
   result = true
",3,,
 The return value was null,"   result = null
",3,,
 The return value was true,"   result = true
",3,,
